# 0 Why CMake?
# 1 Getting Started on Your Computer
## 1.2 Directory Structure
There are two main directories CMake uses when building a project: the source directory and the binary directory. The source directory is where the source code for the project is located. This is also where the CMakeLists files will be found. The binary directory is sometimes referred to as the build directory and is where CMake will put the resulting object files, libraries, and executables. CMake will not write any files to the source directory, only to the binary directory.
> CMake 主要使用源目录和二进制目录，源目录包含源代码，以及 CMakeLists 文件，二进制目录即构建目录，用于防止目标文件、库、可执行文件，CMake 不会对源目录写入任何文件 

Out-of-source builds, where the source and binary directories are different, are strongly encouraged. In-source builds where the source and binary directories are the same are supported but should be avoided if possible. Out-of-source builds make it very easy to maintain a clean source tree and allow quick removal of all of the files generated by a build. Having the build tree differ from the source tree also makes it easy to support having multiple builds of a single source tree. This is useful when you want to have multiple builds with different options but just one copy of the source code. 
> 鼓励源目录和二进制目录分离
## 1.3 Basic CMake Usage
CMake takes one or more CMakeLists files as input and produces project files or Makefiles for use with a wide variety of native development tools.
> CMake 接受 CMakeLists 文件为输入，输出项目文件或 Makefiles

The typical CMake process is as follows:
1. The project is defined in one or more CMakeLists files
2. CMake configures and generates the project
3. Users build project with their favorite native development tool

> 项目定义于 CMakeLists 文件中，CMake 配置并生成项目，用户自行构建项目

Each step of the process is described in detail in the following sections.
## 1.4 CMake Files
The CMakeLists files (actually `CMakeLists.txt` but it is common to leave off the extension) are plain text files that contain the project description in CMake’s Language. The [`cmake-language`](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#manual: cmake-language(7) "(in CMake v3.29.2)") is expressed as a series of comments, commands and variables. You might wonder why CMake decided to have its own language instead of using an existing one such as Python, Java, or Tcl. The main reason is that CMake developers did not want to make CMake require an additional tool to run. By requiring one of these other languages, all users of CMake would be required to have that language installed, and potentially a specific version of that language. This is on top of the language extensions that would be required to do some of the CMake work, for both performance and capability reasons. 
> CMakeLists 为纯文本，用 cmake 语言描述，即一系列的注释、命令、变量
### 1.4.1 Hello World for CMake
To begin, let us consider the simplest possible CMakeLists file. To compile an executable from one source file, the CMakeLists file would contain three lines:

```
cmake_minimum_required(VERSION 3.20)
project(Hello)
add_executable(Hello Hello.c)
```

The first line of the top level CMakeLists file should always be [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html#command: cmake_minimum_required "(in CMake v3.29.2)"). This allows projects to require a given version of CMake and, in addition, allows CMake to be backwards compatible. (CMakeLists 的第一行一定是 `cmake_minimum_required` ，以要求特定版本的 CMake )

The next line of any top level CMakeLists file should be the [`project`](https://cmake.org/cmake/help/latest/command/project.html#command: project "(in CMake v3.29.2)") command. This command sets the name of the project and may specify other options such as language or version. ( 任意顶级的 CMakeLists 的下一行应该是 `project` 命令，设定项目的名称 )

For each directory in a project where the CMakeLists.txt file invokes the [`project`](https://cmake.org/cmake/help/latest/command/project.html#command: project "(in CMake v3.29.2)") command, CMake generates a top-level Makefile or IDE project file. The project will contain all targets that are in the CMakeLists.txt file and any subdirectories, as specified by the [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command: add_subdirectory "(in CMake v3.29.2)") command. If the [`EXCLUDE_FROM_ALL`](https://cmake.org/cmake/help/latest/prop_dir/EXCLUDE_FROM_ALL.html#prop_dir: EXCLUDE_FROM_ALL "(in CMake v3.29.2)") option is used in the [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command: add_subdirectory "(in CMake v3.29.2)") command, the generated project will not appear in the top-level Makefile or IDE project file; this is useful for generating sub-projects that do not make sense as part of the main build process. ( 项目中的任意目录中，只要 CMakeLists 调用了 `project` 命令，CMake 就会生成一个顶级的 Makefile 或 IDE 项目文件，该项目包含 CMakeLists 文件中的所有目标以及子目录，子目录由 `add_subdirectory` 命令添加，若使用的 `EXCLUDE_FROM_ALL` 选项，则生成的项目不会出现在顶层的 Makefile 或 IDE 项目文件中，因此这对于生成与主构建过程的子项目是有帮助的 )

Consider that a project with a number of examples could use this feature to generate the build files for each example with one run of CMake, but not have the examples built as part of the normal build process. 

Finally, use the [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)") command to add an executable to the project using the given source file. ( `add_executable` 使用给定的源文件向项目中添加可执行目标 )

In this example, there are two files in the source directory: `CMakeLists.txt` and `Hello.c`.

The next sections will describe how to configure and build the project using the CMake GUI and command line interfaces.
## 1.5 Configure and Generate
### 1.5.1 Running CMake from the Command Line
From the command line, the [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)") executable can be used to generate a project buildsystem. This is best suited for projects with few or no options. For larger projects like VTK, using [`ccmake`](https://cmake.org/cmake/help/latest/manual/ccmake.1.html#manual:ccmake(1) "(in CMake v3.29.2)"), or the [`cmake-gui`](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual: cmake-gui(1) "(in CMake v3.29.2)") is recommended. 

To build a project with [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)"), first create and change directory to where you want the binaries to be placed. Run [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)") specifying the path to the source tree and pass in any options using the `-D` flag. Unlike [`ccmake`](https://cmake.org/cmake/help/latest/manual/ccmake.1.html#manual:ccmake(1) "(in CMake v3.29.2)"), or the [`cmake-gui`](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual: cmake-gui(1) "(in CMake v3.29.2)"), the configure and generate steps are combined into one when using the [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)") executable. 
>首先创建二进制目录，并进入该目录，运行 `cmake` 并指定源目录的路径，通过 `-D` 标志向 CMake 传递选项 
### 1.5.2 Specifying the Compiler to CMake
On some systems, you may have more than one compiler to choose from or your compiler may be in a non-standard place. In these cases, you will need to specify to CMake where your desired compiler is located. There are three ways to specify this: the generator can specify the compiler; an environment variable can be set; or a cache entry can be set. Some generators are tied to a specific compiler; for example, the Visual Studio 19 generator always uses the Microsoft Visual Studio 19 compiler. For Makefile-based generators, CMake will try a list of usual compilers until it finds a working one. ( 可以向 CMake 指定我们需要的编译器的位置，有三种方法：可以用生成器指定、可以使用环境变量、可以设定 cache 项，一些生成器绑定了特定编译器，对于基于 Makefile 的生成器，CMake 会尝试一系列常用的编译器直到找到一个可以工作的 )

The lists can be preempted with environment variables that can be set before CMake is run. The `CC` environment variable specifies the C compiler, while `CXX` specifies the C++ compiler. You can specify the compilers directly on the command line by using `-DCMAKE_CXX_COMPILER=cl` for example. Once [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)") has been run and picked a compiler, if you wish to change the compiler, start over with an empty binary directory. ( 环境变量的优先级高于默认查询的列表，在 cmake 已经开始运行并选择了一个编译器后，如果我们想要改变编译器，就需要从一个新的空二进制目录开始 )

The flags for the compiler and the linker can also be changed by setting environment variables. Setting `LDFLAGS` will initialize the cache values for link flags, while `CXXFLAGS` and `CFLAGS` will initialize `CMAKE_CXX_FLAGS` and `CMAKE_C_FLAGS` respectively. ( 设定环境变量也可以改变编译器和链接器选项)
### 1.5.3 Build Configurations
Build configurations allow a project to be built in different ways for debug, optimized, or any other special set of flags. CMake supports, by default, Debug, Release, MinSizeRel, and RelWithDebInfo configurations. Debug has the basic debug flags turned on. Release has the basic optimizations turned on. MinSizeRel has flags that produce the smallest object code, but not necessarily the fastest code. RelWithDebInfo builds an optimized build with debug information as well. ( CMake 默认支持 Debug, Release, MinSizeRel, and RelWithDebInfo 的构建配置，不同的构建配置有不同的编译选项 )

CMake handles the configurations in slightly different ways depending on the generator being used. The conventions of the native build system are followed when possible. This means that configurations impact the build in different ways when using Makefiles versus using Visual Studio project files. ( 取决于使用的生成器，CMake 处理配置的方式有所不同，即使用 Makefiles 和使用 VS 项目文件时，配置影响是略有不同的 )

The Visual Studio IDE supports the notion of Build Configurations. A default project in Visual Studio usually has Debug and Release configurations. From the IDE you can select build Debug, and the files will be built with Debug flags.  ( VS 支持构建配置的概念，例如 Debug 配置下，文件就通过 Debug 选项构建) 

The IDE puts all of the binary files into directories with the name of the active configuration. ( IDE 将所有的二进制文件放入名称与活跃配置一致的文件夹 )
This brings about an extra complexity for projects that build programs that need to be run as part of the build process from custom commands. See the [`CMAKE_CFG_INTDIR`](https://cmake.org/cmake/help/latest/variable/CMAKE_CFG_INTDIR.html#variable: CMAKE_CFG_INTDIR "(in CMake v3.29.2)") variable and the custom commands section for more information about how to handle this issue. The variable [`CMAKE_CONFIGURATION_TYPES`](https://cmake.org/cmake/help/latest/variable/CMAKE_CONFIGURATION_TYPES.html#variable: CMAKE_CONFIGURATION_TYPES "(in CMake v3.29.2)") is used to tell CMake which configurations to put in the workspace.  ( 变量 `CMAKE_CONFIGURATION_TYPES` 用于告诉 CMake 将哪个配置放在工作空间 )

With Makefile-based generators, only one configuration can be active at the time CMake is run, and it is specified with the [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html#variable: CMAKE_BUILD_TYPE "(in CMake v3.29.2)") variable. ( 基于 Makefile 的生成器只能在 CMake 运行时活跃一个配置，它由 `CMAKE_BUILD_TYPE` 变量指定 )
If the variable is empty then no flags are added to the build. If the variable is set to the name of a configuration, then the appropriate variables and rules (such as `CMAKE_CXX_FLAGS_<ConfigName>`) are added to the compile lines. ( 若变量为空，则构建不会添加任何标志，若变量设定为配置的名称，则恰当的变量和规则会被添加到编译行 )
Makefiles do not use special configuration subdirectories for object files. To build both debug and release trees, the user is expected to create multiple build directories using the out-of-source build feature of CMake, and set the [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html#variable: CMAKE_BUILD_TYPE "(in CMake v3.29.2)") to the desired selection for each build. ( Makefiles 不会使用特殊的配置子目录，要同时构建 debug 和 release 树，用户需要创建多个构建目录，并对各个构建设定好  `CMAKE_BUILD_TYPE` )
For example:
```
# With source code in the directory MyProject
# to build MyProject-debug create that directory, cd into it and
ccmake ../MyProject -DCMAKE_BUILD_TYPE=Debug
# the same idea is used for the release tree MyProject-release
ccmake ../MyProject -DCMAKE_BUILD_TYPE=Release
```
## 1.6 Building Your Project
After you have run CMake, your project will be ready to be built. If your target generator is based on Makefiles then you can build your project by changing the directory to your binary tree and typing make (or gmake or nmake as appropriate). If you generated files for an IDE such as Visual Studio, you can start your IDE, load the project files into it, and build as you normally would. ( 运行好 CMake 之后，我们的项目就可以构建了，若目标生成器基于 Makefiles，则可以将目录切换到二进制树，然后 `make` ，若生成器基于 IDE，则可以启动 IDE，装载项目文件，然后构建 )

Another option is to use [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)")’s `--build` option from the command line. This option is simply a convenience that allows you to build your project from the command line, even if that requires launching an IDE. ( 添加 `--build` 选项以直接构建 )

That is all there is to installing and running CMake for simple projects. In the following chapters, we will consider CMake in more detail and explain how to use it on more complex software projects.
# 2 Writing CMakeLists Files
This chapter will cover the basics of writing effective CMakeLists files for your software. It will cover the basic commands and issues you will need to handle most projects. ( 本章介绍编写 CMakeLists 的基础 )

The CMakeLists files determine everything from which options to present to users, to which source files to compile. In addition to discussing how to write a CMakeLists file, this chapter will also cover how to make them robust and maintainable.
## 2.1 Editing CMakeLists Files
CMakeLists files can be edited in almost any text editor. For editors such as Emacs or Vim, CMake includes indentation and syntax highlighting modes. These can be found in the `Auxiliary` directory of the source distribution, or downloaded from the CMake [Download](https://cmake.org/cmake/help/book/mastering-cmake/chapter/www.cmake.org/download) page. ( CMake 为 Vim 提供了缩进和语法高亮模式 )

Within any of the supported generators (Makefiles, Visual Studio, etc.), if you edit a CMakeLists file and rebuild, there are rules that will automatically invoke CMake to update the generated files (e.g. Makefiles or project files) as required. This helps to assure that your generated files are always in sync with your CMakeLists files. ( 编辑了 CMakeLists 并重构时，需要生成的文件例如 Makefiles 或项目文件会自动更新，保持与 CMakeLists 同步 )
## 2.2 CMake Language
The CMake language is composed of comments, commands, and variables.
## 2.3 Comments
Comments start with `#` and run to the end of the line. See the [`cmake-language`](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#manual: cmake-language(7) "(in CMake v3.29.2)") manual for more details. ( 注释以 `#` 开始 )
## 2.4 Variables
CMakeLists files use variables much like any programming language. CMake variable names are case sensitive and may only contain alphanumeric characters and underscores. ( 变量命名和编程语言一致 )

A number of useful variables are automatically defined by CMake and are discussed in the [`cmake-variables`](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html#manual: cmake-variables(7) "(in CMake v3.29.2)") manual. These variables begin with `CMAKE_`. Avoid this naming convention (and, ideally, establish your own) for variables specific to your project. ( CMake 自身定义了一些以 `CMAKE_` 开头的变量 )

All CMake variables are stored internally as strings although they may sometimes be interpreted as other types. ( 所有的 CMake 变量都以字符串形式存储 )

Use the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command:set "(in CMake v3.29.2)") command to set variable values. In its simplest form, the first argument to [`set`](https://cmake.org/cmake/help/latest/command/set.html#command:set "(in CMake v3.29.2)") is the name of the variable and the rest of the arguments are the values. Multiple value arguments are packed into a semicolon-separated list and stored in the variable as a string. For example:
```
set(Foo "")      # 1 quoted arg -> value is ""
set(Foo a)       # 1 unquoted arg -> value is "a"
set(Foo "a b c") # 1 quoted arg -> value is "a b c"
set(Foo a b c)   # 3 unquoted args -> value is "a;b;c"
```
( `set(变量名 值)`  ，传入多个值，值会由 `;` 分隔 )

Variables may be referenced in command arguments using syntax `${VAR}` where `VAR` is the variable name.  ( 变量使用 `${VAR}` 语法引用 )

If the named variable is not defined, the reference is replaced with an empty string; otherwise it is replaced by the value of the variable. ( 若变量名未定义，则会被替换为空字符串 )

Replacement is performed prior to the expansion of unquoted arguments, so variable values containing semicolons are split into zero-or-more arguments in place of the original unquoted argument. For example:  ( 对于没有用引号包围的变量，它在展开之前会先进行替换，因此用 `;` 分隔的变量值会被替换为一个或多个参数，如果用引号包围它，即 `"${VAR}"` ，则保留原始字符串 )
```
set(Foo a b c)    # 3 unquoted args -> value is "a;b;c"
command(${Foo})   # unquoted arg replaced by a;b;c
                  # and expands to three arguments
command("${Foo}") # quoted arg value is "a;b;c"
set(Foo "")       # 1 quoted arg -> value is empty string
command(${Foo})   # unquoted arg replaced by empty string
                  # and expands to zero arguments
command("${Foo}") # quoted arg value is empty string
```

System environment variables and Windows registry values can be accessed directly in CMake. To access system environment variables, use the syntax `$ENV{VAR}`. CMake can also reference registry entries in many commands using a syntax of the form `[HKEY_CURRENT_USER\\Software\\path1\\path2;key]`, where the paths are built from the registry tree and key. ( CMake 可以直接访问系统环境变量和 Windows 注册表项，系统环境变量使用 `$ENV{VAR}` 语法访问，注册表项使用 `[HKEY_CURRENT_USER\\Software\\path1\\path2;key]` 语法访问 )
### 2.4.1 Variable Scope
Variables in CMake have a scope that is a little different from most languages. When you set a variable, it is visible to the current CMakeLists file or function and any subdirectory’s CMakeLists files, any functions or macros that are invoked, and any files that are included using the [`include`](https://cmake.org/cmake/help/latest/command/include.html#command: include "(in CMake v3.29.2)") command. ( 当前 CMakeLists 文件中的变量对当前 CMakeLists 中的函数以及任意子目录中的 CMakeLists 可见，以及任意被调用的函数和宏，以及任意使用 `include` 命令包含的文件 )

When a new subdirectory is processed (or a function called), a new variable scope is created and initialized with the current value of all variables in the calling scope. Any new variables created in the child scope, or changes made to existing variables, will not impact the parent scope. ( 处理新的子目录或者调用函数时，会创建新的变量作用域，并用调用域的所有变量当前值进行初始化，在子域中创建的新变量，以及对变量值的改变对父域没有影响 )

Consider the following example:
```
function(foo)
  message(${test}) # test is 1 here
  set(test 2)
  message(${test}) # test is 2 here, but only in this scope
endfunction()

set(test 1)
foo()
message(${test}) # test will still be 1 here
```

In some cases, you might want a function or subdirectory to set a variable in its parent’s scope. There is a way for CMake to return a value from a function, and it can be done by using the `PARENT_SCOPE` option with the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command. We can modify the prior example so that the function `foo` changes the value of test in its parent’s scope as follows: ( 若需要子目录或函数改变父域的变量值，则需要利用函数返回值，或者在 `set` 中使用 ` PARENT_SCOPE` 选项 )
```
function(foo)
  message(${test}) # test is 1 here
  set(test 2 PARENT_SCOPE)
  message(${test}) # test still 1 in this scope
endfunction()

set(test 1)
foo()
message(${test}) # test will now be 2 here
```

Variables in CMake are defined in the order of the execution of [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") commands. ( CMake 中的变量值由 `set` 的顺序定义 )

Consider the following example:
```
# FOO is undefined

set(FOO 1)
# FOO is now set to 1

set(FOO 0)
# FOO is now set to 0
```

To understand the scope of variables, consider this example:
```
set(foo 1)

# process the dir1 subdirectory
add_subdirectory(dir1)

# include and process the commands in file1.cmake
include(file1.cmake)

set(bar 2)
# process the dir2 subdirectory
add_subdirectory(dir2)

# include and process the commands in file2.cmake
include(file2.cmake)
```

In this example, because the variable `foo` is defined at the beginning, it will be defined while processing both dir1 and dir2. In contrast, `bar` will only be defined when processing dir2. Likewise, `foo` will be defined when processing both file1.cmake and file2.cmake, whereas `bar` will only be defined while processing file2.cmake.
## 2.5 Commands
A command consists of the command name, opening parenthesis, whitespace separated arguments, and a closing parenthesis. Each command is evaluated in the order that it appears in the CMakeLists file. See the [`cmake-commands`](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html#manual: cmake-commands(7) "(in CMake v3.29.2)") manual for a full list of CMake commands. ( 命令格式为 `<command-name>(<argument> <argument> ...)` 命令按顺序执行 )

CMake is no longer case sensitive to command names, so where you see `command`, you could use `COMMAND` or `Command` instead. It is considered best practice to use lowercase commands. All whitespace (spaces, line feeds, tabs) is ignored except to separate arguments. Therefore, commands may span multiple lines as long as the command name and the opening parenthesis are on the same line. ( CMake 的命令大小写不敏感，推荐使用小写命令，空格以及各种空白符除了分隔参数都会被忽略 )

CMake command arguments are space separated and case sensitive. ( 命令的参数大小写敏感 )
Command arguments may be either quoted or unquoted. A quoted argument starts and ends in a double quote (“) and always represents exactly one argument. ( 被引号包围的参数永远仅表示一个参数 )
Any double quotes contained inside the value must be escaped with a backslash. ( 要在变量值内包含引号，则需要转义 )

Consider using bracket arguments for arguments that require escaping, see the [`cmake-language`](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#manual: cmake-language(7) "(in CMake v3.29.2)") manual. ( 对于需要转义的参数，考虑使用 `[]` )

An unquoted argument starts in any character other than a double quote (later double quotes are literal) and is automatically expanded into zero-or-more arguments by separating on semicolons within the value. For example: 
```
command("")          # 1 quoted argument
command("a b c")     # 1 quoted argument
command("a;b;c")     # 1 quoted argument
command("a" "b" "c") # 3 quoted arguments
command(a b c)       # 3 unquoted arguments
command(a;b;c)       # 1 unquoted argument expands to 3
```
( 如果参数内有 `;` 且未被引号包围，它会被自动展开)
### 2.5.1 Basic Command
As we saw earlier, the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") and [`unset`](https://cmake.org/cmake/help/latest/command/unset.html#command: unset "(in CMake v3.29.2)") commands explicitly set or unset variables. The [`string`](https://cmake.org/cmake/help/latest/command/string.html#command: string "(in CMake v3.29.2)"), [`list`](https://cmake.org/cmake/help/latest/command/list.html#command: list "(in CMake v3.29.2)"), and [`separate_arguments`](https://cmake.org/cmake/help/latest/command/separate_arguments.html#command: separate_arguments "(in CMake v3.29.2)") commands offer basic manipulation of strings and lists. ( 设置变量: `set/unset` ，操作字符串和列表: `string/list/separate_arguments` )

The [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)") and [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") commands are the main commands for defining the executables and libraries to build, and which source files comprise them. ( `add_executable/library` 添加需要构建的库和可执行文件，同时指定所需的源文件 )

For Visual Studio projects, the source files will show up in the IDE as usual, but any header files the project uses will not be. To have the header files show up, simply add them to the list of source files for the executable or library; this can be done for all generators. ( 对于项目文件，如果需要头文件也展示在其中，则直接将它们添加为可执行文件或库的需求源文件即可 )

Any generators that do not use the header files directly (such as Makefile based generators) will simply ignore them. ( 基于 Makefile 的生成器不直接使用头文件，则会简单忽略它们 )
## 2.6 Flow Control
The CMake language provides three flow control constructs to help organize your CMakeLists files and keep them maintainable.
- Conditional statements (e.g. [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)"))
- Looping constructs (e.g. [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") and [`while`](https://cmake.org/cmake/help/latest/command/while.html#command: while "(in CMake v3.29.2)"))
- Procedure definitions (e.g. [`macro`](https://cmake.org/cmake/help/latest/command/macro.html#command: macro "(in CMake v3.29.2)") and [`function`](https://cmake.org/cmake/help/latest/command/function.html#command: function "(in CMake v3.29.2)"))
( 流控制语句： `if` , `foreach/while` , `macro/function` )
### 2.6.1 Conditional Statements
First we will consider the [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)") command. In many ways, the [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)") command in CMake is just like the [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)") command in any other language. It evaluates its expression and uses it to execute the code in its body or optionally the code in the [`else`](https://cmake.org/cmake/help/latest/command/else.html#command: else "(in CMake v3.29.2)") clause. For example:
```
if(FOO)
  # do something here
else()
  # do something else
endif()
```

CMake also supports [`elseif`](https://cmake.org/cmake/help/latest/command/elseif.html#command:elseif "(in CMake v3.29.2)") to help sequentially test for multiple conditions. For example:

```
if(MSVC80)
  # do something here
elseif(MSVC90)
  # do something else
elseif(APPLE)
  # do something else
endif()
```

The [`if`](https://cmake.org/cmake/help/latest/command/if.html#command:if "(in CMake v3.29.2)") command documents the many conditions it can test.
### 2.6.2 Looping Constructs
The [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") and [`while`](https://cmake.org/cmake/help/latest/command/while.html#command: while "(in CMake v3.29.2)") commands allow you to handle repetitive tasks that occur in sequence. The [`break`](https://cmake.org/cmake/help/latest/command/break.html#command: break "(in CMake v3.29.2)") command breaks out of a [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") or [`while`](https://cmake.org/cmake/help/latest/command/while.html#command: while "(in CMake v3.29.2)") loop before it would normally end.

The [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") command enables you to execute a group of CMake commands repeatedly on the members of a list. Consider the following example adapted from VTK ( `foreach` 即迭代列表中的变量值来反复执行命令 )
```
foreach(tfile
        TestAnisotropicDiffusion2D
        TestButterworthLowPass
        TestButterworthHighPass
        TestCityBlockDistance
        TestConvolve
        )
  add_test(${tfile}-image ${VTK_EXECUTABLE}
    ${VTK_SOURCE_DIR}/Tests/rtImageTest.tcl
    ${VTK_SOURCE_DIR}/Tests/${tfile}.tcl
    -D ${VTK_DATA_ROOT}
    -V Baseline/Imaging/${tfile}.png
    -A ${VTK_SOURCE_DIR}/Wrapping/Tcl
    )
endforeach()
```

The first argument of the [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") command is the name of the variable that will take on a different value with each iteration of the loop; the remaining arguments are the list of values over which to loop. In this example, the body of the [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") loop is just one CMake command, [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command: add_test "(in CMake v3.29.2)"). In the body of the [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)"), each time the loop variable (`tfile` in this example) is referenced will be replaced with the current value from the list. In the first iteration, occurrences of `${tfile}` will be replaced with `TestAnisotropicDiffusion2D`. In the next iteration, `${tfile}` will be replaced with `TestButterworthLowPass`. The [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") loop will continue to loop until all of the arguments have been processed. ( `foreach` 的语法 `foreach(<variable-name> <value-1> <value-2> ...)`)

It is worth mentioning that [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command:foreach "(in CMake v3.29.2)") loops can be nested, and that the loop variable is replaced prior to any other variable expansion. This means that in the body of a [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command:foreach "(in CMake v3.29.2)") loop, you can construct variable names using the loop variable. In the code below, the loop variable `tfile` is expanded, and then concatenated with `_TEST_RESULT`. The new variable name is then expanded and tested to see if it matches `FAILED`.
```
if(${${tfile}_TEST_RESULT} MATCHES FAILED)
  message("Test ${tfile} failed.")
endif()
```
( `foreach` 循环变量的展开比任何其他变量的展开都早，可以利用这一性质构建变量名 )

The [`while`](https://cmake.org/cmake/help/latest/command/while.html#command:while "(in CMake v3.29.2)") command provides looping based on a test condition. The format for the test expression in the [`while`](https://cmake.org/cmake/help/latest/command/while.html#command:while "(in CMake v3.29.2)") command is the same as it is for the [`if`](https://cmake.org/cmake/help/latest/command/if.html#command:if "(in CMake v3.29.2)") command, as described earlier. Consider the following example, which is used by CTest. Note that CTest updates the value of `CTEST_ELAPSED_TIME` internally.
```
#####################################################
# run paraview and ctest test dashboards for 6 hours
#
while(${CTEST_ELAPSED_TIME} LESS 36000)
  set(START_TIME ${CTEST_ELAPSED_TIME})
  ctest_run_script("dash1_ParaView_vs71continuous.cmake")
  ctest_run_script("dash1_cmake_vs71continuous.cmake")
endwhile()
```
### 2.6.3 Procedure Definitions
The [`macro`](https://cmake.org/cmake/help/latest/command/macro.html#command: macro "(in CMake v3.29.2)") and [`function`](https://cmake.org/cmake/help/latest/command/function.html#command: function "(in CMake v3.29.2)") commands support repetitive tasks that may be scattered throughout your CMakeLists files. Once a macro or function is defined, it can be used by any CMakeLists files processed after its definition.

A function in CMake is very much like a function in C or C++. You can pass arguments into it, and they become variables within the function. Likewise, some standard variables such as `ARGC`, `ARGV`, `ARGN`, and `ARGV0`, `ARGV1`, etc. are defined. Function calls have a dynamic scope. Within a function you are in a new variable scope; this is like how you drop into a subdirectory using the [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command: add_subdirectory "(in CMake v3.29.2)") command and are in a new variable scope. All the variables that were defined when the function was called remain defined, but any changes to variables or new variables only exist within the function. When the function returns, those variables will go away. Put more simply: when you invoke a function, a new variable scope is pushed; when it returns, that variable scope is popped. ( CMake 函数定义了一些标准变量，例如 `ARGC, ARGV, ARGN, ARGV0, ARGV1` 等，函数具有动态作用域，即函数内的作用域是新创建的，可以把作用域理解为调用栈 )

The [`function`](https://cmake.org/cmake/help/latest/command/function.html#command:function "(in CMake v3.29.2)") command defines a new function. The first argument is the name of the function to define; all additional arguments are formal parameters to the function.
```
function(DetermineTime _time)
  # pass the result up to whatever invoked this
  set(${_time} "1:23:45" PARENT_SCOPE)
endfunction()

# now use the function we just defined
DetermineTime(current_time)

if(DEFINED current_time)
  message(STATUS "The time is now: ${current_time}")
endif()
```
( `function` 命令用于定义函数，第一个参数是函数名称，其余参数为函数形参 )

Note that in this example, `_time` is used to pass the name of the return variable. The [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command is invoked with the value of `_time`, which will be `current_time`. Finally, the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command uses the `PARENT_SCOPE` option to set the variable in the caller’s scope instead of the local scope. 
( 上例中，形参  `_time` 用于传递返回变量的名称，函数中使用 `set` 改变父作用域中 `_time` 所表示的变量的值 )

Macros are defined and called in the same manner as functions. The main differences are that a macro does not push and pop a new variable scope, and that the arguments to a macro are not treated as variables but as strings replaced prior to execution. 
( 宏和函数的区别在于宏不会构建新的变量作用域，且传递给宏的参数不会被视为变量，而是在宏执行之前被直接替换 )

This is very much like the differences between a macro and a function in C or C++. The first argument is the name of the macro to create; all additional arguments are formal parameters to the macro. ( 第一个参数为宏名称，其余为形参 )
```cmake
# define a simple macro
macro(assert TEST COMMENT)
  if(NOT ${TEST})
    message("Assertion failed: ${COMMENT}")
  endif()
endmacro()

# use the macro
find_library(FOO_LIB foo /usr/local/lib)
assert(${FOO_LIB} "Unable to find library foo")
```

The simple example above creates a macro called `assert`. The macro is defined into two arguments; the first is a value to test and the second is a comment to print out if the test fails. The body of the macro is a simple [`if`](https://cmake.org/cmake/help/latest/command/if.html#command:if "(in CMake v3.29.2)") command with a [`message`](https://cmake.org/cmake/help/latest/command/message.html#command:message "(in CMake v3.29.2)") command inside of it. The macro body ends when the [`endmacro`](https://cmake.org/cmake/help/latest/command/endmacro.html#command:endmacro "(in CMake v3.29.2)") command is found. The macro can be invoked simply by using its name as if it were a command. In the above example, if `FOO_LIB` was not found then a message would be displayed indicating the error condition.

The [`macro`](https://cmake.org/cmake/help/latest/command/macro.html#command: macro "(in CMake v3.29.2)") command also supports defining macros that take variable argument lists. This can be useful if you want to define a macro that has optional arguments or multiple signatures. Variable arguments can be referenced using `ARGC` and `ARGV0`, `ARGV1`, etc., instead of the formal parameters. `ARGV0` represents the first argument to the macro; `ARGV1` represents the next, and so forth. You can also use a mixture of formal arguments and variable arguments, as shown in the example below. ( `macro` 命令还支持变长参数列表，可以通过使用 `ARGC` 和 `ARGV0, ARGV1` 引用，变长参数列表和形式参数可以结合使用 )
```cmake
# define a macro that takes at least two arguments
# (the formal arguments) plus an optional third argument
macro(assert TEST COMMENT)
  if(NOT ${TEST})
    message("Assertion failed: ${COMMENT}")

    # if called with three arguments then also write the
    # message to a file specified as the third argument
    if(${ARGC} MATCHES 3)
      file(APPEND ${ARGV2} "Assertion failed: ${COMMENT}")
    endif()

  endif()
endmacro()

# use the macro
find_library(FOO_LIB foo /usr/local/lib)
assert(${FOO_LIB} "Unable to find library foo")
```
In this example, the two required arguments are `TEST` and `COMMENT`. These required arguments can be referenced by name, as they are in this example, or by referencing `ARGV0` and `ARGV1`. If you want to process the arguments as a list, use the `ARGV` and `ARGN` variables. `ARGV` (as opposed to `ARGV0`, `ARGV1`, etc) is a list of all the arguments to the macro, while `ARGN` is a list of all the arguments after the formal arguments. Inside your macro, you can use the [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command: foreach "(in CMake v3.29.2)") command to iterate over `ARGV` or `ARGN` as desired. ( `ARGN` 是所有形式参数之后参数的列表 )

The [`return`](https://cmake.org/cmake/help/latest/command/return.html#command: return "(in CMake v3.29.2)") command returns from a function, directory or file. Note that a macro, unlike a function, is expanded in place and therefore cannot handle [`return`](https://cmake.org/cmake/help/latest/command/return.html#command: return "(in CMake v3.29.2)"). ( `return` 命令用于从函数、目录或文件中返回，注意宏不是函数，而是会直接展开，因此不适宜使用 `return` )

## 2.7 Regular Expressions
A few CMake commands, such as [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)") and [`string`](https://cmake.org/cmake/help/latest/command/string.html#command: string "(in CMake v3.29.2)"), make use of regular expressions or can take a regular expression as an argument. In its simplest form, a regular expression is a sequence of characters used to search for exact character matches. However, many times the exact sequence to be found is unknown, or only a match at the beginning or end of a string is desired. Since there are several different conventions for specifying regular expressions, CMake’s standard is described in the [`string`](https://cmake.org/cmake/help/latest/command/string.html#command: string "(in CMake v3.29.2)") command documentation. The description is based on the open source regular expression class from Texas Instruments, which is used by CMake for parsing regular expressions. ( CMake 的一些命令支持正则表达式作为形参 )
## 2.8 Advanced Commands
There are a few commands that can be very useful, but are not typically used in writing CMakeLists files. This section will discuss a few of these commands and when they are useful. ( 本节介绍一些高级命令，不一定常用 )

First, consider the [`add_dependencies`](https://cmake.org/cmake/help/latest/command/add_dependencies.html#command: add_dependencies "(in CMake v3.29.2)") command which creates a dependency between two targets. CMake automatically creates dependencies between targets when it can determine them. For example, CMake will automatically create a dependency for an executable target that depends on a library target. The [`add_dependencies`](https://cmake.org/cmake/help/latest/command/add_dependencies.html#command: add_dependencies "(in CMake v3.29.2)") command is typically used to specify inter-target dependencies between targets where at least one of the targets is a custom target (see [Add Custom Command](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Custom%20Commands.html#add-custom-command) section).
( `add_denpendencies` 命令为两个目标之间创建依赖，一般 CMake 会在自己可以决定的情况下自动为目标创建依赖，例如自动为可执行目标和它依赖的库目标之间创建依赖 )

The [`include_regular_expression`](https://cmake.org/cmake/help/latest/command/include_regular_expression.html#command: include_regular_expression "(in CMake v3.29.2)") command also relates to dependencies. This command controls the regular expression that is used for tracing source code dependencies. By default, CMake will trace all the dependencies for a source file including system files such as `stdio.h`. If you specify a regular expression with the [`include_regular_expression`](https://cmake.org/cmake/help/latest/command/include_regular_expression.html#command: include_regular_expression "(in CMake v3.29.2)") command, that regular expression will be used to limit which include files are processed. For example; if your software project’s include files all started with the prefix foo (e.g. `fooMain.c fooStruct.h`, etc), you could specify a regular expression of `^foo.*$` to limit the dependency checking to just the files of your project. 
( `include_regular_expression` 的作用是控制用于追踪源代码依赖的正则表达式，默认下，CMake 为源文件追踪所有依赖，包括系统文件，而该命令可以用于限制需要处理的 include 文件的范围，同时也就限制了依赖检查的范围 )
# 3 CMake Cache
The CMake cache may be thought of as a configuration file. The first time CMake is run on a project, it produces a `CMakeCache.txt` file in the top directory of the build tree. CMake uses this file to store a set of global cache variables, whose values persist across multiple runs within a project build tree. ( CMake cache 可以被视为一个配置文件，CMake 第一次运行于一个项目时，会在构建树的顶层生成 `CMakeCache.txt` 文件，用于存储一系列全局 cache 变量，它们的值在项目构建树内的多次运行中保持 )

There are a few purposes of this cache. The first is to store the user’s selections and choices, so that if they should run CMake again they will not need to reenter that information. For example, the [`option`](https://cmake.org/cmake/help/latest/command/option.html#command: option "(in CMake v3.29.2)") command creates a Boolean variable and stores it in the cache. ( 该 cache 用于存储用户的一些选择信息 )
```
option(USE_JPEG "Do you want to use the jpeg library")
```

The above line would create a variable called `USE_JPEG` and put it into the cache. That way the user can set that variable from the user interface and its value will remain in case the user should run CMake again in the future. To create a variable in the cache, use commands like [`option`](https://cmake.org/cmake/help/latest/command/option.html#command: option "(in CMake v3.29.2)"), [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.29.2)"), or the standard [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command with the `CACHE` option. 
```
set(USE_JPEG ON CACHE BOOL "include jpeg support?")
```
( `option` , `find_file` 命令可以创建 cache 变量，`set` 命令加 `CACHE` 选项也可以创建 cache 变量 )

When you use the `CACHE` option, you may also provide the type of the variable and a documentation string. The type of the variable is used by the [`cmake-gui`](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual: cmake-gui(1) "(in CMake v3.29.2)") to control how that variable is set and displayed, but the value is always stored in the cache file as a string. ( 使用 `CACHE` 选项的同时可以提供变量类型和文档，但 CMake 总是将变量值存储为字符串 )

Another purpose of the cache is to allow CMake itself to persistently store values between CMake runs. These entries may not be visible or adjustable by the user. Typically, these values are system-dependent variables that require CMake to compile and run a program to determine their value. Once these values have been determined, they are stored in the cache to avoid having to recompute them every time CMake is run. CMake generally tries to limit these variables to properties that should never change (such as the byte order of the machine you are on). If you significantly change your computer, either by changing the operating system or switching to a different compiler, you will need to delete the cache file (and probably all of your binary tree’s object files, libraries, and executables). ( CMake 自己也会利用 cache 存储需要在 CMake 运行之间保持的一些值，即一些依赖值于系统的变量，这些变量第一次运行时需要 CMake 编译并运行程序才知道它们的值，如果我们改变了系统，我们可能需要删除 cache 文件，甚至整个二进制树，重新编译 )

Some projects are very complex and setting one value in the cache may cause new options to appear the next time the cache is built.  ( 对于一些复杂的系统，在 cache 中设定一个值可能会让下一次 cache 构建时出现新的 option )
For example, VTK supports the use of MPI for performing distributed computing. This requires the build process to determine where the MPI libraries and header files are and to let the user adjust their values. But MPI is only available if another option `VTK_USE_PARALLEL` is first turned on in VTK. So, to avoid confusion for people who don’t know what MPI is, those options are hidden until `VTK_USE_PARALLEL` is turned on. So CMake shows the `VTK_USE_PARALLEL` option in the cache area, if the user turns that on and re-configures with CMake, new options will appear for MPI that they can then set. The rule is to keep building the cache until it doesn’t change. For most projects this will be just once. For some complicated ones it may be twice or more.
( CMake 的规则是保持构建 cache 直到它不变，一般对于多数项目，只需要构建一次 )

You might be tempted to edit the cache file directly, or to “initialize” a project by giving it a pre-populated `CMakeCache.txt` file. This may not work and could cause additional problems in the future. First, the syntax of the CMake cache is subject to change. Second, cache files contain full paths which make them unsuitable for moving between binary trees. ( 最好不要直接修改 cache 文件 `CMakeCache.txt` )

Once a variable is in the cache, its “cache” value cannot normally be modified from a CMakeLists file. The reasoning behind this is that once CMake has put the variable into the cache with its initial value, the user may then modify that value from the GUI. If the next invocation of CMake overwrote their change back to the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") value, the user would never be able to make a change that CMake wouldn’t overwrite. A `set(FOO ON CACHE BOOL "doc")` command will typically only do something when the cache doesn’t have the variable in it. Once the variable is in the cache, that command will have no effect. ( 已经写入 cache 内的 cached 的变量值不易从 CMakeLists 中改变，即  `set(<var-name. ON CACHE <var-val>)` 命令只会在 cache 中没有 `<var-name>` 的情况下做一些事情，如果 cache 中已经有了该变量，则该命令无效 )

In the rare event that you really want to change a cached variable’s value, use the `FORCE` option in combination with the `CACHE` option to the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command. The `FORCE` option will cause the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command to override and change the cache value of a variable. ( `FORCE` 选项可以强制覆盖写 cached 的变量值 )

A few final points should be made concerning variables and their interaction with the cache. If a variable is in the cache, it can still be overridden in a CMakeLists file using the [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command without the `CACHE` option. Cache values are checked when a referenced variable is not defined in the current scope. The [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") command will define a variable for the current scope without changing the value in the cache. ( cached 的变量的值在 CMakeLists 内可以用 `set` 命令覆盖写，cache 值会在被引用变量在当前作用域内未定义时被检查，`set` 命令会在当前作用域内覆盖该变量的值，但是 cache 内存储的值不变 )
```
# assume that FOO is set to ON in the cache

set(FOO OFF)
# sets foo to OFF for processing this CMakeLists file
# and subdirectories; the value in the cache stays ON
```

Variables that are in the cache also have a property indicating if they are advanced or not. By default, when [`ccmake`](https://cmake.org/cmake/help/latest/manual/ccmake.1.html#manual:ccmake(1) "(in CMake v3.29.2)") or the [`cmake-gui`](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual: cmake-gui(1) "(in CMake v3.29.2)") are run, the advanced cache entries are not displayed. This is so the user can focus on the cache entries that they should consider changing. The advanced cache entries are other options that the user can modify, but typically will not. It is not unusual for a large software project to have fifty or more options, and the advanced property lets a software project divide them into key options for most users and advanced options for advanced users. Depending on the project, there may not be any non-advanced cache entries. To make a cache entry advanced, the [`mark_as_advanced`](https://cmake.org/cmake/help/latest/command/mark_as_advanced.html#command: mark_as_advanced "(in CMake v3.29.2)") command is used with the name of the variable (a.k.a. cache entry). ( cache 内的一些变量是高级变量，一般用户不需要修改 )

In some cases, you might want to restrict a cache entry to a limited set of predefined options. You can do this by setting the [`STRINGS`](https://cmake.org/cmake/help/latest/prop_cache/STRINGS.html#prop_cache: STRINGS "(in CMake v3.29.2)") property on the cache entry. The following CMakeLists code illustrates this by creating a property named `CRYPTOBACKEND` as usual, and then setting the `STRINGS` property on it to a set of three options. ( 我们可以用 `STRINGS` 属性将 cache entry 限制在预定义的选项集合里 )
```cmake
set(CRYPTOBACKEND "OpenSSL" CACHE STRING
    "Select a cryptography backend")
set_property(CACHE CRYPTOBACKEND PROPERTY STRINGS
             "OpenSSL" "LibTomCrypt" "LibDES")
```
When [`cmake-gui`](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual: cmake-gui(1) "(in CMake v3.29.2)") is run and the user selects the `CRYPTOBACKEND` cache entry, they will be presented with a pulldown to select which option they want.
## 3.1 Setting Initial Values for CMake
Sometimes you may need to set up cache entries without running a GUI. This is common when setting up nightly dashboards, or if you will be creating many build trees with the same cache values. In these cases, the CMake cache can be initialized in two different ways. The first way is to pass the cache values on the CMake command line using `-DCACHE_VAR:TYPE=VALUE` arguments. For example, consider the following nightly dashboard script for a UNIX machine: ( 有两种方式初始化 CMake cache，一种是在命令行使用 `-DCACHE_VAR:TYPE=VALUE` 传递 cache 值 )
```
#!/bin/tcsh

cd ${HOME}

# wipe out the old binary tree and then create it again
rm -rf Foo-Linux
mkdir Foo-Linux
cd Foo-Linux

# run cmake to setup the cache
cmake -DBUILD_TESTING:BOOL=ON <etc...> ../Foo

# generate the dashboard
ctest -D Nightly
```

The same idea can be used with a batch file on Windows.

The second way is to create a file to be loaded using [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)")’s `-C` option. In this case, instead of setting up the cache with `-D` options, it is done through a file that is parsed by CMake. The syntax for this file is the standard CMakeLists syntax, which is typically a series of [`set`](https://cmake.org/cmake/help/latest/command/set.html#command: set "(in CMake v3.29.2)") commands such as: ( 另一种方法创建文件，并用 `-C` 选项装载，文件语法和标准 CMakeLists 语法一致，一般是一系列 `set` 命令 )
```
# Build the vtkHybrid kit.
set(VTK_USE_HYBRID ON CACHE BOOL "doc string")
```

In some cases there might be an existing cache, and you want to force the cache values to be set a certain way. For example, say you want to turn Hybrid on even if the user has previously run CMake and turned it off. Then you can do
```
# Build the vtkHybrid kit always.
set(VTK_USE_HYBRID ON CACHE BOOL "doc" FORCE)
```

Another option is that you want to set and then hide options so the user will not be tempted to adjust them later on. This can be done using type `INTERNAL`. `INTERNAL` cache variables imply `FORCE` and are never shown in cache editors. ( 由 `INTERNAL` 设定的 cache 变量有 `FORCE` 的作用，且不会出现在 cache 编辑器上供用户编辑 )
```
# Build the vtkHybrid kit always and don't distract
# the user by showing the option.
set(VTK_USE_HYBRID ON CACHE INTERNAL "doc")
```
# 4  Key Concepts
 Many CMake objects such as targets, directories and source files have properties associated with them. A property is a key-value pair attached to a specific object. ( 属性即依附于某个目标的键值对 )
 
 The most generic way to access properties is through the [`set_property`](https://cmake.org/cmake/help/latest/command/set_property.html#command: set_property "(in CMake v3.29.2)") and [`get_property`](https://cmake.org/cmake/help/latest/command/get_property.html#command: get_property "(in CMake v3.29.2)") commands. These commands allow you to set or get a property from any object in CMake that has properties. See the [`cmake-properties`](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#manual: cmake-properties(7) "(in CMake v3.29.2)") manual for a list of supported properties. From the command line a full list of properties supported in CMake can be obtained by running [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.29.2)") with the `--help-property-list` option. ( `set_property` 和 `get_property` 命令用于管理属性 )
## 4.1 Targets
Probably the most important item is targets. Targets represent executables, libraries, and utilities built by CMake. Every [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)"), [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)"), and [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.29.2)") command creates a target. ( 目标即可执行文件、库，`add_library` , `add_executable` , `add_custom_target` 命令用于创建目标 )

For example, the following command will create a target named “foo” that is a static library, with `foo1.c` and `foo2.c` as source files.
```
add_library(foo STATIC foo1.c foo2.c)
```
( `add_library(foo STATIC foo1.c foo2.c)` 用于创建静态库 `foo`  )

The name “foo” is now available for use as a library name everywhere else in the project, and CMake will know how to expand the name into the library when needed.  ( 使用 `add_library` 命令之后，名称 `foo` 在项目中就代表了一个静态库，CMake 将会在需要的时候将这个名字展开为静态库 )

Libraries can be declared as a particular type such as `STATIC`, `SHARED`, `MODULE`, or left undeclared. `STATIC` indicates that the library must be built as a static library. Likewise, `SHARED` indicates it must be built as a shared library. `MODULE` indicates that the library must be created so that it can be dynamically-loaded into an executable. ( CMake 支持 `STATIC, SHARED, MODLUE` 类型的库，`STATIC` 为静态库，`SHARED` 为共享库，`MODULE` 表示库需要被动态装载入可执行文件 )

Module libraries are implemented as shared libraries on many platforms, but not all. Therefore, CMake does not allow other targets to link to modules. ( 模块库在许多平台都被实现为共享库，但不是所有，为了兼容性，CMake 不允许其他目标和模块链接 )

If none of these options are specified, it indicates that the library could be built as either shared or static. In that case, CMake uses the setting of the variable [`BUILD_SHARED_LIBS`](https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html#variable: BUILD_SHARED_LIBS "(in CMake v3.29.2)") to determine if the library should be `SHARED` or `STATIC`. If it is not set, then CMake defaults to building static libraries. ( 若没有指定选项，表明可以是静态或共享库，CMake 根据 `BUID_SHARED_LIBS` 变量确定，若变量未设定，则构建静态库 )

Likewise, executables have some options. By default, an executable will be a traditional console application that has a main entry point. One may specify a `WIN32` option to request a WinMain entry point on Windows systems, while retaining main on non-Windows systems. ( 类似地，可执行文件目标也有选项可指定，默认为控制台应用，`WIN32` 选项用于在 Windows 系统上请求一个 WinMain 入口点，在其他系统上保持为 main 入口点 )

In addition to storing their type, targets also keep track of general properties. These properties can be set and retrieved using the [`set_target_properties`](https://cmake.org/cmake/help/latest/command/set_target_properties.html#command: set_target_properties "(in CMake v3.29.2)") and [`get_target_property`](https://cmake.org/cmake/help/latest/command/get_target_property.html#command: get_target_property "(in CMake v3.29.2)") commands, or the more general [`set_property`](https://cmake.org/cmake/help/latest/command/set_property.html#command: set_property "(in CMake v3.29.2)") and [`get_property`](https://cmake.org/cmake/help/latest/command/get_property.html#command: get_property "(in CMake v3.29.2)") commands. ( 选项指定了目标的类型，`set_target_properties` , `get_target_property` 用于管理目标的特性 )

One useful property is [`LINK_FLAGS`](https://cmake.org/cmake/help/latest/prop_tgt/LINK_FLAGS.html#prop_tgt: LINK_FLAGS "(in CMake v3.29.2)"), which is used to specify additional link flags for a specific target. ( `LINK_FLAGS` 特性用于为目标指定额外的链接标志 )
Targets store a list of libraries that they link against, which are set using the [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command: target_link_libraries "(in CMake v3.29.2)") command. Names passed into this command can be libraries, full paths to libraries, or the name of a library from an [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") command. Targets also store the link directories to use when linking, and custom commands to execute after building.  ( 目标会存储其链接的库为一个列表，可以用 `target_link_libraries` 设定，该命令接受库、库路径、`add_library` 添加的库名，目标同时存储链接目录以及自定义命令 )
## 4.2 Usage Requirements
CMake will also propagate “usage requirements” from linked library targets. Usage requirements affect compilation of sources in the `<target>`. They are specified by properties defined on linked targets. 
> CMake 会传递被链接库目标的“使用要求“，这些“要求”由被链接库目标的特性指定

For example, to specify include directories that are required when linking to a library you would can do the following: 
> 指定链接到 `foo`  库所需的 include 目录
```cmake
add_library(foo foo.cxx)
target_include_directories(foo PUBLIC
                           "${CMAKE_CURRENT_BINARY_DIR}"
                           "${CMAKE_CURRENT_SOURCE_DIR}"
                           )
```
Now anything that links to the target `foo` will automatically have foo’s binary and source as include directories.  
>现在任意链接了 `foo` 库的目标的 include 目录中会包含 `foo` 库的源目录和二进制目录

The order of the include directories brought in through “usage requirements” will match the order of the targets in the [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command: target_link_libraries "(in CMake v3.29.2)") call. 
> 各个链接库带来的 include 目录的顺序优先级遵循它们在 `target_link_libraries` 中的顺序

For each library or executable CMake creates, it tracks of all the libraries on which that target depends using the [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command: target_link_libraries "(in CMake v3.29.2)") command. For example: 
> CMake 对于库和可执行目标会追踪它们在 `target_link_libraries` 命令中指定的依赖、依赖的依赖、依赖的依赖的依赖等等作为目标所需的库
```
add_library(foo foo.cxx)
target_link_libraries(foo bar)

add_executable(foobar foobar.cxx)
target_link_libraries(foobar foo)
```
will link the libraries “foo” and “bar” into the executable “foobar” even though only “foo” was explicitly specified for it. 
>  `foobar` 依赖于 `foo` ， `foo` 依赖于 `bar` ，因此 `foobar` 依赖于 `foo` , `bar` ，会对二者都进行链接
## 4.3 Specifying Optimized or Debug Libraries with a Target
On Windows platforms, users are often required to link debug libraries with debug libraries, and optimized libraries with optimized libraries. CMake helps satisfy this requirement with the [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command: target_link_libraries "(in CMake v3.29.2)") command, which accepts an optional flag labeled as `debug` or `optimized`. If a library is preceded with either `debug` or `optimized`, then that library will only be linked in with the appropriate configuration type. For example ( CMake `target_link_libraries` 支持可选标志 `debug` , `optimized` ，对应的库会在合适的配置类型，例如 debug 构建、optimized 构建下被链接 )
```cmake
add_executable(foo foo.c)
target_link_libraries(foo debug libdebug optimized libopt)
```
In this case, foo will be linked against libdebug if a debug build was selected, or against libopt if an optimized build was selected.
## 4.4 Object Libraries
Large projects often organize their source files into groups, perhaps in separate subdirectories, that each need different include directories and preprocessor definitions. For this use case CMake has developed the concept of Object Libraries. ( 大型项目中源文件会分组于各个子目录中，每个子目录有不同的 include 目录和预处理器定义，CMake 的相关概念是目标库 )

An Object Library is a collection of source files compiled into an object file which is not linked into a library file or made into an archive. ( 目标库即源文件集合编译为一个目标文件，这个目标文件不会被链接到一个库文件，即动态库文件，也不会被作为 archive，即静态库文件 )

Instead other targets created by [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") or [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)") may reference the objects using an expression of the form `$<TARGET_OBJECTS:name>` as a source, where “name” is the target created by the [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") call. ( 而其他由 `add_library` 或 `add_executable` 创建的目标可以使用形式为 `$<TARGET_OBJECTS:name>` 的表达式作为源，其中 `name` 是由 `add_library` 调用创建的目标 )
For example:
```cmake
add_library(A OBJECT a.cpp)
add_library(B OBJECT b.cpp)
add_library(Combined $<TARGET_OBJECTS:A> $<TARGET_OBJECTS:B>)
```
will include A and B object files in a library called Combined. Object libraries may contain only sources (and headers) that compile to object files. ( 上例将 A 和 B 目标文件包含在了一个称为 Combined 的库中 )
## 4.5 Source Files
The source file structure is in many ways similar to a target. It stores the filename, extension, and a number of general properties related to a source file. Like targets, you can set and get properties using [`set_source_files_properties`](https://cmake.org/cmake/help/latest/command/set_source_files_properties.html#command: set_source_files_properties "(in CMake v3.29.2)") and [`get_source_file_property`](https://cmake.org/cmake/help/latest/command/get_source_file_property.html#command: get_source_file_property "(in CMake v3.29.2)"), or the more generic versions. ( CMake 中的源文件结构体和目标文件是类似的，它存储了文件名、拓展名，以及一系列和源文件相关的通用特性，我们使用 `set_source_files_properties` 和 `get_source_file_property` 来管理源文件的特性 )
## 4.6 Directories, Tests, and Properties
In addition to targets and source files, you may find yourself occasionally working with other objects such as directories and tests. Normally such interactions take the shape of setting or getting properties (e.g. [`set_directory_properties`](https://cmake.org/cmake/help/latest/command/set_directory_properties.html#command: set_directory_properties "(in CMake v3.29.2)") or [`set_tests_properties`](https://cmake.org/cmake/help/latest/command/set_tests_properties.html#command: set_tests_properties "(in CMake v3.29.2)")) from these objects. ( CMake 中还有目录和测试作为对象，我们同样使用 `set_xxx_properties` 来管理它们的属性 )
# 5 Policies
Occasionally a new feature or change is made to CMake that is not fully backwards compatible with older versions. This can create problems when someone tries to use an old CMakeLists file with a new version of CMake. ( 有时 CMake 的新版本无法兼容旧的 CMakeLists 文件 )
To help both end users and developers through such issues, we have introduced [`cmake-policies`](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html#manual: cmake-policies(7) "(in CMake v3.29.2)"). Policies are a mechanism for helping improve backwards compatibility and tracking compatibility issues between different versions of CMake. ( CMake policy 是用于提高向后兼容能力的机制)
## 5.1 Design Goals
There were four main design goals for the CMake policy mechanism:
( CMake policy 机制有4个设计目标 )
1. Existing projects should build with newer versions of CMake than that used by the project authors.
    - Users should not need to edit code to get the projects to build.
    - Warnings may be issued but the projects should build.
    (对于现存的，用新 CMake 构建的项目，用户应该不需要重新编辑源码使得项目可以构建，CMake 会发送警告，但项目依然可以构建 )
2. Correctness of new interfaces or bug fixes in old interfaces should not be inhibited by compatibility requirements. Any reduction in correctness of the latest interface is not fair on new projects. ( 对新接口的修改以及 bug 修复应该不受兼容性考虑的影响，即能修复就修复 )
3. Every change made to CMake that may require changes to a project’s CMakeLists files should be documented.
    - Each change should also have a unique identifier that can be referenced with warning and error messages.
    - The new behavior is enabled only when the project has somehow indicated it is supported. 
    ( 能够导致需要修改项目的 CMakeLists 文件的 CMake 修改会有文档说明 )
4. We must be able to eventually remove code that implements compatibility with ancient CMake versions.
    - Such removal is necessary to keep the code clean and to allow for internal refactoring.
    - After such removal, attempts at building projects written for ancient versions must fail with an informative message.
    ( 需要能够最终移除为了与旧 CMake 兼容而实现的代码 )
All policies in CMake are assigned a name in the form CMPNNNN where NNNN is an integer value. Policies typically support both an old behavior that preserves compatibility with earlier versions of CMake, and a new behavior that is considered correct and preferred for use by new projects. Every policy has documentation detailing the motivation for the change, and the old and new behaviors. 
## 5.2 Setting Policies
Projects may configure the setting of each policy to request old or new behaviors. When CMake encounters user code that may be affected by a particular policy, it checks to see whether the project has set the policy. If the policy has been set (to `OLD` or `NEW`) then CMake follows the behavior specified. If the policy has not been set then the old behavior is used, but a warning is issued telling the project author to set the policy. ( 项目可以配置每个 policy 的设定来决定需要旧的或新的行为，若 policy 没有被设定，则 CMake 默认使用旧的行为 )

There are a couple ways to set the behavior of a policy. The quickest way is to set all policies to a version that corresponds to the release version of CMake the project was written in. ( 设定 policy 行为最快的方法就是将所有的 policy 设定为 CMake 的一个发布版本 )
Setting the policy version requests the new behavior for all policies introduced in the corresponding version of CMake or earlier. Policies introduced in later versions are marked as “not set” in order to produce proper warning messages. ( 设定 policy 版本后，所有在这个版本之后发布的 policy 都会被标记为“未设定” ) The policy version is set using the [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html#command: cmake_policy "(in CMake v3.29.2)") command’s `VERSION` signature. For example, the code
```cmake
cmake_policy(VERSION 3.20)
```
will request the new behavior for all policies introduced in CMake 3.20 or earlier. ( 例如，`cmake_policy(VERSION 3.20)` 就设定 policy 的行为都为 CMake3.20版本的新行为 )

The [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html#command: cmake_minimum_required "(in CMake v3.29.2)") command will require a minimum version of CMake and will call [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html#command: cmake_policy "(in CMake v3.29.2)"). A project should always begin with the lines ( `cmake_minimum_required` 命令用于设定要求的 CMake 最小版本，并且它会调用 `cmake_policy` )
```cmake
cmake_minimum_required(VERSION 3.20)
project(MyProject)
# ...code using CMake 3.20 policies
```
This indicates that the person running CMake must have at least version 3.20. If they are running an older version of CMake, an error message will be displayed telling them that the project requires at least the specified version of CMake.

Of course, one should replace “3.20” with the version of CMake you are currently writing to. You can also set each policy individually if you wish; this is sometimes helpful for project authors who want to incrementally convert their projects to use a new behavior, or silence warnings about dependence on an old behavior. The [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html#command: cmake_policy "(in CMake v3.29.2)") command’s `SET` option may be used to explicitly request old or new behavior for a particular policy. ( `cmake_policy` 命令的 `SET` 选项可以用于显式请求某个特定 policy 的行为是新还是旧 )

For example, CMake 2.6 introduced the policy [`CMP0002`](https://cmake.org/cmake/help/latest/policy/CMP0002.html#policy:CMP0002 "(in CMake v3.29.2)"), which requires all logical target names to be globally unique (duplicate target names previously worked by accident in some cases, but were not diagnosed). Projects using duplicate target names and working accidentally will receive warnings referencing the policy. The warnings may be silenced with the code
```cmake
cmake_policy(SET CMP0002 OLD)
```
which explicitly tells CMake to use the old behavior for the policy (silently accepting duplicate target names). Another option is to use the code
```cmake
cmake_policy(SET CMP0002 NEW)
```
to explicitly tell CMake to use new behavior and produce an error when a duplicate target is created. Once this is added to the project, it will not build until the author removes any duplicate target names.

When a new version of CMake is released, it introduces new policies that can still build old projects, because by default they do not request `NEW` behavior for any of the new policies. When starting a new project, one should always specify the most recent release of CMake to be supported with the [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html#command:cmake_minimum_required "(in CMake v3.29.2)") command. This will ensure that the project is written to work using policies from that version of CMake and not using any old behavior. If no policy version is set, CMake will warn and assume a policy version of 2.4. This allows existing projects that do not specify [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html#command:cmake_minimum_required "(in CMake v3.29.2)") to build as they would have with CMake 2.4.
## 5.3 The Policy Stack
Policy settings are scoped using a stack. A new level of the stack is pushed when entering a new subdirectory of the project (with [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command: add_subdirectory "(in CMake v3.29.2)")) and popped when leaving it. Therefore, setting a policy in one directory of a project will not affect parent or sibling directories, but it will affect subdirectories.
( policy 设定使用栈来控制作用域，进入新的子目录时，CMake 就会推入一个新栈，离开时弹栈，因此在项目的一个目录中设定 policy 仅会影响子目录 )

This is useful when a project contains subprojects that are maintained separately yet built inside the tree. The top-level CMakeLists file in a project may write
```
cmake_policy(VERSION 2.6)
project(MyProject)
add_subdirectory(OtherProject)
# ... code requiring new behavior as of CMake 2.6 ...
```

while the `OtherProject/CMakeLists.txt` file contains
```
cmake_policy(VERSION 2.4)
projectS(OtherProject)
# ... code that builds with CMake 2.4 ...
```
This allows a project to be updated to CMake 2.6 while subprojects, modules, and included files continue to build with CMake 2.4 until their maintainers update them. ( 可以对不同的子目录设定不同的 policy 版本 )

User code may use the [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html#command: cmake_policy "(in CMake v3.29.2)") command to push and pop its own stack levels as long as every push is paired with a pop. This is useful when temporarily requesting different behavior for a small section of code. ( 用户还可以使用 `cmake_policy` 命令来自己推和弹 policy 栈 )

For example, policy [`CMP0003`](https://cmake.org/cmake/help/latest/policy/CMP0003.html#policy: CMP0003 "(in CMake v3.29.2)") removes extra link directories that used to be included when new behavior is used. When incrementally updating a project, it may be difficult to build a particular target with the remaining targets being OK. The code
```
cmake_policy(PUSH)
cmake_policy(SET CMP0003 OLD) # use old-style link for now
add_executable(myexe ...)
cmake_policy(POP)
```
will silence the warning and use the old behavior for that target. You can get a list of policies and help on specific policies by running CMake from the command line as follows
```
cmake --help-command cmake_policy
cmake --help-policies
cmake --help-policy CMP0003
```
## 5.4 Updating a Project For a New Version of CMake
When a CMake release introduces new policies, it may generate warnings for some existing projects. These warnings indicate that changes to a project may be necessary for dealing with the new policies. While old releases of a project can continue to build with the warnings, the project development tree should be updated to take the new policies into account. There are two approaches to updating a tree: one-shot and incremental. The question of which one is easier depends on the size of the project and which new policies produce warnings. ( CMake 发布新的 policy 时，可能需要考虑更新项目开发树，更新项目开发树有两种方法：一次完成和增量式 )
### 5.4.1 The One-Shot Approach
The simplest approach to updating a project for a new version of CMake is simply to change the policy version which is set at the top of the project. Then, try building with the new CMake version to fix problems. For example, to update a project to build with CMake 3.20, one might write
```cmake
cmake_minimum_required(VERSION 3.20)
```
at the beginning of the top-level CMakeLists file. This tells CMake to use the new behavior for every policy introduced in CMake 3.20 and below. When building this project with CMake 3.20, no warnings will be produced regarding policies because it knows that no policies were introduced in later versions. However, if the project was depending on the old policy behavior, it may not build since CMake is now using the new behavior without warning. It is up to the project author who added the policy version line to fix these issues.
> 最简单的方法就是修改 `cmake_minimum_require()` 中的参数，但如果项目依赖于旧 policy 的行为，项目就无法构建
### 5.4.2 The Incremental Approach
Another approach to updating a project for a new version of CMake is to deal with each warning one-by-one. One advantage of this approach is that the project will continue to build throughout the process, so the changes can be made incrementally.
> 为了在新的 policy 下构建项目，需要一个一个处理 warning

When CMake encounters a situation where it needs to know whether to use the old or new behavior for a policy, it checks whether the project has set the policy. If the policy is set, CMake silently uses the corresponding behavior. If the policy is not set, CMake uses the old behavior but warns the author that the policy is not set.
> CMake 遇到需要使用 policy 的情况时，它会检查项目是否设定了该 policy，若设定了，则使用新的行为，否则使用旧的行为，并发出警告

In many cases, a warning message will point to the exact line of code in the CMakeLists files that caused the warning. In some cases, the situation cannot be diagnosed until CMake is generating the native build system rules for the project, so the warning will not include explicit context information. In these cases, CMake will try to provide some information about where code may need to be changed. The documentation for these “generation-time” policies should indicate the point in the project code where the policy should be set to take effect.

In order to incrementally update a project, one warning should be addressed at a time. Several cases may occur, as described below.
### 5.4.3 Silence a Warning When the Code is Correct
Many policy warnings may be produced simply because the project has not set the policy even though the project may work correctly with the new behavior (there is no way for CMake to know the difference). For a warning about some policy, `CMP<NNNN>`, you can check whether this is the case by adding
> CMake 在用户没有设定 policy 时会就会发出警告，有时只需要把 policy 设定以下就可以解决警告了，只要代码可以在新 policy 下构建，就不涉及代码

```
cmake_policy(SET CMP<NNNN> NEW)
```
to the top of the project and trying to build it. If the project builds correctly with the new behavior, move on to the next policy warning. If the project does not build correctly, one of the other cases may apply.
### 5.4.4 Silence a Warning Without Updating the Code
Users can suppress all instances of a warning `CMP<NNNN>` by adding
```
cmake_policy(SET CMP<NNNN> OLD)
```
to the top of a project. However, we encourage project authors to update their code to work with the new behavior for all policies. This is especially important because versions of CMake in the (distant) future may remove support for old behaviors and produce an error for projects requesting them (which tells the user to get an older versions of CMake to build the project).
> 将 policy 设定为旧版可以暂时在不修改代码的情况下成功构建项目
### 5.4.5 Silence a Warning by Updating Code
When a project does not work correctly with the NEW behaviors for a policy, the code needs to be updated. In order to deal with a warning for some policy `CMP<NNNN>`,add
```
cmake_policy(SET CMP<NNNN> NEW)
```
to the top of the project and then fix the code to work with the NEW behavior.
> 代码不能在新的 policy 下构建，就需要修改代码

If many instances of the warning occur fixing all of them simultaneously may be too difficult: instead, a developer may fix them one at a time by using the PUSH/POP signatures of the [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html#command:cmake_policy "(in CMake v3.29.2)") command:
```
cmake_policy(PUSH)
cmake_policy(SET CMP<NNNN> NEW)
# ... code updated for new policy behavior ...
cmake_policy(POP)
```
> 可以使用 `cmake_policy` 的 PUSH 和 POP 特性，一次解决一个由新 policy 带来的 warning

This will request the new behavior for a small region of code that has been fixed. Other instances of the policy warning may still appear and must be fixed separately.
### 5.4.6 Updating the Project Policy Version
After addressing all policy warnings and getting the project to build cleanly with the new CMake version one step remains. The policy version set at the top of the project should now be updated to match the new CMake version, just as in the one-shot approach described above. For example, after updating a project to build cleanly with CMake 3.20, users may update the top of the project with the line
```
cmake_minimum_required(VERSION 3.20)
```
> 解决了全部由新的 policy 带来的 warning 之后，就可以直接修改 `cmake_minimum_require()` 中的参数为最新版

This will set all policies introduced in CMake 3.20 or below to use the new behavior. Then users may sweep through the rest of the code and remove the calls that use the [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html#command: cmake_policy "(in CMake v3.29.2)") command to request the new behavior incrementally. The end result should look the same as the one-shot approach, but could be attained step-by-step.
> 之后就可以移除其他的 `cmake_policy` 调用了
### 5.4.7 Supporting Multiple CMake Versions
Some projects might want to support a few releases of CMake simultaneously. The goal is to build with an older version, while also working with newer versions without warnings. In order to support both CMake 2.4 and 2.6, one may write code like
```
cmake_minimum_required(VERSION 2.4)
if(COMMAND cmake_policy)
  # policy settings ...
  cmake_policy(SET CMP0003 NEW)
endif()
```

This will set the policies to build with CMake 2.6 and to ignore them for CMake 2.4. In order to support both CMake 2.6 and some policies of CMake 2.8, one may write code like:
```
cmake_minimum_required(VERSION 2.6)
if(POLICY CMP1234)
  # policies not known to CMake 2.6 ...
  cmake_policy(SET CMP1234 NEW)
endif()
```
This will set the policies to build with CMake 2.8 and to ignore them for CMake 2.6. If it is known that the project builds with both CMake 2.6 and CMake 2.8’s new policies users may write:
```
cmake_minimum_required(VERSION 2.6)
if (NOT ${CMAKE_VERSION} VERSION_LESS 2.8)
   cmake_policy(VERSION 2.8)
endif()
```
> 结合使用 `cmake_minumum_required` 和 `cmake_policy` 可以在利用不同版本的 policies 构建项目
#### 5.4.7.1 Checking Versions of CMake
CMake is an evolving program and as new versions are released, new features or commands are introduced. As a result, there may be instances where you might want to use a command that is in a current version of CMake but not in previous versions. There are a couple of ways to handle this; one option is to use the [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)") command to check whether a new command exists. For example:
```
# test if the command exists
if(COMMAND some_new_command)
  # use the command
  some_new_command( ARGS...)
endif()
```
> CMake 支持使用 `if` 检查需要使用的命令是否在当前版本存在，方便构建兼容旧版本和新版本的 CMakeLists

Alternatively, one may test against the actual version of CMake that is being run by evaluating the [`CMAKE_VERSION`](https://cmake.org/cmake/help/latest/variable/CMAKE_VERSION.html#variable:CMAKE_VERSION "(in CMake v3.29.2)") variable:
```
# look for newer versions of CMake
if(${CMAKE_VERSION} VERSION_GREATER 3.20)
  # do something special here
endif()
```
> 也可以使用 `if` 检查实际运行的 CMake 版本，为此做出相应的在新版本可行的行为

Finally, some new releases of CMake might no longer support some behavior you were using (although we try to avoid this). In these cases, use CMake policies, as discussed in the [`cmake-policies`](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html#manual: cmake-policies(7) "(in CMake v3.29.2)") manual.
> CMake 新的发布不支持我们使用的一些行为时，就使用 `cmake_policy` 来解决
# 6 Modules
## 6.1 Using Modules
Code reuse is a valuable technique in software development and CMake has been designed to support it. Allowing CMakeLists files to make use of reusable modules enables the entire community to share reusable sections of code. For CMake, these sections are called [`cmake-modules`](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual: cmake-modules(7) "(in CMake v3.29.2)") and can be found in the Modules subdirectory of your installation.
> CMakeLists 可以利用可复用的模块，社区内可以共享可复用的代码段，CMake 称它们为 `cmake-modules` ，模块位于 Modules 子目录中

A module’s location can be specified using the full path to the module file, or by letting CMake find the module by itself. CMake will look for modules in the directories specified by [`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable: CMAKE_MODULE_PATH "(in CMake v3.29.2)"); if it cannot find it there, it will look in the Modules subdirectory. This way projects can override modules that CMake provides and customize them for their needs. Modules can be broken into a few main categories:
> 可以用模块文件的完整路径指定模块位置，也可以让 CMake 自己寻找模块，CMake 通过 `CMAKE_MODULE_PATH` 中指定的目录寻找模块，若没找到，则前往 Modules 子目录寻找模块，这样设计主要是方便用户自定义模块覆盖默认模块搜索路径

> 模块可以分类以下几个主要类别
### 6.1.1 Find Modules
These modules support the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command to determine the location of software elements, such as header files or libraries, that belong to a given package. Do not include them directly. Use the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command. Each module comes with documentation describing the package it finds and the variables in which it provides results.
> Find 模块支持 `find_package` 命令来决定一个给定包内的库文件、头文件的位置
> 不要直接 include package 内的这些文件，而是使用 `find_package` 命令
> 每个 Find 模块都有文档描述它找到的包和它所提供结果的一些变量
### 6.1.2 Utility Modules
Utility modules are simply sections of CMake commands put into a file; they can then be included into other CMakeLists files using the [`include`](https://cmake.org/cmake/help/latest/command/include.html#command: include "(in CMake v3.29.2)") command. For example, the following commands will include the [`CheckTypeSize`](https://cmake.org/cmake/help/latest/module/CheckTypeSize.html#module: CheckTypeSize "(in CMake v3.29.2)") module from CMake and then use the macro it defines.
```cmake
include(CheckTypeSize)
check_type_size(long SIZEOF_LONG)
```
> Utility 模块即一个文件中包含一些 CMake 命令，它们可以被 `include` 进其他的 CMakeLists 文件
> 例如 `include` 了 `CheckTypeSize` 模块之后，就可以使用它定义的宏

These modules test the system to provide information about the target platform or compiler, such as the size of a float or support for ANSI C++ streams. Many of these modules have names prefixed with `Test` or `Check`, such as [`TestBigEndian`](https://cmake.org/cmake/help/latest/module/TestBigEndian.html#module: TestBigEndian "(in CMake v3.29.2)") and [`CheckTypeSize`](https://cmake.org/cmake/help/latest/module/CheckTypeSize.html#module: CheckTypeSize "(in CMake v3.29.2)"). Some of them try to compile code in order to determine the correct result. In these cases, the source code is typically named the same as the module, but with a `.c` or `.cxx` extension. Utility modules also provide useful macros and functions implemented in the CMake language and intended for specific, common use cases. See documentation of each module for details.
> Utility 模块都会对系统进行测试，以提供关于目标平台或编译器的信息
> 许多 Utility模块有 `Test` 或 `Check` 前缀
> 一些 Utility 模块会编译代码来决定正确的结果，和这些模块相关的源文件名称一般和模块相同
> Utility 模块会提供一些使用 CMake 语言实现的宏和函数用于特定的目的
# 7 Installing Files
Software is typically installed into a directory separate from the source and build trees. This allows it to be distributed in a clean form and isolates users from the details of the build process. 
> 软件一般安装与和源目录和构建树不同的目录中，以干净地分发，并隔绝用户和构建过程

CMake provides the [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") command to specify how a project is to be installed. This command is invoked by a project in the CMakeLists file and tells CMake how to generate installation scripts. The scripts are executed at install time to perform the actual installation of files. For Makefile generators (UNIX, NMake, MinGW, etc.), the user simply runs `make install` (or `nmake install`) and the make tool will invoke CMake’s installation module. With GUI based systems (Visual Studio, Xcode, etc.), the user simply builds the target called `INSTALL`.
> CMake 提供 `install` 命令用于指定项目如何被安装
> 该命令被项目在 CMakeLists 中调用以告诉 CMake 如何生成安装脚本
> 安装脚本在安装时执行，执行文件地安装
> 对于 Makfile 生成器 (包括 Unix, NMake, MinGW) ，用户运行 `make install` ，然后 `make` 就会调用 CMake 的安装模块
> 对于 GUI 系统，用户直接构建名为 `INSTALL` 的目标

Each call to the [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") command defines some installation rules. Within one CMakeLists file (source directory), these rules will be evaluated in the order that the corresponding commands are invoked. The order across multiple directories changed in CMake 3.14.
> 对 `install` 命令的调用会设定安装规则，同一 CMakeLists 文件内，规则评估的顺序和调用顺序一致

The [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") command has several signatures designed for common installation use cases. A particular invocation of the command specifies the signature as the first argument. The signatures are `TARGETS`, `FILES` or `PROGRAMS`, `DIRECTORY`, `SCRIPT`, `CODE` and `EXPORT`.
> `install` 命令有许多签名/重载，对 `install` 的调用需要在第一个参数指定签名，如下介绍

```
install(TARGETS …)
```
Installs the binary files corresponding to targets built inside the project.
> 安装和项目内构建的目标对应的二进制文件

```
install(FILES …)
```
General-purpose file installation, which is typically used for header files, documentation, and data files required by your software.
> 用于通用目的的文件安装，一般用于软件要求的头文件、文档、数据文件

```
install(PROGRAMS …)
```
Installs executable files not built by the project, such as shell scripts. This argument is identical to `install(FILES)` except that the default permissions of the installed file include the executable bit. 
> 安装非该项目构建的可执行文件，例如 shell 脚本，其参数和 `install(FILES)` 类似，除了它安装的可执行文件默认权限是可执行的

```
install(DIRECTORY …)
```
This argument installs an entire directory tree. It may be used for installing directories with resources, such as icons and images.
> 安装整个目录树，可用于安装资源目录，例如图片

```
install(SCRIPT …)
```
Specifies a user-provided CMake script file to be executed during installation. This is typically used to define pre-install or post-install actions for other rules.
> 用于指定在安装时需要执行的 CMake 脚本，一般用于定义 install 前和 install 后的行为

```
install(CODE …)
```
Specifies user-provided CMake code to be executed during the installation. This is similar to `install (SCRIPT)` but the code is provided inline in the call as a string.
> 指定安装时需要执行的 CMake 代码，和上一个类似，差别在于代码为内联提供，形式是字符串

```
install(EXPORT …)
```
Generates and installs a CMake file containing code to import targets from the installation tree into another project.
> 生成并安装一个包含代码的 CMake 文件，以从安装树中 import 目标到另一个项目

The `TARGETS`, `FILES`, `PROGRAMS`, and `DIRECTORY` signatures are all meant to create install rules for files. The targets, files, or directories to be installed are listed immediately after the signature name argument. Additional details can be specified using keyword arguments followed by corresponding values. Keyword arguments provided by most of the signatures are as follows.
> `TARGETS, FILES, PROGRAMS, DIRECTORY` 签名主要用于创建文件的安装规则，需要被安装的文件、目录、目标需要在第一个参数之后立即列出，此外可以用关键字参数提供额外的细节指定，关键字参数如下介绍

```
DESTINATION
```
This argument specifies the location where the installation rule will place files, and must be followed by a directory path indicating the location. If the directory is specified as a full path, it will be evaluated at install time as an absolute path. If the directory is specified as a relative path, it will be evaluated at install time relative to the installation prefix. The prefix may be set by the user through the cache variable [`CMAKE_INSTALL_PREFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html#variable: CMAKE_INSTALL_PREFIX "(in CMake v3.29.2)"). A platform-specific default is provided by CMake: `/usr/local` on UNIX, and “\<SystemDrive\>/ `Program Files` /\<ProjectName\>” on Windows, where SystemDrive is along the lines of `C:` and ProjectName is the name given to the top-most [`project`](https://cmake.org/cmake/help/latest/command/project.html#command: project "(in CMake v3.29.2)") command.
> `DESTINATION` 参数指定了安装规则应该在哪个目录安装文件
> 如果给定的值是完整路径，该路径会直接在安装时作为绝对路径评估
> 如果是相对路径，在安装时它会添加上 installation 前缀，用户可以通过 `CMAKE_INSTALL_PREFIX` 对其进行设定
> UNIX 平台上，该变量的值默认为 `/usr/local`

```
PERMISSIONS
```
This argument specifies file permissions to be set on the installed files. This option is needed only to override the default permissions selected by a particular [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") command signature. Valid permissions are `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`, `GROUP_READ`, `GROUP_WRITE`, `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`, `SETUID`, and `SETGID`. Some platforms do not support all of these permissions; on such platforms those permission names are ignored.
> `PERMISSIONS` 参数指定安装文件的权限，该参数主要用于覆盖特定 `install` 签名选定的默认权限

```
CONFIGURATIONS
```
This argument specifies a list of build configurations for which an installation rule applies (Debug, Release, etc.). For Makefile generators, the build configuration is specified by the [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html#variable: CMAKE_BUILD_TYPE "(in CMake v3.29.2)") cache variable. For Visual Studio and Xcode generators, the configuration is selected when the [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") target is built. An installation rule will be evaluated only if the current install configuration matches an entry in the list provided to this argument. Configuration name comparison is case-insensitive.
> `CONFIGURATIONS` 参数指定安装规则应用时的构建配置
> 对于 Makefile 生成器，构建配置通过 `CMAKE_BUILD_TYPE` cache 变量指定，对于 GUI 配置在 `install` 目标构建时选定
> 一个安装规则只有在当前安装配置匹配了该参数值列表中的某一项才会被评估

```
COMPONENT
```
This argument specifies the installation component for which the installation rule applies. Some projects divide their installations into multiple components for separate packaging. For example, a project may define a `Runtime` component that contains the files needed to run a tool; a `Development` component containing the files needed to build extensions to the tool; and a `Documentation` component containing the manual pages and other help files. The project may then package each component separately for distribution by installing only one component at a time. By default, all components are installed. Component-specific installation is an advanced feature intended for use by package maintainers. It requires manual invocation of the installation scripts with an argument defining the `COMPONENT` variable to name the desired component. Note that component names are not defined by CMake. Each project may define its own set of components.
> `COMPONENT` 该参数指定了安装规则应用时的安装部件
> 一些项目将他们的安装划分为多个部件，例如 `Runtime` 部件包含了运行一个工具所需的文件，`Development` 部件包含了构建工具拓展所需的文件，`Documentation` 部件包含了文档和手册
> 项目可以分别打包各个部件，分别发布
> 默认安装所有部件
> 对指定部件的安装主要由包维护者使用，它要求人工调用安装脚本，且传入定义了 `COMPONENT` 变量的参数，CMake 不会定义部件名称，项目应该自己定义自己的部件集合

```
OPTIONAL
```
This argument specifies that it is not an error if the input file to be installed does not exist. If the input file exists, it will be installed as requested. If it does not exist, it will be silently not installed.
> `OPTINOAL` 参数指定如果需要安装的输入文件不存在时不是一个错误
> 若输入文件存在，则它会被安装，若不存在，就不安装
## 7.1 Installing Targets
Projects typically install some of the library and executable files created during their build process. The [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") command provides the `TARGETS` signature for this purpose.
> 项目一般会安装一些它们构建过程中创建的库和可执行文件
> 这对应于 `install` 的 `TARGETS` 签名

The `TARGETS` keyword is immediately followed by a list of the targets created using [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)") or [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)"), which are to be installed. One or more files corresponding to each target will be installed.
> `TARGET` 关键字后应该紧随一个由 `add_executable/library` 创建的目标列表，这些就是要安装的目标

Files installed with this signature may be divided into categories such as `ARCHIVE`, `LIBRARY`, or `RUNTIME`. These categories are designed to group target files by typical installation destination. The corresponding keyword arguments are optional, but if present, specify that other arguments following them apply only to target files of that type. Target files are categorized as follows:
> 由该签名安装的文件会被划分为 `ARCHIVE/LIBRARY/RUNTIME` 三类，不同类别有不同的安装目的地

**executables -** `RUNTIME`
    Created by [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)") (.exe on Windows, no extension on UNIX)
> 由 `add_executable` 创建的可执行目标属于 `RUNTIME ` 类，

**loadable modules -** `LIBRARY`
    Created by [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") with the `MODULE` option (.dll on Windows, .so on UNIX)
> 由 `add_library(MODULE)` 创建的可装载模块属于 `LIBRARY` 类，即 Windows 上的动态链接库，UNIX 上的共享目标文件

**shared libraries -** `LIBRARY`
    Created by [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") with the `SHARED` option on UNIX-like platforms (.so on most UNIX, .dylib on Mac)
> 由 `add_library(SHARED)` 创建的共享库在类 UNIX 平台上属于 `LIBRARY` 类，同样是 UNIX 上的 `.so`

**dynamic-link libraries -** `RUNTIME`
    Created by [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") with the `SHARED` option on Windows platforms (.dll)
> 由 `add_library(SHARED)` 创建的动态链接库在 Windows 平台上属于 `RUNTIME` 类，同样是 Windows 上的 `.dll`

**import libraries -** `ARCHIVE`
    A linkable file created by a dynamic-link library that exports symbols (.lib on most Windows, .dll.a on Cygwin and MinGW).
> 导入库即由导出符号的动态链接库创建的可链接文件，在大多数 Windows 平台上是 `.lib` ，输入 `ARCHIVE` 类

**static libraries -** `ARCHIVE`
    Created by [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") with the `STATIC` option (.lib on Windows, .a on UNIX, Cygwin, and MinGW)
> 静态库由 `add_library(STATIC)` 创建，在 Windows 平台上为 `.lib` ，在 UNIX 平台上为 `.a`  ，属于 `ARCHIVE` 类

Consider a project that defines an executable, `myExecutable`, which links to a shared library `mySharedLib`. It also provides a static library `myStaticLib` and a plugin module to the executable called `myPlugin` that also links to the shared library. The executable, static library, and plugin file may be installed individually using the commands
> 考虑一个项目，定义 `myExecutable` 可执行文件，链接到共享库 `mySharedLib` ，同时提供了 `myStaticLib` 和链接到共享库的插入模块 `myPlugin` ，可以用如下命令单独安装可执行文件、静态库、插入文件
```
install(TARGETS myExecutable DESTINATION bin)
install(TARGETS myStaticLib DESTINATION lib/myproject)
install(TARGETS myPlugin DESTINATION lib)
```

The executable will not be able to run from the installed location until the shared library to it links to is also installed. 
> 安装好的可执行文件在它链接的共享库被安装之前都不可以被运行

Installation of the library requires a bit more care in order to support all platforms. It must be installed in a location searched by the dynamic linker on each platform. On UNIX-like platforms, the library is typically installed to `lib`, while on Windows it should be placed next to the executable in `bin`. An additional challenge is that the import library associated with the shared library on Windows should be treated like the static library, and installed to `lib/myproject`. 
> 注意库安装的地址需要在可以由各个平台的动态链接器可以搜索到的位置
> 在类 UNIX 平台上，库一般安装在 `lib` 目录
> 在 Windows 平台上，则应该在 `bin` 目录中，和可执行文件同一目录
> 另外，在 Windows 平台上，和共享库相关的 import 库应该被视作静态库，且安装到 `lib/myproject`

In other words, we have three different kinds of files created with a single target name that must be installed to three different destinations! Fortunately, this problem can be solved using the category keyword arguments. The shared library may be installed using the command:
> 换句话说，对于一个目标名称，我们有3个不同类别的文件，需要被安装带三个不同的目录
> 我们使用 category 关键字参数解决该问题

> 可以使用如下命令安装共享库
```
install(TARGETS mySharedLib
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib/myproject)
```
This tells CMake that the `RUNTIME` file (.dll) should be installed to `bin`, the `LIBRARY` file (.so) should be installed to `lib`, and the `ARCHIVE` (.lib) file should be installed to `lib/myproject`. On UNIX, the `LIBRARY` file will be installed; on Windows, the `RUNTIME` and `ARCHIVE` files will be installed.
> 它告诉 CMake `RUNTIME` 文件，即 `.dll` 文件需要被安装到 `bin` ，`LIBRARY` 文件，即 `.so` 文件需要被安装到 `lib` ， `ARCHIVE` 文件，即 `.lib` 文件需要被安装到 `lib/myproject` 
> UNIX 上，`LIBRARY` 文件会被安装，Windows 上 `RUNTIME` 和 `ARCHIVE` 文件会被安装

If the above sample project is to be packaged into separate run time and development components, we must assign the appropriate component to each target file installed. The executable, shared library, and plugin are required in order to run the application, so they belong in a `Runtime` component. Meanwhile, the import library (corresponding to the shared library on Windows) and the static library are only required to develop extensions to the application, and therefore belong in a `Development` component.
> 如果上述实例项目需要被打包为多个运行时和开发组件，我们需要为每个安装的目标文件赋予特定的组件
> 为了运行应用程序，可执行文件、共享库、插件都是需要的，因此它们属于 `RUNTIME` 组件，同时，import 库 (对应于 Windows 上的共享库) 和静态库仅在为应用程序开发拓展时需要，因此属于 `Development` 组件

Component assignments may be specified by adding the `COMPONENT` argument to each of the commands above. You may also combine all of the installation rules into a single command invocation, which is equivalent to all of the above commands with components added. The files generated by each target are installed using the rule for their category.
> 组件分配通过为上述命令添加 `COMPONENT` 参数进行
> 我们可以把所有的安装规则结合进一次命令调用，使其等价于上述的所有命令
> 由每个目标生成的文件就根据它们的 category 的规则来安装
```cmake
install(TARGETS myExecutable mySharedLib myStaticLib myPlugin
        RUNTIME DESTINATION bin           COMPONENT Runtime
        LIBRARY DESTINATION lib           COMPONENT Runtime
        ARCHIVE DESTINATION lib/myproject COMPONENT Development)
```

Either `NAMELINK_ONLY` or `NAMELINK_SKIP` may be specified as a `LIBRARY` option. On some platforms, a versioned shared library has a symbolic link such as
> `LIBRARY` 选项可以指定为 `NAMELINK_ONLY` 或者 `NAMELINK_SKIP` ，在某些平台上，一个带有版本的共享库会有如下的符号连接
```
lib<name>.so -> lib<name>.so.1
```
where `lib<name>.so.1` is the soname of the library, and `lib<name>.so` is a “namelink” that helps linkers to find the library when given `-l<name>`. 
> 其中 `lib<name>.so.1` 就是实际使用的共享库的名称，而 `lib<name>.so` 则是一个“名称链接”，帮助链接器在给定 `-l<name>` 的情况下找到实际的库

The `NAMELINK_ONLY` option results in installation of only the namelink when a library target is installed. The `NAMELINK_SKIP` option causes installation of library files other than the namelink when a library target is installed. When neither option is given, both portions are installed. On platforms where versioned shared libraries do not have namelinks, or when a library is not versioned, the `NAMELINK_SKIP` option installs the library and the `NAMELINK_ONLY` option installs nothing. See the [`VERSION`](https://cmake.org/cmake/help/latest/prop_tgt/VERSION.html#prop_tgt: VERSION "(in CMake v3.29.2)") and [`SOVERSION`](https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html#prop_tgt: SOVERSION "(in CMake v3.29.2)") target properties for details on creating versioned, shared libraries.
> `NAMELNK_ONLY` 选项的作用是在安装一个库目标时，仅仅安装一个名称链接，而 `NAMELINK_SKIP` 选项是在安装一个库目标时，安装库文件，但不安装其名称链接
> 两个选项都不给定时，库文件和名称链接都安装
> 在一些有版本的共享库并没有名称链接的平台上，或者当一个库没有版本的情况下，`NAMELINK_SKIP` 就正常安装库，而 `NAMELINK_ONLY` 什么也不安装
## 7.2 Installing Files
Projects may install files other than those that are created with [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.29.2)") or [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)"), such as header files or documentation. General-purpose installation of files is specified using the `FILES` signature.
> 项目也会安装除了由 `add_executable/library` 创建的文件，例如头文件或文档
> 一般目的的文件安装使用 `FILES` 签名

The `FILES` keyword is immediately followed by a list of files to be installed. Relative paths are evaluated with respect to the current source directory. Files will be installed to the given `DESTINATION` directory. For example, the command installs the file `my-api.h` from the source tree, and the file `my-config.h` from the build tree into the include directory under the installation prefix. By default installed files are given the permissions `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`, and `WORLD_READ`, but this may be overridden by specifying the `PERMISSIONS` option. 
```cmake
install(FILES my-api.h ${CMAKE_CURRENT_BINARY_DIR}/my-config.h
        DESTINATION include)
```
> `FILES` 关键字之后紧随需要安装的文件列表，相对路径评估时为相对当前源目录，文件会被安装到给定的 `DESTINATION` 目录中
> 上述命令将 `my-api.h` 和 `my-config.h` 从源树和构建树安装到了 `include` 目录中
> 默认安装的文件的权限为 `OWNER_WRITE/READ` `GROUP_READ` `WORLD_READ` ，可以通过 `PERMISSIONS` 选项来覆盖

Consider cases in which users would want to install a global configuration file on a UNIX system that is readable only by its owner (such as root). We accomplish this with the command
```cmake
install(FILES my-rc DESTINATION /etc
        PERMISSIONS OWNER_WRITE OWNER_READ)
```
which installs the file `my-rc` with owner read/write permission into the absolute path `/etc`.

The `RENAME` argument specifies a name for an installed file that may be different from the original file. Renaming is allowed only when a single file is installed by the command. For example, the command
```
install(FILES version.h DESTINATION include RENAME my-version.h)
```
will install the file `version.h` from the source directory to `include/my-version.h` under the installation prefix.
> `RENAME` 参数为安装的文件指定一个新的名称，只有在安装单个文件时才允许重命名
## 7.3 Installing Programs
Projects may also install helper programs, such as shell scripts or Python scripts that are not actually compiled as targets. These may be installed with the `FILES` signature using the `PERMISSIONS` option to add execute permission. However, this case is common enough to justify a simpler interface. CMake provides the `PROGRAMS` signature for this purpose.
> 项目可以安装帮助程序，例如 shell/python 脚本，这些脚本不会被编译为目标
> 这些程序可以通过 `FILES` 签名安装，记得用 `PERMISSIONS` 添加可执行权限
> CMake 也提供了 `PROGRAMS` 签名

The `PROGRAMS` keyword is immediately followed by a list of scripts to be installed. This command is identical to the `FILES` signature, except that the default permissions additionally include `OWNER_EXECUTE`, `GROUP_EXECUTE`, and `WORLD_EXECUTE`. For example, we may install a Python utility script with the command
> `PROGRAMS` 后紧随一个脚本列表，该命令等价于 `FILES` 签名，除了默认权限多了 `OWNER/GROUP/WORLD_EXECUTE`
```
install(PROGRAMS my-util.py DESTINATION bin)
```
which installs `my-util.py` to the `bin` directory under the installation prefix and gives it owner, group, world read and execute permissions, plus owner write.
## 7.4 Installing Directories
Projects may also provide an entire directory full of resource files, such as icons or html documentation. An entire directory may be installed using the `DIRECTORY` signature.
> 项目可以通过 `DIRECTORY` 签名安装带有资源的整个目录

The `DIRECTORY` keyword is immediately followed by a list of directories to be installed. Relative paths are evaluated with respect to the current source directory. Each named directory is installed to the destination directory. The last component of each input directory name is appended to the destination directory as that directory is copied. For example, the command
> `DIRECTORY` 之后跟着需要安装的目录列表

```cmake
install(DIRECTORY data/icons DESTINATION share/myproject)
```
will install the `data/icons` directory from the source tree into `share/myproject/icons` under the installation prefix.
> 该命令将 `data/icons` 目录安装到 `share/myprojects/icons` 目录中

A trailing slash will leave the last component empty and install the contents of the input directory to the destination. The command
```
install(DIRECTORY doc/html/ DESTINATION doc/myproject)
```
installs the contents of `doc/html` from the source directory into `doc/myproject` under the installation prefix.
> 该命令将 `doc/html/` 下的所有内容安装到 `doc/myproject` 目录下

If no input directory names are given, as in
```cmake
install(DIRECTORY DESTINATION share/myproject/user)
```
the destination directory will be created but nothing will be installed into it.
> 若没有给定输入目录名称，则目标目录会被创建，但里面不会有东西

Files installed by the `DIRECTORY` signature are given the same default permissions as the `FILES` signature. Directories installed by the `DIRECTORY` signature are given the same default permissions as the `PROGRAMS` signature. The `FILE_PERMISSIONS` and `DIRECTORY_PERMISSIONS` options may be used to override these defaults. Consider a case in which a directory full of example shell scripts is to be installed into a directory that is both owner and group writable. We may use the command
> 由 `DIRECTORY` 签名安装的文件和由 `FILES` 签名安装的文件具有相同的权限，由 `DIRECTORY` 签名安装的目录和由 `PROGEAMS` 签名安装的文件具有相同的权限
> 可以用 `FILE/DIRECTORY_PERMISSIONS` 来覆盖默认权限
```cmake
install(DIRECTORY data/scripts DESTINATION share/myproject
        FILE_PERMISSIONS
          OWNER_READ OWNER_EXECUTE OWNER_WRITE
          GROUP_READ GROUP_EXECUTE
          WORLD_READ WORLD_EXECUTE
        DIRECTORY_PERMISSIONS
          OWNER_READ OWNER_EXECUTE OWNER_WRITE
          GROUP_READ GROUP_EXECUTE GROUP_WRITE
          WORLD_READ WORLD_EXECUTE
        )
```
which installs the directory `data/scripts` into `share/myproject/scripts` and sets the desired permissions. 

In some cases, a fully-prepared input directory created by the project may have the desired permissions already set. The `USE_SOURCE_PERMISSIONS` option tells CMake to use the file and directory permissions from the input directory during installation. If in the previous example the input directory were to have already been prepared with correct permissions, the following command may have been used instead:
> 有时，由项目准备好的输入目录可能已经设定好了权限
> `USE_SOURCE_PERMISSIONS` 用于告诉 CMake 安装时使用源目录的权限
```
install(DIRECTORY data/scripts DESTINATION share/myproject
        USE_SOURCE_PERMISSIONS)
```

If the input directory to be installed is under source management, there may be extra subdirectories in the input that you do not wish to install. There may also be specific files that should not be installed or be installed with different permissions, while most files get the defaults. The `PATTERN` and `REGEX` options may be used for this purpose. A `PATTERN` option is followed first by a globbing pattern and then by an `EXCLUDE` or `PERMISSIONS` option. A `REGEX` option is followed first by a regular expression and then by `EXCLUDE` or `PERMISSIONS`. The `EXCLUDE` option skips installation of those files or directories matching the preceding pattern or expression, while the `PERMISSIONS` option assigns specific permissions to them.
> 有时我们会有一些子目录不希望安装，有时我们会有一些特定的文件不希望安装或需要以不同的权限安装
> `PATTERN` 选项跟随一个通配符模式，该模式匹配的文件可以被随后的 `EXCLUDE` 或 `PERMISSIONS` 选项管理
> `REGEX` 选项同理，需要跟随一个正则表达式，而后跟随 `EXCLUDE` 或 `PERMISSIONS`
> `EXCLUDE` 即用于跳过匹配的文件或目录的安装，`PERMISSIONS` 用于指定权限

Each input file and directory is tested against the pattern or regular expression as a full path with forward slashes. A pattern will match only complete file or directory names occurring at the end of the full path, while a regular expression may match any portion. For example, the pattern `foo*` will match `.../foo.txt` but not `.../myfoo.txt` or `.../foo/bar.txt;` however, the regular expression `foo` will match all of them.
> 每个输入文件或目录都会与模式或正则表达式匹配，对于 pattern，匹配需要完全匹配，匹配的名称一定是完整的，且在路径的末尾，对于 regex，匹配可以部分匹配
> 例如 pattern `foo*` 可以匹配 `.../foo.txt` ，不能匹配 `.../myfoo.txt` `.../foo/bar.txt` ，而 regex 可以

Returning to the above example of installing an icons directory, consider the case in which the input directory is managed by git and also contains some extra text files that we do not want to install. The command
```cmake
install(DIRECTORY data/icons DESTINATION share/myproject
        PATTERN ".git" EXCLUDE
        PATTERN "*.txt" EXCLUDE)
```

installs the icons directory while ignoring any .git directory or text file contained. The equivalent command using the `REGEX` option is

```cmake
install(DIRECTORY data/icons DESTINATION share/myproject
        REGEX "/.git$" EXCLUDE
        REGEX "/[^/]*.txt$" EXCLUDE)
```
which uses ‘/’ and ‘$’ to constrain the match in the same way as the patterns.

Consider a similar case in which the input directory contains shell scripts and text files that we wish to install with different permissions than the other files. The command
```cmake
install(DIRECTORY data/other/ DESTINATION share/myproject
        PATTERN ".git" EXCLUDE
        PATTERN "*.txt"
          PERMISSIONS OWNER_READ OWNER_WRITE
        PATTERN "*.sh"
          PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE)
```
will install the contents of `data/other` from the source directory to `share/myproject` while ignoring .git directories and giving specific permissions to `.txt` and `.sh` files.
## 7.5 Installing Scripts
Project installations may need to perform tasks other than just placing files in the installation tree. Third-party packages may provide their own mechanisms for registering new plugins that must be invoked during project installation. The `SCRIPT` signature is provided for this purpose.
> 项目安装时，第三方包可能会提供子集的机制用于注册新的插件，这些机制需要在项目安装时被调用
> 因此需要使用 `SCRIPT` 签名

The `SCRIPT` keyword is immediately followed by the name of a CMake script. CMake will execute the script during installation. If the file name given is a relative path, it will be evaluated with respect to the current source directory. A simple use case is printing a message during installation. We first write a `message.cmake` file containing the code
> `SCRIPT` 跟随一个 CMake 脚本的名称，它会在安装时被执行
> 一个简单的用例是在安装时打印信息

```cmake
message("Installing My Project")
```
and then reference this script using the command:
```cmake
install(SCRIPT message.cmake)
```

Custom installation scripts are not executed during the main CMakeLists file processing; they are executed during the installation process itself. 
> 自定义的安装脚本不会再 CMakeLists 文件处理时被执行，而是在安装过程中被执行

Variables and macros defined in the code containing the `install (SCRIPT)` call will not be accessible from the script. 
> `SCRIPT` 执行的 CMake 脚本不能访问调用者的变量和宏

However, there are a few variables defined during the script execution that may be used to get information about the installation. The variable [`CMAKE_INSTALL_PREFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html#variable: CMAKE_INSTALL_PREFIX "(in CMake v3.29.2)") is set to the actual installation prefix. This may be different from the corresponding cache variable value, because the installation scripts may be executed by a packaging tool that uses a different prefix. An environment variable `ENV{DESTDIR}` may be set by the user or packaging tool. Its value is prepended to the installation prefix and to absolute installation paths to determine the location where files are installed. In order to reference an install location on disk, custom script may use `$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}` as the top portion of the path. The variable `CMAKE_INSTALL_CONFIG_NAME` is set to the name of the build configuration currently being installed (Debug, Release, etc.). During component-specific installation, the variable `CMAKE_INSTALL_COMPONENT` is set to the name of the current component.
> 但 CMake 在脚本执行时会定义一些变量用于获取安装信息
> 例如  `CMAKE_INSTALL_PREFIX` 的值为真实的安装前缀，可能与 cache 变量值不同，因为安装脚本可能被打包工具以一个不同的前缀执行
> 用户或打包工具可以设定环境变量 `ENV{DESTDIR}` ，该值会被前置到安装前缀之前和绝对安装路径之前
> 为了引用磁盘上的安装位置，自定义脚本可以使用 `$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}` 作为路径的顶部成分
> 又比如 `CMAKE_INSTALL_CONFIG_NAME` 的值为当前安装的构建配置
> 在特定部件的安装中，`CMAKE_INSTALL_COMPONENT` 的值被设定为当前 component 的名称
## 7.7 Installing Code
Custom installation scripts, as simple as the message above, are more easily created with the script code placed inline in the call to the [`install`](https://cmake.org/cmake/help/latest/command/install.html#command: install "(in CMake v3.29.2)") command. The `CODE` signature is provided for this purpose.
> 除了用另外的文件作为自定义安装脚本，还有一种选择是在 `install` 中调用 inline 代码
> 因此可以使用 `CODE` 签名

The `CODE` keyword is immediately followed by a string containing the code to place in the installation script. An install-time message may be created using the command
> `CODE` 之后跟随包含代码的字符串，作为安装脚本

```cmake
install(CODE "MESSAGE(\"Installing My Project\")")
```
which has the same effect as the `message.cmake` script but contains the code inline.
## 7.8 Installing Prerequisite Shared Libraries
Executables are frequently built using shared libraries as building blocks. When you install such an executable, you must also install its prerequisite shared libraries, called “prerequisites” because the executable requires their presence in order to load and run properly. 
> 可执行文件常常涉及到共享库，安装这类可执行文件时，我们必须也安装它的前置要求共享库，可执行文件需要装载这些库才可以运行

The three main sources of shared libraries are the operating system itself, the build products of your own project, and third party libraries belonging to an external project. 
> 三个共享库的主要来源是 OS 自身、我们自己项目的构建产物、属于外部项目的第三方库

The ones from the operating system may be relied upon to be present without installing anything: they are on the base platform where your executable runs. The build products in your own project presumably have [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.29.2)") build rules in the CMakeLists files, and so it should be straightforward to create CMake install rules for them. It is the third party libraries that frequently become a high maintenance item when there are more than a handful of them, or when the set of them fluctuates from version-to-version of the third party project. Libraries may be added, code may be reorganized, and the third party shared libraries themselves may actually have additional prerequisites that are not obvious at first glance.
> 由 OS 提供的共享库可以不需要安装直接使用，构建产物则一般来自于我们的项目中的 `add_library` 
> 一般需要维护的是第三方库，第三方库有时也会有额外的前提要求

CMake provides a module, [`BundleUtilities`](https://cmake.org/cmake/help/latest/module/BundleUtilities.html#module: BundleUtilities "(in CMake v3.29.2)") to make it easier to deal with required shared libraries. This module provides the `fixup_bundle` function to copy and fix prerequisite shared libraries using well-defined locations relative to the executable. For Mac bundle applications, it embeds the libraries inside the bundle, fixing them with `install_name_tool` to make a self-contained unit. On Windows, it copies the libraries into the same directory with the executable since executables will search in their own directories for their required DLLs.
> CMake 的 `BundleUtilities` 模块让处理所需的共享库更加容易
> 模块的 `fixup_bundle` 函数用于拷贝和修复可执行文件所要求的共享库，在 Windows 上，它会将库拷贝到和 exe 相同的目录(因为 Windows 平台上，exe 在同目录内搜索 dll)

The `fixup_bundle` function helps you create relocatable install trees. Mac users appreciate self-contained bundle applications: you can drag them anywhere, double click them, and they still work. They do not rely on anything being installed in a certain location other than the operating system itself. Similarly, Windows users without administrative privileges appreciate a relocatable install tree where an executable and all required DLLs are installed in the same directory, so that it works no matter where you install it. You can even move things around after installing them and it will still work.

To use `fixup_bundle`, first install one of your executable targets. Then, configure a CMake script that can be called at install time. Inside the configured CMake script, simply [`include`](https://cmake.org/cmake/help/latest/command/include.html#command: include "(in CMake v3.29.2)") [`BundleUtilities`](https://cmake.org/cmake/help/latest/module/BundleUtilities.html#module: BundleUtilities "(in CMake v3.29.2)") and call the `fixup_bundle` function with appropriate arguments.
> 首先安装一个 exe 目标，然后配置 CMake 脚本，用于在安装时调用，在脚本内 `include` `BundleUtilities` 模块，然后调用 `fixup_bundle` 函数

In CMakeLists.txt
```cmake
install(TARGETS myExecutable DESTINATION bin)

# To install, for example, MSVC runtime libraries:
include(InstallRequiredSystemLibraries)

# To install other/non-system 3rd party required libraries:
configure_file(
  ${CMAKE_CURRENT_SOURCE_DIR}/FixBundle.cmake.in
  ${CMAKE_CURRENT_BINARY_DIR}/FixBundle.cmake
  @ONLY
  )

install(SCRIPT ${CMAKE_CURRENT_BINARY_DIR}/FixBundle.cmake)
```

In FixBundle.cmake.in:
```cmake
include(BundleUtilities)

# Set bundle to the full path name of the executable already
# existing in the install tree:
set(bundle
   "${CMAKE_INSTALL_PREFIX}/myExecutable@CMAKE_EXECUTABLE_SUFFIX@")

# Set other_libs to a list of full path names to additional
# libraries that cannot be reached by dependency analysis.
# (Dynamically loaded PlugIns, for example.)
set(other_libs "")

# Set dirs to a list of directories where prerequisite libraries
# may be found:
set(dirs
   "@CMAKE_RUNTIME_OUTPUT_DIRECTORY@"
   "@CMAKE_LIBRARY_OUTPUT_DIRECTORY@"
   )

fixup_bundle("${bundle}" "${other_libs}" "${dirs}")
```

You are responsible for verifying that you have permission to copy and distribute the prerequisite shared libraries for your executable. Some libraries may have restrictive software licenses that prohibit making copies a la `fixup_bundle`.
# 8 System Inspection
This chapter will describe how to use CMake to inspect the environment of the system where the software is being built. This is a critical factor in creating cross-platform applications or libraries. It covers how to find and use system and user installed header files and libraries. It also covers some of the more advanced features of CMake, including the [`try_compile`](https://cmake.org/cmake/help/latest/command/try_compile.html#command: try_compile "(in CMake v3.29.2)") and [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.29.2)") commands. These commands are extremely powerful tools for determining the capabilities of the system and compiler that is hosting your software.
> 本章介绍使用 CMake 审查系统环境，包括了如何找到、使用系统以及用户安装的头文件和库，以及一些高级命令如 `try_compile/run` 用于决定系统和编译器的能力
## 8.1 Using Header Files and Libraries
Many C and C++ programs depend on external libraries; however, when it comes to the practical aspects of compiling and linking a project, taking advantage of existing libraries can be difficult for both developers and users. Problems typically show up as soon as the software is built on a system other than the one on which it was developed. Assumptions regarding where libraries and header files are located become obvious when they are not installed in the same place on the new computer and the build system is unable to find them. CMake has many features to aid developers in the integration of external software libraries into a project.
> 编译和链接项目时，利用现存的库往往是一个比较难的实际问题
> 当软件需要在它被开发之外的平台上构建时，往往会出现问题，因为构建系统找不到库和头文件
> CMake 有许多特性帮助开发者集成外部软件库到项目中

The CMake commands that are most relevant to this type of integration are the [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.29.2)"), [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)"), [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.29.2)"), [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.29.2)"), and [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") commands. For most C and C++ libraries, a combination of [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)") and [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.29.2)") will be enough to compile and link with an installed library. The command [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)") can be used to locate, or allow a user to locate a library, and [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.29.2)") can be used to find the path to a representative include file from the project. For example, if you wanted to link to the tiff library, you could use the following commands in your CMakeLists.txt file
> 相关的命令有 `find_file/library/path/program/package` ，对于多数 C++库，`find_library/path` 就足够编译和链接一个已下载的库
> `find_library` 用于定位库，`find_path` 用于找到项目中的 include 文件的路径

```cmake
# find libtiff, looking in some standard places
find_library(TIFF_LIBRARY
             NAMES tiff tiff2
             PATHS /usr/local/lib /usr/lib
            )

# find tiff.h looking in some standard places
find_path(TIFF_INCLUDES tiff.h
           /usr/local/include
           /usr/include
          )

add_executable(mytiff mytiff.c )

target_link_libraries(mytiff ${TIFF_LIBRARY})

target_include_directories(mytiff ${TIFF_INCLUDES})
```
The first command used is [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)"), which in this case, will look for a library with the name tiff or tiff2. The [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)") command only requires the base name of the library without any platform-specific prefixes or suffixes, such as .lib and .dll. The appropriate prefixes and suffixes for the system running CMake will be added to the library name automatically when CMake attempts to find it.
> 本例中， `find_library` 会寻找名为 `tiff/tiff2` 的库，`find_library` 不要求后缀名，它会根据平台自己添加

 All the `FIND_*` commands will look in the `PATH` environment variable. In addition, the commands allow the specification of additional search paths as arguments to be listed after the `PATHS` marker argument.
 > 所有的 `FIND_*` 命令都会查看 `PATH` 环境变量，且允许额外的搜索路径作为参数列出在 `PATHS` 之后
 
  In addition to supporting standard paths, Windows registry entries and environment variables can be used to construct search paths. The syntax for registry entries is the following:
 > Windows 注册表项和环境变量也可以用于构建搜索路径

```
[HKEY_CURRENT_USER\\Software\\Kitware\\Path;Build1]
```

Since software can be installed in many different places, it is impossible for CMake to find the library every time, but most standard installations should be covered. The `find_*` commands automatically create a cache variable so that users can override or specify the location from the CMake GUI. This way, if CMake is unable to locate the files it is looking for, users will still have an opportunity to specify them. If CMake does not find a file, the value is set to `VAR-NOTFOUND`; this value tells CMake that it should continue looking each time CMake’s configure step is run. Note that in if statements, values of `VAR-NOTFOUND` will evaluate as false.
> `find_*` 命令会自动创建一个 cache 变量，用户可以在 CMake GUI 覆盖该 cache 变量的值，因此用户可以在 CMake 定位不到文件时直接指定路径
> CMake 找不到文件时该变量就会被设定为 `VAR-NOTFOUND` ，该值告诉 CMake 它应该在每次 CMake 配置步骤运行时继续寻找文件

The next command used is [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.29.2)"), a general purpose command that, in this example, is used to locate a header file from the library. Header files and libraries are often installed in different locations, and both locations are required to compile and link programs that use them. The use of [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.29.2)") is similar to [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)"), although it only supports one name, a list of search paths.
> 本例中用的另一个命令是 `find_path` ，用于定位头文件
> 头文件和库一般安装在不同的位置，而二者对于编译和链接 exe 都是需要的
> `find_path` 用法和 `find_library` 类似，但仅支持一个名字

The remainder of the CMakeLists file may use the variables created by the `find_*` commands. The variables can be used without checking for valid values, as CMake will print an error message notifying the user if any of the required variables have not been set. The user can then set the cache values and reconfigure until the message goes away. Optionally, a CMakeLists file could use the [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.29.2)") command to use alternative libraries or options to build the project without the library if it cannot be found.
> CMakeLists 可以使用由 `find_*` 命令创建的变量，例如使用 `if` 命令在库没有找到的情况下使用一个替代的库

From the above example you can see how using the `find_*` commands can help your software compile on a variety of systems. It is worth noting that the `find_*` commands search for a match starting with the first argument and first path, so when listing paths and library names, list your preferred paths and names first. If there are multiple versions of a library and you would prefer tiff over tiff2, make sure they are listed in that order.
> 注意 `find_*` 命令根据顺序查找路径，因此要把优先的路径置前
## 8.2 System Properties
Although it is a common practice in C and C++ code to add platform-specific code inside preprocessor `ifdef` directives, for maximum portability this should be avoided. Software should not be tuned to specific platforms with `ifdefs`, but rather to a canonical system consisting of a set of features.
> 软件最好不要使用 `ifdef` 以对某个特定平台进行调节

Coding to specific systems makes the software less portable, because systems and the features they support change with time, and even from system to system. A feature that may not have worked on a platform in the past may be a required feature for the platform in the future. The following code fragments illustrate the difference between coding to a canonical system and a specific system:
```cmake
// coding to a feature
#ifdef HAS_FOOBAR_CALL
  foobar();
#else
  myfoobar();
#endif

// coding to specific platforms
#if defined(SUN) && defined(HPUX) && !defined(GNUC)
  foobar();
#else
  myfoobar();
#endif
```
The problem with the second approach is that the code will have to be modified for each new platform on which the software is compiled. 
For example, a future version of SUN may no longer have the foobar call. Using the `HAS_FOOBAR_CALL` approach, the software will work as long as `HAS_FOOBAR_CALL` is defined correctly, and this is where CMake can help.
> 上例展示了针对某一特性编码 (foobar call) 和针对某一平台编码的差异，如果需要使用 foobar call，最好针对这一特性编码

CMake can be used to define `HAS_FOOBAR_CALL` correctly and automatically by making use of the [`try_compile`](https://cmake.org/cmake/help/latest/command/try_compile.html#command: try_compile "(in CMake v3.29.2)") and [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.29.2)") commands. 
> 使用 `try_compile/run` 命令可以让 CMake 定义 `HAS_FOOBAR_CALL` 方便我们针对特性编码

These commands can be used to compile and run small test programs during the CMake configure step. The test programs will be sent to the compiler that will be used to build the project, and if errors occur, the feature can be disabled. These commands require that you write a small C or C++ program to test the feature. For example, to test if the `foobar` call is provided on the system, try compiling a simple program that uses `foobar`. 
> `try_compile/run` 命令可以被用于在 CMake 配置步骤中编译并且运行小的测试程序，测试程序会被交给用于构建项目的编译器
> `try_compile/run` 命令要求我们写好小的 C/C++ 程序来测试特性，例如，测试是否系统提供了 `foobar` 调用

First write the simple test program (`testNeedFoobar.c` in this example) and then add the CMake calls to the CMakeLists file to try compiling that code. If the compilation works then `HAS_FOOBAR_CALL` will be set to true.
```c
// --- testNeedFoobar.c -----

#include <foobar.h>
main()
{
  foobar();
}
```

```cmake
# --- testNeedFoobar.cmake ---

try_compile (HAS_FOOBAR_CALL
  ${CMAKE_BINARY_DIR}
  ${PROJECT_SOURCE_DIR}/testNeedFoobar.c
  )
```
> 本例中，我们首先写出简单的测试程序 `testNeedFoobar.c` ，然后在 CMakeLists 中 `try_compile` 该代码，如果可以编译，说明 `foobar()` 调用存在

Now that `HAS_FOOBAR_CALL` is set correctly in CMake, you can use it in your source code through the [`target_compile_definitions`](https://cmake.org/cmake/help/latest/command/target_compile_definitions.html#command: target_compile_definitions "(in CMake v3.29.2)") command. Alternatively, it is possible to configure a header file. This is discussed further in the section called [How to Configure a Header File](https://cmake.org/cmake/help/book/mastering-cmake/chapter/System%20Inspection.html#configure-header).
> 此时 `HAS_FOOBAR_CALL` 已经在 CMake 中正确设定好了，我们可以使用 `target_compile_definitions` 来使用它

Sometimes compiling a test program is not enough. In some cases, you may actually want to compile and run a program to get its output. A good example of this is testing the byte order of a machine. The following example shows how to write a small program that CMake will compile and run to determine the byte order of a machine.
> 有时仅仅编译不够，我们还需要编译并且运行并得到程序的输出
> 一个例子就是测试机器的字节序
```c
// ---- TestByteOrder.c ------

int main () {
  /* Are we most significant byte first or last */
  union
  {
    long l;
    char c[sizeof (long)];
  } u;
  u.l = 1;
  exit (u.c[sizeof (long) - 1] == 1);
}
```

```cmake
# ----- TestByteOrder.cmake-----

try_run(RUN_RESULT_VAR
  COMPILE_RESULT_VAR
  ${CMAKE_BINARY_DIR}
  ${PROJECT_SOURCE_DIR}/Modules/TestByteOrder.c
  OUTPUT_VARIABLE OUTPUT
  )
```
The return result of the run will go into `RUN_RESULT_VAR`, the result of the compile will go into `COMPILE_RESULT_VAR`, and any output from the run will go into `OUTPUT`. You can use these variables to report debug information to the users of your project.
> `try_run` 运行的程序的返回值会写入 `RUN_RESLUT_VAR` ，而编译的结果会被写入 `COMPILE_RESULT_VAR` 

For small test programs the [`file`](https://cmake.org/cmake/help/latest/command/file.html#command:file "(in CMake v3.29.2)") command with the `WRITE` option can be used to create the source file from the CMakeLists file. The following example tests the C compiler to verify that it can be run.
```cmake
file(WRITE
  ${CMAKE_BINARY_DIR}/CMakeTmp/testCCompiler.c
  "int main(){return 0;}"
  )

try_compile(CMAKE_C_COMPILER_WORKS
  ${CMAKE_BINARY_DIR}
  ${CMAKE_BINARY_DIR}/CMakeTmp/testCCompiler.c
  OUTPUT_VARIABLE OUTPUT
  )
```
> 对于小的测试程序，我们可以直接使用 `file(WRITE)` 来直接从 CMakeLists 文件中创建源文件

For more advanced [`try_compile`](https://cmake.org/cmake/help/latest/command/try_compile.html#command: try_compile "(in CMake v3.29.2)") and [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.29.2)") operations, it may be desirable to pass flags to the compiler or to CMake. Both commands support the optional arguments `CMAKE_FLAGS` and `COMPILE_DEFINITIONS`. `CMAKE_FLAGS` can be used to pass `-DVAR:TYPE=VALUE` flags to CMake. The value of `COMPILE_DEFINITIONS` is passed directly to the compiler command line.
> `try_compile/run` 还支持传递编译标志，支持 `CMAKE_FLAGS/COMPILE_DEFINITIONS`
> 其中 `CMAKE_FLAGS` 用于向 CMake 本身传递 `-DVAR:TYPE=VALUE` 标志，而 `COMPILE_DEFINITIONS` 的值则直接在命令行传递给编译器

There are several predefined try-run and try-compile modules available in CMake [`cmake-modules(7)`](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual: cmake-modules(7) "(in CMake v3.29.2)"), some of which are listed below. These modules allow some common checks to be performed without having to create a source file for each test. Many of these modules will look at the current value of the `CMAKE_REQUIRED_FLAGS` and `CMAKE_REQUIRED_LIBRARIES` variables to add additional compile flags or link libraries to the test.
> CMake `cmake-modules(7)` 有一些预定义的 try-run/compile 模块，其中一些列在下方
> 这些模块允许在为各个测试创建源文件的情况下执行一些常见的检查，其中许多模块也会查看 `CMAKE_REQUIRED_FLAGS` 和 `CMAKE_REQUIRED_LIBRARIES` 变量来为测试添加额外的编译标志和链接库

[`CheckIncludeFile`](https://cmake.org/cmake/help/latest/module/CheckIncludeFile.html#module:CheckIncludeFile "(in CMake v3.29.2)")
    Provides a macro that checks for an include file on a system by taking two arguments with first being the include file to look for and the second being the variable to store the result into. Additional CFlags can be passed in as a third argument or by setting `CMAKE_REQUIRED_FLAGS`.
> 提供一个用于检查 system 中 include 文件的宏
> 该宏有两个参数，第一个是需要寻找的 include 文件，第二个是用于存储结果的变量
> 接受额外的 CFlags，可以通过第三个参数传递，也可以通过设定 `CMAKE_REQUIRED_FLAGS`

[`CheckIncludeFileCXX`](https://cmake.org/cmake/help/latest/module/CheckIncludeFileCXX.html#module:CheckIncludeFileCXX "(in CMake v3.29.2)")
    Provides a macro that checks for an include file in a C++ program by taking two arguments with the first being the include file to look for and the second being the variable to store the result into. Additional CFlags can be passed in as a third argument.
> 提供一个用于检查 C++ 程序中 include 文件的宏
> 该宏有两个参数，第一个是需要寻找的 include 文件，第二个是用于存储结果的变量
> 接受额外的 CFlags，可以通过第三个参数传递

[`CheckIncludeFiles`](https://cmake.org/cmake/help/latest/module/CheckIncludeFiles.html#module: CheckIncludeFiles "(in CMake v3.29.2)")
    Provides a macro that checks if the given header files can be include together. This macro uses `CMAKE_REQUIRED_FLAGS` if it is set, and is useful when a header file you are interested in checking for is dependent on including another header file first.
> 提供一个用于检查给定的头文件是否可以一起 include 的宏
> 如果 `CMAKE_REQUIRED_FLAGS ` 被设定，该宏会使用
> 一般用于检查某个头文件是否需要依赖于先 include 其他的头文件

[`CheckLibraryExists`](https://cmake.org/cmake/help/latest/module/CheckLibraryExists.html#module:CheckLibraryExists "(in CMake v3.29.2)")
    Provides a macro that checks to see if a library exists by taking four arguments with the first being the name of the library to check for; the second being the name of a function that should be in that library; the third argument being the location of where the library should be found; and the fourth argument being a variable to store the result into. This macro uses `CMAKE_REQUIRED_FLAGS` and `CMAKE_REQUIRED_LIBRARIES` if they are set.
> 提供一个用于检查是否某个库存在的宏
> 有四个参数，第一个是苦命，第二个是库中的函数名，第三个是库的位置，第四个是存储返回值的变量
> 如果 `CMAKE_REQURIED_FALGS/LIBRARIES` 被设定，该宏会使用

[`CheckSymbolExists`](https://cmake.org/cmake/help/latest/module/CheckSymbolExists.html#module:CheckSymbolExists "(in CMake v3.29.2)")
    Provides a macro that checks to see if a symbol is defined in a header file by taking three arguments with the first being the symbol to look for; the second argument being a list of header files to try including; and the third argument being where the result is stored. This macro uses `CMAKE_REQUIRED_FLAGS` and `CMAKE_REQUIRED_LIBRARIES` if they are set.
> 提供一个用于检查定义于头文件的一个符号是否存在的宏
> 第一个参数为寻找的符号，第二个为需要尝试 include 的头文件列表

[`CheckTypeSize`](https://cmake.org/cmake/help/latest/module/CheckTypeSize.html#module:CheckTypeSize "(in CMake v3.29.2)")
    Provides a macro that determines the size in bytes of a variable type by taking two arguments with the first argument being the type to evaluate, and the second argument being where the result is stored. Both `CMAKE_REQUIRED_FLAGS` and `CMAKE_REQUIRED_LIBRARIES` are used if they are set.
> 决定变量类型的大小
> 第一个参数为变量类型

[`CheckVariableExists`](https://cmake.org/cmake/help/latest/module/CheckVariableExists.html#module:CheckVariableExists "(in CMake v3.29.2)")
    Provides a macro that checks to see if a global variable exists by taking two arguments with the first being the variable to look for, and the second argument being the variable to store the result in. This macro will prototype the named variable and then try to use it. If the test program compiles then the variable exists. This will only work for C variables. This macro uses `CMAKE_REQUIRED_FLAGS` and `CMAKE_REQUIRED_LIBRARIES` if they are set.
> 检查全局变量是否存在
> 第一个参数是要寻找的变量
> 该宏会首先 prototype 需要寻找的变量，然后尝试使用它，若成功编译，则变量存在
> 该宏仅针对 C 变量

Consider the following example which shows a variety of these modules being used to compute properties of the platform. At the beginning of the example four modules are loaded from CMake. The remainder of the example uses the macros defined in those modules to test for header files, libraries, symbols, and type sizes respectively.
```cmake
# Include all the necessary files for macros
include(CheckIncludeFiles)
include(CheckLibraryExists)
include(CheckSymbolExists)
include(CheckTypeSize)

# Check for header files
set(INCLUDES "")
check_include_files("${INCLUDES};winsock.h" HAVE_WINSOCK_H)

if(HAVE_WINSOCK_H)
  set(INCLUDES ${INCLUDES} winsock.h)
endif()

check_include_files("${INCLUDES};io.h" HAVE_IO_H)
if (HAVE_IO_H)
  set(INCLUDES ${INCLUDES} io.h)
endif()

# Check for all needed libraries
set(LIBS "")
check_library_exists("dl;${LIBS}" dlopen "" HAVE_LIBDL)
if(HAVE_LIBDL)
  set(LIBS ${LIBS} dl)
endif()

check_library_exists("ucb;${LIBS}" gethostname "" HAVE_LIBUCB)
if(HAVE_LIBUCB)
  set(LIBS ${LIBS} ucb)
endif()

# Add the libraries we found to the libraries to use when
# looking for symbols with the check_symbol_exists macro
set(CMAKE_REQUIRED_LIBRARIES ${LIBS})

# Check for some functions that are used
check_symbol_exists(socket "${INCLUDES}" HAVE_SOCKET)
check_symbol_exists(poll "${INCLUDES}" HAVE_POLL)

# Various type sizes
check_type_size(int SIZEOF_INT)
check_type_size(size_t SIZEOF_SIZE_T)
```
## 8.3 How to Pass Parameters to a Compilation
Once you have determined the features of the system in which you are interested, it is time to configure the software based on what has been found. There are two common ways to pass this information to the compiler: on the compile line, or using a pre-configured header. The first way is to pass definitions on the compile line. 
> 决定了系统的特性之后，就需要基于这些特性配置软件
> 有两种常用的向编译器传递信息的方式：on compile line 或使用 pre-configured header

A preprocessor definition can be passed to the compiler from a CMakeLists file with the [`target_compile_definitions`](https://cmake.org/cmake/help/latest/command/target_compile_definitions.html#command: target_compile_definitions "(in CMake v3.29.2)") command. For example, a common practice in C code is to have the ability to selectively compile in/out debug statements.
> 在 CMakeLists 文件中，可以通过 `target_compile_definitions` 向编译器传递预处理器定义，例如，C 代码中的一个常见做法是通过预处理定义来选择性编译 debug 语句

```c
#ifdef DEBUG_BUILD
  printf("the value of v is %d", v);
#endif
```

A CMake variable could be used to turn on or off debug builds using the [`option`](https://cmake.org/cmake/help/latest/command/option.html#command:option "(in CMake v3.29.2)") command:
```cmake
option(DEBUG_BUILD
      "Build with extra debug print messages.")

if(DEBUG_BUILD)
  target_compile_definitions(mytarget PUBLIC DEBUG_BUILD)
endif()
```
> CMake 中，可以使用 CMake 变量来实现 debug 构建的开关

Another example would be to tell the compiler the result of the previous `HAS_FOOBAR_CALL` test that was discussed earlier in this chapter. You could do this with the following:
```cmake
if (HAS_FOOBAR_CALL)
  target_compile_definitions(mytarget PUBLIC HAS_FOOBAR_CALL)
endif()
```
## 8.4 How to Configure a Header File
The second approach for passing definitions to the source code is to configure a header file. The header file will include all of the `#define` macros needed to build the project. To configure a file with CMake, the [`configure_file`](https://cmake.org/cmake/help/latest/command/configure_file.html#command: configure_file "(in CMake v3.29.2)") command is used. This command requires an input file that is parsed by CMake to produce an output file with all variables expanded or replaced. There are three ways to specify a variable in an input file for [`configure_file`](https://cmake.org/cmake/help/latest/command/configure_file.html#command: configure_file "(in CMake v3.29.2)").
> 除了 `target_compile_definitions` ，另一个向源码传递定义的方式就是配置一个头文件
> CMake 提供 `configure_file` 配置头文件，该命令需要一个输入文件，CMake 对其分析，然后产生输出文件，将输入文件内的变量都展开或替换
> 对于 `configure_file` 的输入文件，有三种方式在其中指定一个变量
```cmake
#cmakedefine VARIABLE
```
If `VARIABLE` is true, then the result will be:
```cmake
#define VARIABLE
```
If `VARIABLE` is false, then the result will be:
```cmake
/* #undef VARIABLE */
```

When writing a file to be configured, consider using `@VARIABLE@` instead of `${VARIABLE}` for variables that are expected to be expanded by CMake. Since the `${}` syntax is commonly used by other languages, users can tell the [`configure_file`](https://cmake.org/cmake/help/latest/command/configure_file.html#command: configure_file "(in CMake v3.29.2)") command to only expand variables using the `@var@` syntax by passing the `@ONLY` option to the command; this is useful if you are configuring a script that may contain `${var}` strings that you want to preserve. This is important because CMake will replace all occurrences of `${var}` with the empty string if `var` is not defined in CMake.
> 在写需要被 `configure` 的文件时，考虑对于期望被 CMake 展开的变量使用 `@VARIABLE` 而不是 `${VARIABLE}`
> 因为 `${}` 语法通常也会被其他语言使用，而通过向 `configure_file` 传递 `@ONLY` 选项，就可以让该命令仅展开使用 `@var@` 语法的变量，同时保持 `${var}` 不变，防止 CMake 在 `var` 没有在 CMake 中定义时将 `${var}` 全部替换为空字符串

The following example configures a .h file for a project that contains preprocessor variables. The first definition indicates if the `FOOBAR` call exists in the library, and the next one contains the path to the build tree.
> 该例展示了如何为项目 configure 头文件
> `h.in` 文件中的第一个定义用于表明 `FOOBAR` call 是否存在于库中
> 第二个定义包含了指向构建树的路径
```cmake
# ---- CMakeLists.txt file-----

# Configure a file from the source tree
# called projectConfigure.h.in and put
# the resulting configured file in the build
# tree and call it projectConfigure.h
configure_file(
   ${PROJECT_SOURCE_DIR}/projectConfigure.h.in
   ${PROJECT_BINARY_DIR}/projectConfigure.h
   @ONLY
   )
```

```
// -----projectConfigure.h.in file------
/* define a variable to tell the code if the */
/* foobar call is available on this system */
#cmakedefine HAS_FOOBAR_CALL

/* define a variable with the path to the */
/* build directory  */
#define PROJECT_BINARY_DIR "@PROJECT_BINARY_DIR@"
```
It is important to configure files into the binary tree, not the source tree. A single source tree may be shared by multiple build trees or platforms. By configuring files into the binary tree the differences between builds or platforms will be kept isolated in the build tree and will not corrupt other builds. This means that you will need to include the directory of the build tree where you configured the header file into the project’s list of include directories using the [`target_include_directories`](https://cmake.org/cmake/help/latest/command/target_include_directories.html#command: target_include_directories "(in CMake v3.29.2)") command.
> 要注意我们需要 configure 文件到二进制树 `${PROJECT_BINARY_DIR}` ，而不是源码树
> 单个源码树常常被多个构建树或者平台共享，因此我们希望 configure 文件到构建树，而不是污染源码树影响其他的构建树或平台
> 这也意味着我们需要使用 `target_include_directories` 命令来将构建树目录也添加到项目的 include 列表
# 9 Finding Packages
Many software projects provide tools and libraries that are meant as building blocks for other projects and applications. CMake projects that depend on outside packages locate their dependencies using the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command. 
> CMake 项目使用 `find_package` 来定位项目需要依赖的外部 package

A typical invocation is of the form:
```cmake
find_package(<Package> [version])
```
where `<Package>` is the name of the package to be found, and `[version]` is an optional version request (of the form `major[.minor.[patch]]`). The command’s notion of a package is distinct from that of CPack, which is meant for creating source and binary distributions and installers.
> 注意 `find_package` 的 package 指的是软件的依赖，而 CPack 的 package 指的是需要创建和发布的源和二进制 distributions 和 installers

The command operates in two modes: `Module` mode and `Config` mode. In Module mode, the command searches for a [`find module`](https://cmake.org/cmake/help/latest/manual/cmake-developer.7.html#manual: cmake-developer(7) "(in CMake v3.29.2)"): a file named `Find<Package>.cmake`. It looks first in the [`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable: CMAKE_MODULE_PATH "(in CMake v3.29.2)") and then in the CMake installation. If a find module is found, it is loaded to search for individual components of the package. Find modules contain package-specific knowledge of the libraries and other files they expect to find, and internally use commands like [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.29.2)") to locate them. CMake provides find modules for many common packages; see the [`cmake-modules(7)`](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual: cmake-modules(7) "(in CMake v3.29.2)") manual.
> `find_package` 命令有两种模式：`Module` 和 `Config` 
> Module 模式中，命令会搜索一个名为 `Find<Package>.cmake` 的查找模块 ( `find_module` ) ，它首先在 `CMAKE_MODULE_PATH` 查找，然后在 CMake 安装目录查找，如果找到了该模块，该模块被装载，然后搜索 package 的各个组成部分
> 查找模块包含了关于包的特定的库和其他预期要找到的文件的知识，事实上一些命令例如 `find_library` 也使用会使用查找模块
> CMake 为常用的 package 提供了查找模块

The Config mode of [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") provides a powerful alternative through cooperation with the package to be found. It enters this mode after failing to locate a find module or when explicitly requested by the caller. In Config mode the command searches for a `package configuration file`: a file named `<Package>Config.cmake` or `<package>-config.cmake` which is provided by the package to be found. 
> Config 模式会在被显式请求或者在定位不到查找模块时被启动
> 此时命令会搜索名为 `<Package>Config.cmake/<package>-config.cmake` 的包配置文件，该文件一般由需要查找的包的维护者提供，包含了定位包元信息和定位包的逻辑

Given the name of a package, the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command knows how to search deep inside installation prefixes for locations like:
```cmake
<prefix>/lib/<package>/<package>-config.cmake
```
(see documentation of the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command for a complete list of locations). 
> `find_package` 通过以上的方式寻找包的配置文件

CMake creates a cache entry called `<Package>_DIR` to store the location found or allow the user to set it. Since a package configuration file comes with an installation of its package, it knows exactly where to find everything provided by the installation. Once the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command locates the file, it provides the locations of package components without any additional searching.
> CMake 创建名为 `<Package>_DIR` 的 cache 项来存储找到的包的位置
> 因为包的配置文件会和包的安装一起提供，CMake 在找到了配置文件之后就可以确切地知道安装的一切内容需要在哪里找到
> 一旦 `find_package` 定位到了该配置文件，CMake 就可以直接定位包的组件的位置，无需额外的搜索

The `[version]` option asks [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") to locate a particular version of the package. In Module mode, the command passes the request on to the find module. In Config mode the command looks next to each candidate package configuration file for a `package version file`: a file named `<Package>ConfigVersion.cmake` or `<package>-config-<version>.cmake`. The version file is loaded to test whether the package version is an acceptable match for the version requested (see documentation of [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") for the version file API specification). If the version file claims compatibility, the configuration file is accepted, or is otherwise ignored. This approach allows each project to define its own rules for version compatibility.
> `find_package` 的 `[version]` 选项用于请求定位包的特定版本
> Module 模式下，会将该请求传递给查找模块
> Config 模式下会在每个找到的包配置文件旁寻找包版本文件，一般名为 `<Package>ConfigVersino.cmake/<package>-config-<versino>.cmake`
> 版本文件会被装载并测试是否符合要求
> 若版本是兼容的，则相应的配置文件就会被接受
> 版本的兼容规则可以由项目自定义
## 9.1 Built-in Find Modules
CMake has many predefined modules that can be found in the Modules subdirectory of CMake. The modules can find many common software packages. See the [`cmake-modules(7)`](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual: cmake-modules(7) "(in CMake v3.29.2)") manual for a detailed list.
> CMake 预定义的模块，包括查找模块，都位于 Modules 目录

Each `Find<XX>.cmake` module defines a set of variables that will allow a project to use the software package once it is found. Those variables all start with the name of the software being found `<XX>`. With CMake we have tried to establish a convention for naming these variables, but you should read the comments at the top of the module for a more definitive answer. The following variables are used by convention when needed:
> 查找模块定义了允许项目在包被找到之后使用的变量
> 变量名的前缀为找到的软件包的名称

`<XX>_INCLUDE_DIRS`
    Where to find the package’s header files, typically `<XX>.h`, etc.
> 包的头文件的路径

`<XX>_LIBRARIES`
    The libraries to link against to use `<XX>`. These include full paths.
> 包相关的库的路径

`<XX>_DEFINITIONS`
    Preprocessor definitions to use when compiling code that uses `<XX>`.
> 包的宏定义

`<XX>_EXECUTABLE`
    Where to find the `<XX>` tool that is part of the package.
> 包的可执行文件的路径

`<XX>_<YY>_EXECUTABLE`
    Where to find the `<YY>` tool that comes with `<XX>`.

`<XX>_ROOT_DIR`
    Where to find the base directory of the installation of `<XX>`. This is useful for large packages where you want to reference many files relative to a common base (or root) directory.
> 包的根目录

`<XX>_VERSION_<YY>`
    Version `<YY>` of the package was found if true. Authors of find modules should make sure at most one of these is ever true. For example TCL_VERSION_84.

`<XX>_<YY>_FOUND`
    If false, then the optional `<YY>` part of `<XX>` package is unavailable.

`<XX>_FOUND`
    Set to false or undefined if we haven’t found or don’t want to use `<XX>`.

Not all of the variables are present in each of the `FindXX.cmake files`. However, the `<XX>_FOUND` should exist under most circumstances. If `<XX>` is a library, then `<XX>_LIBRARIES` should also be defined, and `<XX>_INCLUDE_DIR` should usually be defined.
> 但注意不是所有的变量都在查找模块文件中有定义，一些变量视情况而被定义

Modules can be included in a project either with the [`include`](https://cmake.org/cmake/help/latest/command/include.html#command:include "(in CMake v3.29.2)") command or the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package "(in CMake v3.29.2)") command.
```
find_package(OpenGL)
```
is equivalent to:
```
include(${CMAKE_ROOT}/Modules/FindOpenGL.cmake)
```
and
```
include(FindOpenGL)
```
> 项目要 include 的模块要么使用 `include` 要么使用 `find_package`

If the project converts over to CMake for its build system, the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package "(in CMake v3.29.2)") will still work if the package provides a `<XX>Config.cmake` file. How to create a CMake package is described later in this chapter.
## 9.2 Creating CMake Package Configuration Files
Projects must provide package configuration files so that outside applications can find them. 
> 项目作为包发布时，需要提供包配置文件

Consider a simple project “Gromit” providing an executable to generate source code and a library against which the generated code must link. The `CMakeLists.txt` file might start with:
> 项目通过 `add_library/executable` 构建
```cmake
cmake_minimum_required(VERSION 3.20)
project(Gromit C)
set(version 1.0)
# Create library and executable.
add_library(gromit STATIC gromit.c gromit.h)
add_executable(gromit-gen gromit-gen.c)
```

In order to install Gromit and export its targets for use by outside projects, add the code:
> 项目通过 `install` 安装并 export 它的 target 以便外部项目可用
```cmake
# Install and export the targets.
install(FILES gromit.h DESTINATION include/gromit-${version})
install(TARGETS gromit gromit-gen
        DESTINATION lib/gromit-${version}
        EXPORT gromit-targets)
install(EXPORT gromit-targets
        DESTINATION lib/gromit-${version})
```

Finally, Gromit must provide a package configuration file in its installation tree so that outside projects can locate it with [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)"):
> 项目在它的安装树提供包配置文件，以方便外部项目通过 `find_package` 定位它
```cmake
# Create and install package configuration and version files.
configure_file(
   ${Gromit_SOURCE_DIR}/pkg/gromit-config.cmake.in
   ${Gromit_BINARY_DIR}/pkg/gromit-config.cmake @ONLY)

configure_file(
   ${Gromit_SOURCE_DIR}/gromit-config-version.cmake.in
   ${Gromit_BINARY_DIR}/gromit-config-version.cmake @ONLY)

install(FILES ${Gromit_BINARY_DIR}/pkg/gromit-config.cmake
         ${Gromit_BINARY_DIR}/gromit-config-version.cmake
         DESTINATION lib/gromit-${version})
```
This code configures and installs the package configuration file and a corresponding package version file. The package configuration input file `gromit-config.cmake.in` has the code:
```cmake
# Compute installation prefix relative to this file.
get_filename_component(_dir "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_prefix "${_dir}/../.." ABSOLUTE)

# Import the targets.
include("${_prefix}/lib/gromit-@version@/gromit-targets.cmake")

# Report other information.
set(gromit_INCLUDE_DIRS "${_prefix}/include/gromit-@version@")
```
After installation, the configured package configuration file `gromit-config.cmake` knows the locations of other installed files relative to itself. 
> 安装后，项目所配置好的包配置文件 `gromit-config.cmake` 就会其他安装的文件相对于它自身的位置

The corresponding package version file is configured from its input file `gromit-config-version.cmake.in`, which contains code such as:
```cmake
set(PACKAGE_VERSION "@version@")
if(NOT "${PACKAGE_FIND_VERSION}" VERSION_GREATER "@version@")
  set(PACKAGE_VERSION_COMPATIBLE 1) # compatible with older
  if("${PACKAGE_FIND_VERSION}" VERSION_EQUAL "@version@")
    set(PACKAGE_VERSION_EXACT 1) # exact match for this version
  endif()
endif()
```
> 对应的包版本文件同样用 `configure_file` 配置

An application that uses the Gromit package might create a CMake file that looks like this:
```cmake
cmake_minimum_required(VERSION 3.20)
project(MyProject C)

find_package(gromit 1.0 REQUIRED)
include_directories(${gromit_INCLUDE_DIRS})
# run imported executable
add_custom_command(OUTPUT generated.c
                   COMMAND gromit-gen generated.c)
add_executable(myexe generated.c)
target_link_libraries(myexe gromit) # link to imported library
```
The call to [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") locates an installation of Gromit or terminates with an error message if none can be found (due to `REQUIRED`). After the command succeeds, the Gromit package configuration file `gromit-config.cmake` has been loaded, so Gromit targets have been imported and variables like `gromit_INCLUDE_DIRS` have been defined.
> `find_package` 成功后，就会装载包配置文件 `gromit-config.cmake` ，因此 gromit 的目标就可以被 imported，并且 `gromit_INCLUDE_DIRS` 这样的变量就会被定义

The above example creates a package configuration file and places it in the `install` tree. One may also create a package configuration file in the `build` tree to allow applications to use the project without installation. In order to do this, one extends Gromit’s CMake file with the code:
> 上例创建了一个包配置文件，并将其放在了 `install` 树内
> 我们也可以创建包配置文件然后将其放在 `build` 树内，以允许应用在不进行安装的情况下使用我们的项目
```cmake
# Make project usable from build tree.
export(TARGETS gromit gromit-gen FILE gromit-targets.cmake)
configure_file(${Gromit_SOURCE_DIR}/gromit-config.cmake.in
               ${Gromit_BINARY_DIR}/gromit-config.cmake @ONLY)
```

This [`configure_file`](https://cmake.org/cmake/help/latest/command/configure_file.html#command:configure_file "(in CMake v3.29.2)") call uses a different input file, `gromit-config.cmake.in`, containing:
```cmake
# Import the targets.
include("@Gromit_BINARY_DIR@/gromit-targets.cmake")

# Report other information.
set(gromit_INCLUDE_DIRS "@Gromit_SOURCE_DIR@")
```
The package configuration file `gromit-config.cmake` placed in the build tree provides the same information to an outside project as that in the install tree, but refers to files in the source and build trees. It shares an identical package version file `gromit-config-version.cmake` which is placed in the install tree.
> 这次放在构建树中的包配置文件同样提供了安装树中的包配置文件需要提供的信息，它和安装树中的包配置文件共享安装树中的包版本文件
## 9.3 CMake Package Registry
CMake provides two central locations to register packages that have been built or installed anywhere on a system: a _User Package Registry_ and a _System Package Registry_. The [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command searches the two package registries as two of the search steps specified in its documentation. The registries are especially useful for helping projects find packages in non-standard install locations or directly in the package build trees. A project may populate either the user or system registry (using its own means) to refer to its location. In either case, the package should store a package configuration file at the registered location and optionally a package version file earlier in this chapter.
> CMake 为要安装的或构建的包提供了两个位置用于注册包：用户软件包注册表、系统软件包注册表
> `find_package` 命令会搜索这两个注册表
> 注册表帮助项目在非标准的地方寻找包，或直接在包的构建树中寻找包
> 包应该将包配置文件存储在注册的地方，包的版本文件也是一样 (optional) 

The _User Package Registry_ is stored in a platform-specific, per-user location.
>用户包注册表，针对各个用户

On Windows it is stored in the Windows registry under a key in `HKEY_CURRENT_USER`. A `<package>` may appear under registry key
```
HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\<package>
```
as a `REG_SZ` value with arbitrary name that specifies the directory containing the package configuration file. 
> Windows 中，包注册表在 `HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\<package>` key 下存储一个 `REG_SZ` 值，该值指向了包含包配置文件的目录

On UNIX platforms, the user package registry is stored in the user home directory under `~/.cmake/packages`. A `<package>` may appear under the directory as a file with arbitrary name whose content specifies the directory containing the package configuration file.
```
~/.cmake/packages/<package>
```
> UNIX 平台上，包注册表以文件的形式存储于用户的家目录

 The [`export(PACKAGE)`](https://cmake.org/cmake/help/latest/command/export.html#command: export "(in CMake v3.29.2)") command may be used to register a project build tree in the user package registry. CMake does not currently provide an interface to add install trees to the user package registry; installers must be manually taught to register their packages if desired.
 > `export(PACKAGE)` 命令可以用于在用户包注册表注册一个项目构建树
 > 对于安装树，CMake 没有提供将它注册到用户注册表的接口，安装程序需要自己在注册表中注册

The _System Package Registry_ is stored in a platform-specific, system-wide location. On Windows it is stored in the Windows registry under a key in `HKEY_LOCAL_MACHINE`. A `<package>` may appear under registry key
```
HKEY_LOCAL_MACHINE\Software\Kitware\CMake\Packages\<package>
```
as a `REG_SZ` value with arbitrary name that specifies the directory containing the package configuration file. There is no system package registry on non-Windows platforms. CMake does not provide an interface to add to the system package registry; installers must be manually taught to register their packages if desired.
> 非 Windows 平台没有系统包注册表，CMake 并没有提供相应的接口

Package registry entries are individually owned by the project installations that they reference. A package installer is responsible for adding its own entry and the corresponding uninstaller is responsible for removing it. However, in order to keep the registries clean, the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") command automatically removes stale package registry entries it encounters if it has sufficient permissions. An entry is considered stale if it refers to a directory that does not exist or does not contain a matching package configuration file. This is particularly useful for user package registry entries created by the [`export(PACKAGE)`](https://cmake.org/cmake/help/latest/command/export.html#command: export "(in CMake v3.29.2)") command for build trees which have no uninstall event and are simply deleted by developers.
> 包注册表项仅由它们指向的项目安装拥有
> 包的安装程序需要自己添加注册表项，包的卸载程序需要自己删除注册表项
> `find_package` 命令会自动移除过期的注册表项，过期的注册表项即指向了不再存在的目录或指向了不包含对应包配置文件的目录的注册表项
> 例如由 `export(PACKAGE)` 命令为了一些没有安装事件的构建树创建的用户包注册表项，这些构建树之后被开发者删除了，注册表项就过期了

Package registry entries may have arbitrary name. A simple convention for naming them is to use content hashes, as they are deterministic and unlikely to collide. The [`export(PACKAGE)`](https://cmake.org/cmake/help/latest/command/export.html#command: export "(in CMake v3.29.2)") command uses this approach. The name of an entry referencing a specific directory is simply the content hash of the directory path itself. For example, a project may create package registry entries such as
> 包注册表项的名称任意，对其命名的一个惯例是使用内容哈希值
> `export(PACKAGE)` 就使用该方法
```
> reg query HKCU\Software\Kitware\CMake\Packages\MyPackage
HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\MyPackage
 45e7d55f13b87179bb12f907c8de6fc4
                          REG_SZ  c:/Users/Me/Work/lib/cmake/MyPackage
 7b4a9844f681c80ce93190d4e3185db9
                          REG_SZ  c:/Users/Me/Work/MyPackage-build
```
on Windows, or
```
$ cat ~/.cmake/packages/MyPackage/7d1fb77e07ce59a81bed093bbee945bd
/home/me/work/lib/cmake/MyPackage
$ cat ~/.cmake/packages/MyPackage/f92c1db873a1937f3100706657c63e07
/home/me/work/MyPackage-build
```
on UNIX. The command [`find_package(MyPackage)`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") will search the registered locations for package configuration files. The search order among package registry entries for a single package is unspecified. Registered locations may contain package version files to tell [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.29.2)") whether a specific location is suitable for the version requested.
# 10 Custom Commands
Frequently the build process for a software project goes beyond simply compiling libraries and executables. In many cases, additional tasks may be required during or after the build process. Common examples include: compiling documentation using a documentation package; generating source files by running another executable; generating files using tools for which CMake doesn’t have rules (such as lex and yacc); moving the resulting executables; post processing the executable, etc. CMake supports these additional tasks using the [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") and [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.30.3)") commands. This chapter will describe how to use custom commands and targets to perform complex tasks that CMake does not inherently support.
> 软件在构建过程之后可能需要做额外的工作
> 例如：使用 documantation package 编译 documentation；运行另一个 exe 生成源文件；使用 CMake 没有对应规则的工具例如 lex 和 yacc 生成文件；移动 exe；后处理 exe
> CMake 通过 `add_custom_command/target` 为这些工作提供支持
## 10.1 Portable Custom Commands
Before going into detail on how to use custom commands, we will discuss how to deal with some of their portability issues. Custom commands typically involve running programs with files as inputs or outputs. Even a simple command, such as copying a file, can be tricky to do in a cross-platform way. For example, copying a file on UNIX is done with the `cp` command, while on Windows it is done with the `copy` command. To make matters worse, frequently the names of files will change on different platforms. Executables on Windows end with .exe, while on UNIX they do not. Even between UNIX implementations there are differences, such as which extensions are used for shared libraries; `.so`, `.sl`, `.dylib`, etc.
> 我们首先讨论自定义命令的可移植性
> 自定义命令一般是运行程序，程序接受文件输入，输出文件

CMake provides three main tools for handling these differences. The first is the `-E` option (short for execute) to [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.30.3)"). When the [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.30.3)") executable is passed the `-E` option, it acts as a general purpose, cross-platform utility command. The arguments following the `-E` option indicate what [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.30.3)") should do. These options provide a platform-independent way to perform a few common tasks including copy or remove files, compare and conditionally copy, time, create symlinks and others. The [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.30.3)") executable can be referenced by using the [`CMAKE_COMMAND`](https://cmake.org/cmake/help/latest/variable/CMAKE_COMMAND.html#variable: CMAKE_COMMAND "(in CMake v3.30.3)") variable in your CMakeLists files, as later examples will show.
> CMake 提供三个工具处理平台间的差异
> 其一是 `-E` 选项，cmake exe 被传入 `-E` 选项时，它将作为一个通用目的、跨平台的 utility 命令，`-E` 之后的参数告诉 cmake 需要执行什么，这些参数是独立于平台的，cmake 根据其语义执行对应命令
> CMakeLists 中使用 `CMAKE_COMMDN` 引用 cmake exe

Of course, CMake doesn’t limit you to using `cmake -E` in all your custom commands. You can use any command that you like, though it’s important to consider portability issues when doing it. A common practice is to use [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)") to find an executable (Perl, for example), and then use that executable in your custom commands.
> 可以都用 `-E` ，也可以考虑用 `find_program` 找到一个 exe，然后在我们的自定义命令中用这个 exe

The second tool that CMake provides to address portability issues is a number of variables describing the characteristics of the platform. The [`cmake-variables(7)`](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html#manual: cmake-variables(7) "(in CMake v3.30.3)") manual lists many variables that are useful for custom commands that need to reference files with platform-dependent names. These include [`CMAKE_EXECUTABLE_SUFFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_EXECUTABLE_SUFFIX.html#variable: CMAKE_EXECUTABLE_SUFFIX "(in CMake v3.30.3)"), [`CMAKE_SHARED_LIBRARY_PREFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_SHARED_LIBRARY_PREFIX.html#variable: CMAKE_SHARED_LIBRARY_PREFIX "(in CMake v3.30.3)"), etc. which describe file naming conventions.
> CMake 提供了描述平台特征的变量
> 这些变量可以用于帮助引用具有平台特定名称的文件

Finally, CMake supports [`generator expressions`](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual: cmake-generator-expressions(7) "(in CMake v3.30.3)") in custom commands. These are expressions that use the special syntax `$<...>` and are not evaluated while processing CMake input files, but are instead delayed until generation of the final build system. Therefore, the values substituted for them know all the details of their evaluation context, including the current build configuration and all build properties associated with a target.
> CMake 支持自定义命令中的 generator 表达式
> 这些表达式使用特殊语法 `$<...>` ，并且在处理 CMake 输入文件时不会被评估，会被延迟到生成最终构建系统时评估
> 因此它们的值会和它们的评估上下文相关，包括当前构建配置和目标相关的所有构建属性
## 10.2 Add Custom Command
Now we will consider the signature for [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)"). In Makefile terminology, [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") adds a rule to a Makefile. For those more familiar with Visual Studio, it adds a custom build step to a file. [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") has two main signatures: one for adding a custom command to a target and one for adding a custom command to build a file.
>对于 Makefile， `add_custom_command` 向 Makefile 中添加一个规则，对于 VS，则为文件添加一个自定义构建步骤
> `add_custom_command` 有两个签名，分别用于为目标添加自定义命令和为构建一个文件添加自定义命令

The target is the name of a CMake target (executable, library, or custom) to which you want to add the custom command. There is a choice of when the custom command should be executed. You can specify as many commands as you want for a custom command. They will be executed in the order specified.

Now let us consider a simple custom command for copying an executable once it has been built.
```cmake
# first define the executable target as usual
add_executable(Foo bar.c)

# then add the custom command to copy it
add_custom_command(
  TARGET Foo
  POST_BUILD
  COMMAND ${CMAKE_COMMAND}
  ARGS -E copy $<TARGET_FILE:Foo> /testing_department/files
  )
```
The first command in this example is the standard command for creating an executable from a list of source files. In this case, an executable named `Foo` is created from the source file `bar.c`. Next is the [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") invocation. Here the target is simply `Foo` and we are adding a post build command. The command to execute is [`cmake`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1) "(in CMake v3.30.3)") which has its full path specified in the [`CMAKE_COMMAND`](https://cmake.org/cmake/help/latest/variable/CMAKE_COMMAND.html#variable: CMAKE_COMMAND "(in CMake v3.30.3)") variable. Its arguments are `-E copy` and the source and destination locations. In this case, it will copy the `Foo` executable from where it was built into the `/testing_department/files` directory. Note that the `TARGET` parameter accepts a CMake target (`Foo` in this example), but arguments specified to the `COMMAND` parameter normally require full paths. In this case, we pass to `cmake -E copy`, the full path to the executable referenced via the `$<TARGET_FILE:...>` generator expression.
> 本例中为目标添加了一个 `POST_BUILD` 命令
> `${CMAKE_COMMAND}` 指定了 cmake 命令的路径
## 10.3 Generate a File
The second use for [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") is to add a rule for how to build an output file. Here the rule provided will replace any current rules for building that file. Keep in mind that [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") output must be consumed by a target in the same scope. As discussed later, the [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.30.3)") command can be used for this.
> 除了为目标添加命令，`add_custom_command` 还可以为如何构建输出文件添加规则，它会替换原来构建该文件的规则
> 注意 `add_custom_command` 的输出必须被相同作用域内的 target 使用
### 10.3.1 Using an Executable to Build a Source File
Sometimes a software project builds an executable that is then used for generating source files, which are used to build other executables or libraries. This may sound like an odd case, but it occurs quite frequently. 
> 项目有时会构建 exe，然后 exe 生成源文件，然后根据源文件再构建 exe 或库

One example is the build process for the TIFF library, which creates an executable that is then run to generate a source file that has system specific information in it. This file is then used as a source file in building the main TIFF library. Another example is the Visualization Toolkit (VTK), which builds an executable called `vtkWrapTcl` that wraps C++ classes into Tcl. The executable is built and then used to create more source files for the build process.
```cmake
###################################################
# Test using a compiled program to create a file
####################################################

# add the executable that will create the file
# build creator executable from creator.cxx
add_executable(creator creator.cxx)

# add the custom command to produce created.c
add_custom_command(
  OUTPUT ${PROJECT_BINARY_DIR}/created.c
  DEPENDS creator
  COMMAND creator ${PROJECT_BINARY_DIR}/created.c
  )

# add an executable that uses created.c
add_executable(Foo ${PROJECT_BINARY_DIR}/created.c)
```
The first part of this example produces the `creator` executable from the source file `creator.cxx`. The custom command then sets up a rule for producing the source file `created.c` by running the executable `creator`. The custom command depends on the `creator` target and writes its result into the output tree ([`PROJECT_BINARY_DIR`](https://cmake.org/cmake/help/latest/variable/PROJECT_BINARY_DIR.html#variable: PROJECT_BINARY_DIR "(in CMake v3.30.3)")). Finally, an executable target called `Foo` is added, which is built using the `created.c` source file. CMake will create all the required rules in the Makefile (or Visual Studio workspace) so that when you build the project, the `creator` executable will be built, and run to create `created.c`, which will then be used to build the `Foo` executable.
> 该例中首先构建 exe，然后用 custom 命令设定 `created.c` 的生成规则，最后用 `created.c` 构建 exe
> CMake 会在 Makefile 中创建对应的规则 (或者在 VS 工作空间中)
## 10.4 Adding a Custom Target
In the discussion so far, CMake targets have generally referred to executables and libraries. CMake supports a more general notion of targets, called custom targets, which can be used whenever you want the notion of a target but without the end product being a library or an executable. Examples of custom targets include targets to build documentation, run tests, or update web pages. To add a custom target, use the [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.30.3)") command.
> 除了 exe 和库，CMake 还支持自定义目标
> 自定义目标可以构建文档、运行测试、更新网页
> CMake 使用 `add_custom_target` 添加自定义目标

The name specified will be the name given to the target. You can use that name to specifically build that target with Makefiles (make name) or Visual Studio (right-click on the target and then select Build). 
If the optional `ALL` argument is specified, this target will be included in the `ALL_BUILD` target and will automatically be built whenever the Makefile or Project is built. 
> `ALL` 参数将目标包括进 `ALL_BUILD` 目标

The command and arguments are optional; if specified, they will be added to the target as a post-build command. For custom targets that will only execute a command this is all you will need. More complex custom targets may depend on other files, in these cases the `DEPENDS` arguments are used to list which files this target depends on. 
> 命令和参数会被添加到该目标的 post-build 命令中
> `DEPENDS` 用于列出自定义目标依赖的文件

We will consider examples of both cases. First, let us look at a custom target that has no dependencies:
```cmake
add_custom_target(FooJAR ALL
  ${JAR} -cvf "\"${PROJECT_BINARY_DIR}/Foo.jar\""
              "\"${PROJECT_SOURCE_DIR}/Java\""
  )
```
With the above definition, whenever the `FooJAR` target is built, it will run Java’s Archiver (jar) to create the `Foo.jar` file from java classes in the `${PROJECT_SOURCE_DIR}/Java` directory. In essence, this type of custom target allows the developer to tie a command to a target so that it can be conveniently invoked during the build process. 
> 该例在构建目标后运行 java 归档进程创建 .jar 文件

Now let us consider a more complex example that roughly models the generation of PDF files from LaTeX. In this case, the custom target depends on other generated files (mainly the end product .pdf files)
```cmake
# Add the rule to build the .dvi file from the .tex
# file. This relies on LATEX being set correctly
#
add_custom_command(
  OUTPUT  ${PROJECT_BINARY_DIR}/doc1.dvi
  DEPENDS ${PROJECT_SOURCE_DIR}/doc1.tex
  COMMAND ${LATEX} ${PROJECT_SOURCE_DIR}/doc1.tex
  )

# Add the rule to produce the .pdf file from the .dvi
# file. This relies on DVIPDF being set correctly
#
add_custom_command(
  OUTPUT  ${PROJECT_BINARY_DIR}/doc1.pdf
  DEPENDS ${PROJECT_BINARY_DIR}/doc1.dvi
  COMMAND ${DVIPDF} ${PROJECT_BINARY_DIR}/doc1.dvi
  )

# finally add the custom target that when invoked
# will cause the generation of the pdf file
#
add_custom_target(TDocument ALL
  DEPENDS ${PROJECT_BINARY_DIR}/doc1.pdf
  )
```
This example makes use of both [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") and [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.30.3)"). The two [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") invocations are used to specify the rules for producing a .pdf file from a .tex file. In this case, there are two steps and two custom commands. First a .dvi file is produced from the .tex file by running LaTeX, then the .dvi file is processed to produce the desired .pdf file. Finally, a custom target is added called TDocument. Its command simply echoes out what it is doing, while the real work is done by the two custom commands. The `DEPENDS` argument sets up a dependency between the custom target and the custom commands. When TDocument is built, it will first look to see if all of its dependencies are built. If any are not built, it will invoke the appropriate custom commands to build them.
> 该例用 `add_custom_command` 制定生成 .dvi .pdf 文件的规则，然后添加了自定义目标
> 在构建自定义目标 TDocument 时，CMake 会首先查找其依赖是否被构建，如果没有，调用自定义命令构建

This example can be shortened by combining the two custom commands into one custom command, as shown in the following example:
```cmake
# Add the rule to build the .pdf file from the .tex
# file. This relies on LATEX and DVIPDF being set correctly
#
add_custom_command(
  OUTPUT  ${PROJECT_BINARY_DIR}/doc1.pdf
  DEPENDS ${PROJECT_SOURCE_DIR}/doc1.tex
  COMMAND ${LATEX}  ${PROJECT_SOURCE_DIR}/doc1.tex
  COMMAND ${DVIPDF} ${PROJECT_BINARY_DIR}/doc1.dvi
  )

# finally add the custom target that when invoked
# will cause the generation of the pdf file

add_custom_target(TDocument ALL
  DEPENDS ${PROJECT_BINARY_DIR}/doc1.pdf
  )
```

Now consider a case where the documentation consists of multiple files. The above example can be modified to handle many files by using a list of inputs and a [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command:foreach "(in CMake v3.30.3)") loop. For example
```cmake
# set the list of documents to process
set(DOCS doc1 doc2 doc3)

# add the custom commands for each document
foreach(DOC ${DOCS})
  add_custom_command(
    OUTPUT  ${PROJECT_BINARY_DIR}/${DOC}.pdf
    DEPENDS ${PROJECT_SOURCE_DIR}/${DOC}.tex
    COMMAND ${LATEX} ${PROJECT_SOURCE_DIR}/${DOC}.tex
    COMMAND ${DVIPDF} ${PROJECT_BINARY_DIR}/${DOC}.dvi
    )

  # build a list of all the results
  list(APPEND DOC_RESULTS ${PROJECT_BINARY_DIR}/${DOC}.pdf)
endforeach()

# finally add the custom target that when invoked
# will cause the generation of the pdf file
add_custom_target(TDocument ALL
  DEPENDS ${DOC_RESULTS}
  )
```

In this example, building the custom target `TDocument` will cause all of the specified .pdf files to be generated. Adding a new document to the list is simply a matter of adding its filename to the `DOCS` variable at the top of the example.
## 10.5 Specifying Dependencies and Outputs
When using custom commands and custom targets you will often be specifying dependencies. When you specify a dependency or the output of a custom command, you should always specify the full path. For example, if the command produces `foo.h` in the binary tree then its output should be something like `${PROJECT_BINARY_DIR}/foo.h`. CMake will try to determine the correct path for the file if it is not specified; complex projects frequently end up using files in both the source and build trees, this can eventually lead to errors if the full paths are not specified.
> 为自定义命令制定依赖或输出时，需要指定完整路径
> 因为 CMake 会在没有指定完整路径时在当前路径寻找文件，但复杂的项目一般会同时使用源和构建树中的文件，因此 CMake 的默认行为不一定正确

When specifying a target as a dependency, you can leave off the full path and executable extension, referencing it simply by its name. Consider the specification of the generator target as an [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") dependency in the example earlier in this chapter. CMake recognizes `creator` as matching an existing target and properly handles the dependencies.
> 而将一个目标作为依赖时，可以仅用它的名字，CMake 会将这个名字与现存的目标匹配

## 10.5 When There Isn’t One Rule For One Output
There are a couple of unusual cases that can arise when using custom commands that warrant further explanation. The first is a case where one command (or executable) can create multiple outputs, and the second is when multiple commands can be used to create a single output.
> 本节考虑一个命令创建多个输出和多个命令创建一个输出的情况
### 10.5.1 A Single Command Producing Multiple Outputs
In CMake, a custom command can produce multiple outputs simply by listing multiple outputs after the `OUTPUT` keyword. CMake will create the correct rules for your build system so that no matter which output is required for a target, the right rules will be run. If the executable happens to produce a few outputs but the build process is only using one of them, then you can simply ignore the other outputs when creating your custom command. Say that the executable produces a source file that is used in the build process, and also an execution log that is not used. The custom command should specify the source file as the output and ignore the fact that a log file is also generated.
> 需要创建多个输出时，在 `OUTPUT` 之后列出
> 如果 exe 创建的多个输出中有一些在构建过程中不会用到，可以不指定它们

Another case of having one command with multiple outputs is when the command is the same but the arguments to it change. This is effectively the same as having a different command, and each case should have its own custom command. An example of this was the documentation example, where a custom command was added for each .tex file. The command is the same but the arguments passed to it change each time.
> 相同的命令但参数不同也会导致单命令多输出
> 这应该被视作多个命令，每一例都应该有自己的 custom 命令，各自的参数不同
### 10.5.2 Having One Output That Can Be Generated By Different Commands
In rare cases, you may find that you have more than one command that you can use to generate an output. Most build systems, such as make and Visual Studio, do not support this and likewise CMake does not. There are two common approaches that can be used to resolve this. If you truly have two different commands that produce the same output and no other significant outputs, then you can simply pick one of them and create a custom command for it.
> 多数构建系统不支持多命令单输出，包括 CMake

In more complex cases there are multiple commands with multiple outputs; for example:
```
Command1 produces foo.h and bar.h
Command2 produces widget.h and bar.h
```
There are a few approaches that can be used in this case. You might consider combining both commands and all three outputs into a single custom command, so that whenever one output is required, all three are built at the same time. You could also create three custom commands, one for each unique output. The custom command for `foo.h` would invoke Command1, while the one for `widget.h` would invoke Command2. When specifying the custom command for `bar.h`, you could choose either Command1 or Command2.
# 11 Converting Existing Systems to CMake
For many people, the first thing they will do with CMake is convert an existing project from using an older build system to use CMake. This can be a fairly easy process, but there are a few issues to consider. This section will address those issues and provide some suggestions for effectively converting a project over to CMake. 
The first issue to consider when converting to CMake is the project’s directory structure.
> 本章讨论将其他构建系统转换为 CMake
> 首先要考虑的问题是项目的目录结构
## 11.1 Source Code Directory Structures
Most small projects will have their source code in either the top level directory or in a directory named `src` or `source`. Even if all of the source code is in a subdirectory, we highly recommend creating a CMakeLists file for the top level directory. There are two reasons for this. First, it can be confusing to some people that they must run CMake on the subdirectory of the project, instead of the main directory. Second, you may want to install documentation or other support files from the other directories. By having a CMakeLists file at the top of the project, you can use the [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command: add_subdirectory "(in CMake v3.30.3)") command to step down into the documentation directory where its CMakeLists file can install the documentation (you can have a CMakeLists file for a documentation directory with no targets or source code).
> 虽然源码在 src 目录，但推荐在顶级目录创建 CMakeLists，提醒人们在主目录运行 cmake，以及方便用 `add_subdirectory` 安装文件到其他目录

For projects that have source code in multiple directories, there are a few options. One option that many Makefile-based projects use is to have a single Makefile at the top-level directory that lists all the source files to compile in their subdirectories. For example:
> 源码分布于多个目录是，在 Makefile 中可以如下写
```makefile
SOURCES=\
  subdir1/foo.cxx \
  subdir1/foo2.cxx \
  subdir2/gah.cxx \
  subdir2/bar.cxx
```

This approach works just as well with CMake using a similar syntax:
> CMake 类似
```cmake
set(SOURCES
  subdir1/foo.cxx
  subdir1/foo2.cxx
  subdir1/gah.cxx
  subdir2/bar.cxx
  )
```

Another option is to have each subdirectory build a library or libraries that can then be linked into the executables. In those cases, each subdirectory would define its own list of source files and add the appropriate targets. 
> 也可以各个子目录自己定义目标构建库，然后库链接到 exe

A third option is a mixture of the first two; each subdirectory can have a CMakeLists file that lists its sources, but the top-level CMakeLists file will not use the [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command: add_subdirectory "(in CMake v3.30.3)") command to step into the subdirectories. Instead, the top-level CMakeLists file will use the [`include`](https://cmake.org/cmake/help/latest/command/include.html#command: include "(in CMake v3.30.3)") command to include each of the subdirectory’s CMakeLists files. For example, a top-level CMakeLists file might include the following code
> 也可以两个方法混合，顶级的 CMakeLists 使用 inlcude 将子目录的 CMakeLists 包括，而不是用 `add_subdirectory` ，然后去获得子目录中的文件

```cmake
# collect the files for subdir1
include(subdir1/CMakeLists.txt)
foreach(FILE ${FILES})
  set(subdir1Files ${subdir1Files} subdir1/${FILE})
endforeach()

# collect the files for subdir2
include(subdir2/CMakeLists.txt)
foreach(FILE ${FILES})
  set(subdir2Files ${subdir2Files} subdir2/${FILE})
endforeach()

# add the source files to the executable
add_executable(foo ${subdir1Files} ${subdir2Files})
```

While the CMakeLists files in the subdirectories might look like the following:
> 子目录中的 CMakeLists 文件设定好 FILES 变量供父目录使用
```cmake
# list the source files for this directory
set(FILES
  foo1.cxx
  foo2.cxx
  )
```

The approach you use is entirely up to you. For large projects, having multiple shared libraries can certainly improve build times when changes are made. For smaller projects, the other two approaches have their advantages. The main suggestion here is to choose a strategy and stick with it.
> 对于大型项目，使用多个共享库可以提高有修改时的构建时间
> 对于小型项目，则两种方式各有优势
## 11.2 Build Directories
The next issue to consider is where to put the resulting object files, libraries, and executables. There are a few different, commonly used approaches, and some work better with CMake than others. The recommended strategy is to put the binary files into a separate tree that has the same structure as the source tree. 
> 第二个问题是哪里放目标文件、库和 exe
> 推荐将二进制文件放在一个和源树相同结构的二进制树中

For example, if the source tree looked like the following:
```
foo/
  subdir1
  subdir2
```

the binary tree might look like:
```
foobin/
  subdir1
  subdir2
```

For some Windows generators, such as Visual Studio, build files are actually kept in a subdirectory matching the selected configuration; e.g. debug, release, etc.
> VS 会把构建文件放在关联特定配置的子目录

If you need to support multiple architectures from one source tree, we highly recommend a directory structure like the following:
> 单源树对应多构建树
```
projectfoo/
  foo/
    subdir1
    subdir2
  foo-linux/
    subdir1
    subdir2
  foo-osx/
    subdir1
    subdir2
  foo-solaris/
    subdir1
    subdir2
```
That way, each architecture has its own build directory and will not interfere with any other architecture. Remember that not only are the object files kept in the binary directories, but also any configured files that are typically written to the binary tree. 
> 各个构建互不干扰，注意 configured 文件一般也会放入构建树

Another tree structure found primarily on UNIX projects is one where the binary files for different architectures are kept in subdirectories of the source tree (see below). CMake does not work well with this structure, so we recommend switching to the separate build tree structure shown above.
```
foo/
  subdir1/
    linux
    solaris
    hpux
  subdir2/
    linux
    solaris
    hpux
```

CMake provides three variables for controlling where binary targets are written. They are the [`CMAKE_RUNTIME_OUTPUT_DIRECTORY`](https://cmake.org/cmake/help/latest/variable/CMAKE_RUNTIME_OUTPUT_DIRECTORY.html#variable: CMAKE_RUNTIME_OUTPUT_DIRECTORY "(in CMake v3.30.3)"), [`CMAKE_LIBRARY_OUTPUT_DIRECTORY`](https://cmake.org/cmake/help/latest/variable/CMAKE_LIBRARY_OUTPUT_DIRECTORY.html#variable: CMAKE_LIBRARY_OUTPUT_DIRECTORY "(in CMake v3.30.3)"), and [`CMAKE_ARCHIVE_OUTPUT_DIRECTORY`](https://cmake.org/cmake/help/latest/variable/CMAKE_ARCHIVE_OUTPUT_DIRECTORY.html#variable: CMAKE_ARCHIVE_OUTPUT_DIRECTORY "(in CMake v3.30.3)") variables. These variables are used to initialize properties of libraries and executables to control where they will be written. Setting these enables a project to place all the libraries and executables into a single directory.  For projects with many subdirectories, this can be a real time saver. 
> `CMAKE_RUNTIME/LIBRARY/ARCHIVE_OUTPUT_DIRECTORY` 设定二进制树的路径

A typical implementation is shown below:
```cmake
# Setup output directories.
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
```

In this example, all the “runtime” binaries will be written to the `bin` subdirectory of the project’s binary tree, including executable files on all platforms and DLLs on Windows. Other binaries will be written to the `lib` directory. This approach is very useful for projects that make use of shared libraries (DLLs) because it collects all of the shared libraries into one directory. If the executables are placed in the same directory, then they can find the required shared libraries more easily when run on Windows.
> 本例中，runtime (exe 和 Windows 的 dll) 被写入 bin，其他被写入 lib

One final note on directory structures: with CMake, it is perfectly acceptable to have a project within a project. For example, within the Visualization Toolkit’s source tree is a directory that contains a complete copy of the zlib compression library. In writing the CMakeLists file for that library, we use the [`project`](https://cmake.org/cmake/help/latest/command/project.html#command: project "(in CMake v3.30.3)") command to create a project named VTKZLIB even though it is within the VTK source tree and project. This has no real impact on VTK, but it does allow us to build zlib independent of VTK without having to modify its CMakeLists file.
> CMake 支持项目嵌套
> 使用 `project` 在项目子目录的 CMakeLists 指定项目，然后在不影响父项目的情况下构建子项目
## 11.3 Useful CMake Commands When Converting Projects
There are a few CMake commands that can make the job of converting an existing project easier and faster. The [`file`](https://cmake.org/cmake/help/latest/command/file.html#command: file "(in CMake v3.30.3)") command with the `GLOB` argument allows you to quickly set a variable containing a list of all the files that match the glob expression. For example:
> `file(GLOB)` 可以用于快速设定一个匹配了 glob 表达式的文件列表
```cmake
# collect up the source files
file(GLOB SRC_FILES "*.cxx")

# create the executable
add_executable(foo ${SRC_FILES})
```
will set the `SRC_FILES` variable to a list of all the `.cxx` files in the current source directory. It will then create an executable using those source files. Windows developers should be aware that glob matches are case sensitive.
## 11.4 Converting UNIX Makefiles
If your project is currently based on standard UNIX Makefiles then their conversion to CMake should be fairly straightforward. Essentially, for every directory in your project that has a Makefile, you will create a matching CMakeLists file. How you handle multiple Makefiles in a directory depends on their function. If the additional Makefiles (or Makefile type files) are simply included in the main Makefile, you can create matching CMake input (.cmake) files and include them into your main CMakeLists file in a similar manner. If the different Makefiles are meant to be invoked on the command line for different situations, consider creating a main CMakeLists file that uses some logic to choose which one to [`include`](https://cmake.org/cmake/help/latest/command/include.html#command: include "(in CMake v3.30.3)") based on a CMake option.
> 对于 Makefile 项目，每一个 Makefile 都替换为 CMakeLists
> 对于一个目录中有多个 Makefile 则看情况：
> 如果其他 Makefile 仅仅被主 Makefile include，则我们创建一个对应的 CMake input (.cmake) 文件，然后再主 CMakeLists 中 include 对应文件
> 如果不同的 Makefile 意在不同的情况被分别调用，则考虑在主 CMakeLists 中使用逻辑选择其中一个 include

Frequently Makefiles have a list of object files to compile. These can be converted to CMake variables as follows:
```
OBJS= \
  foo1.o \
  foo2.o \
  foo3.o
```

becomes
```
set(SOURCES
  foo1.c
  foo2.c
  foo3.c
)
```

While the object files are typically listed in a Makefile, in CMake the focus is on the source files. If you used conditional statements in your Makefiles, they can be converted over to CMake [`if`](https://cmake.org/cmake/help/latest/command/if.html#command: if "(in CMake v3.30.3)") commands. Since CMake handles generating dependencies, most dependencies or rules to generate dependencies can be eliminated. Where you have rules to build libraries or executables, replace them with [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.30.3)") or [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)") commands.
> Makefile 中会列出目标文件，CMake 则专注源文件
> 因为 CMake 会自己处理依赖的生成，Makefile 中生成依赖的对应规则可以换为 `add_library/executable`

Some UNIX build systems (and source code) make heavy use of the system architecture to determine which files to compile or what flags to use. Typically this information is stored in a Makefile variable called `ARCH` or `UNAME`
> UNIX 构建系统会使用系统结构决定需要编译的文件和需要使用的标志
> Makfile 中一般用 `ARCH/UNAME` 存储这些信息

The first choice in these cases is to replace the architecture-specific code with a more generic test. With some software packages, there is too much architecture specific code for such a change to be reasonable, or you may want to make decisions based on architecture for other reasons. In those cases, you can use the variables [`CMAKE_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html#variable: CMAKE_SYSTEM_NAME "(in CMake v3.30.3)") and [`CMAKE_SYSTEM_VERSION`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_VERSION.html#variable: CMAKE_SYSTEM_VERSION "(in CMake v3.30.3)"). They provide fairly detailed information on the operating system and version of the host computer.
> 可以将针对架构的代码替换为更通用的
> 如果要针对架构编码，则考虑使用 `CMAKE_SYSTEM_NAME/VERSION` 
## 11.5 Converting Autoconf Based Projects
pass
## 11.6 Converting Windows Based Workspaces
To convert a Visual Studio solution to CMake involves a few steps. First you will need to create a CMakeLists file at the top of your source code directory. As always, this file should start with [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html#command: cmake_minimum_required "(in CMake v3.30.3)") and [`project`](https://cmake.org/cmake/help/latest/command/project.html#command: project "(in CMake v3.30.3)") command that defines the name of the CMake project. This will become the name of the resulting Visual Studio solution. Next, add all of your source files into CMake variables. For large projects that have multiple directories, create a CMakeLists file in each directory as described in the section on source directory structures at the beginning of this chapter. You will then add your libraries and executables using [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command: add_library "(in CMake v3.30.3)") and [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)"). By default, [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)") assumes that your executable is a console application. Adding the `WIN32` argument to [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)") indicates that it is a Windows application (using WinMain instead of main).
> 首先在源树根目录创建 CMakeLists
> `project` 决定了 VS solution 文件的名称
> 然后将源文件都加入到 CMake 变量
> 然后用 `add_library/executable` 添加库和 exe
> CMake 默认将 `add_executable` 认为是控制台应用程序

There are a few nice features that Visual Studio supports and CMake can take advantage of. One is support for class browsing. Typically in CMake, only source files are added to a target, not header files. If you add header files to a target, they will show up in the workspace and then you will be able to browse them as usual. Visual Studio also supports the notion of groups of files. By default, CMake creates groups for source files and header files. Using the [`source_group`](https://cmake.org/cmake/help/latest/command/source_group.html#command:source_group "(in CMake v3.30.3)") command, you can create your own groups and assign files to them. 
> CMake 一般仅需要将源文件加入到 target，不需要头文件，但如果我们添加了头文件，VS 的 workspace 中将出现这些头文件
> VS 支持文件组的概念，CMake 默认会为源文件和头文件创建组

If you have any custom build steps in your workspace, these can be added to your CMakeLists files using the [`add_custom_command`](https://cmake. org/cmake/help/latest/command/add_custom_command. html#command: add_custom_command " (in CMake v3.30.3)") command. Custom targets (Utility Targets) in Visual Studio can be added with the [`add_custom_target`](https://cmake. org/cmake/help/latest/command/add_custom_target. html#command: add_custom_target " (in CMake v3.30.3)") command.
# 11 Cross Compiling With CMake
Cross-compiling a piece of software means that the software is built on one system, but is intended to run on a different system. The system used to build the software will be called the “build host,” and the system for which the software is built will be called the “target system” or “target platform.” The target system usually runs a different operating system (or none at all) and/or runs on different hardware. A typical use case is in software development for embedded devices like network switches, mobile phones, or engine control units. In these cases, the target platform doesn’t have or is not able to run the required software development environment.
> 跨编译即在一个系统(build host)构建在另一个系统(target system/platform)运行的程序
> target system 一般 OS 不同(或者没有 OS)，硬件也不同
> 常见的例子是为嵌入式设备开发软件，此时 target platform 不存在需要的软件开发环境

Cross-compiling is fully supported by CMake, ranging from cross-compiling from Linux to Windows; cross-compiling for supercomputers, through to cross-compiling for small embedded devices without an operating system (OS).

Cross-compiling has several consequences for CMake:
- CMake cannot automatically detect the target platform.
- CMake cannot find libraries and headers in the default system directories.
- Executables built during cross compiling cannot be executed.

Cross-compiling support doesn’t mean that all CMake-based projects can be magically cross-compiled out-of-the-box (some are), but that CMake separates between information about the build platform and target platform and gives the user mechanisms to solve cross-compiling issues without additional requirements such as running virtual machines, etc.
> CMake 帮助分离构建平台和目标平台的信息，提供用于解决跨编译问题机制

To support cross-compiling for a specific software project, CMake must to be told about the target platform via a toolchain file. The CMakeLists.txt may have to be adjusted. It is aware that the build platform may have different properties than the target platform, and it has to deal with the instances where a compiled executable tries to execute on the build host.
## 11.1 Toolchain Files
In order to use CMake for cross-compiling, a CMake file that describes the target platform has to be created, called the “toolchain file,” This file tells CMake everything it needs to know about the target platform. Here is an example that uses the MinGW cross-compiler for Windows under Linux; the contents will be explained line-by-line afterwards.
> 需要先创建描述目标平台的 CMake 文件，即工具链文件
```cmake
# the name of the target operating system
set(CMAKE_SYSTEM_NAME Windows)

# which compilers to use for C and C++
set(CMAKE_C_COMPILER   i586-mingw32msvc-gcc)
set(CMAKE_CXX_COMPILER i586-mingw32msvc-g++)

# where is the target environment located
set(CMAKE_FIND_ROOT_PATH  /usr/i586-mingw32msvc
    /home/alex/mingw-install)

# adjust the default behavior of the FIND_XXX() commands:
# search programs in the host environment
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)

# search headers and libraries in the target environment
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
```

Assuming that this file is saved with the name TC-mingw.cmake in your home directory, you instruct CMake to use this file by setting the [`CMAKE_TOOLCHAIN_FILE`](https://cmake.org/cmake/help/latest/variable/CMAKE_TOOLCHAIN_FILE.html#variable: CMAKE_TOOLCHAIN_FILE "(in CMake v3.30.3)") variable:
> 设定 `CMAKE_TOOLCHAIN_FILE` 指向工具链文件
```
~/src$ cd build
~/src/build$ cmake -DCMAKE_TOOLCHAIN_FILE=~/TC-mingw.cmake ..
...
```
[`CMAKE_TOOLCHAIN_FILE`](https://cmake.org/cmake/help/latest/variable/CMAKE_TOOLCHAIN_FILE.html#variable: CMAKE_TOOLCHAIN_FILE "(in CMake v3.30.3)") has to be specified only on the initial CMake run; after that, the results are reused from the CMake cache. You don’t need to write a separate toolchain file for every piece of software you want to build. The toolchain files are per target platform; i.e. if you are building several software packages for the same target platform, you only have to write one toolchain file that can be used for all packages.
> `CMAKE_TOOLCHAIN_FILE` 在第一次 CMake 运行后会被存在 CMake 缓存，之后不需要再指定

What do the settings in the toolchain file mean? We will examine them one-by-one. Since CMake cannot guess the target operating system or hardware, you have to set the following CMake variables:
> 工具链文件中需要设置如下变量

[`CMAKE_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html#variable:CMAKE_SYSTEM_NAME "(in CMake v3.30.3)")
    This variable is mandatory; it sets the name of the target system, i.e. to the same value as `CMAKE_SYSTEM_NAME` would have if CMake were run on the target system. Typical examples are “Linux” and “Windows.” It is used for constructing the file names of the platform files like Linux.cmake or Windows-gcc.cmake. If your target is an embedded system without an OS, set `CMAKE_SYSTEM_NAME` to “Generic.” Presetting `CMAKE_SYSTEM_NAME` this way instead of being detected, automatically causes CMake to consider the build a cross-compiling build and the CMake variable [`CMAKE_CROSSCOMPILING`](https://cmake.org/cmake/help/latest/variable/CMAKE_CROSSCOMPILING.html#variable: CMAKE_CROSSCOMPILING "(in CMake v3.30.3)") will be set to TRUE. `CMAKE_CROSSCOMPILING` is the variable that should be tested in CMake files to determine whether the current build is a cross-compiled build or not.
> target 平台名称用于构建平台文件的名称例如 Linux/Windows-gcc. cmake
> 嵌入式平台名称为 Generic

[`CMAKE_SYSTEM_VERSION`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_VERSION.html#variable:CMAKE_SYSTEM_VERSION "(in CMake v3.30.3)")
    Sets the version of your target system.

[`CMAKE_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_PROCESSOR.html#variable:CMAKE_SYSTEM_PROCESSOR "(in CMake v3.30.3)")
    This variable is optional; it sets the processor or hardware name of the target system. It is used in CMake for one purpose, to load the `${CMAKE_SYSTEM_NAME}-COMPILER_ID-${CMAKE_SYSTEM_PROCESSOR}.cmake` file. This file can be used to modify settings such as compiler flags for the target. You should only have to set this variable if you are using a cross-compiler where each target needs special build settings. The value can be chosen freely, so it could be, for example, i386, IntelPXA255, or MyControlBoardRev42.

In CMake code, the `CMAKE_SYSTEM_XXX` variables always describe the target platform. The same is true for the short [`WIN32`](https://cmake.org/cmake/help/latest/variable/WIN32.html#variable: WIN32 "(in CMake v3.30.3)"), [`UNIX`](https://cmake.org/cmake/help/latest/variable/UNIX.html#variable: UNIX "(in CMake v3.30.3)"), [`APPLE`](https://cmake.org/cmake/help/latest/variable/APPLE.html#variable: APPLE "(in CMake v3.30.3)") variables. These variables can be used to test the properties of the target. If it is necessary to test the build host system, there is a corresponding set of variables: [`CMAKE_HOST_SYSTEM`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM.html#variable: CMAKE_HOST_SYSTEM "(in CMake v3.30.3)"), [`CMAKE_HOST_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html#variable: CMAKE_HOST_SYSTEM_NAME "(in CMake v3.30.3)"), [`CMAKE_HOST_SYSTEM_VERSION`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_VERSION.html#variable: CMAKE_HOST_SYSTEM_VERSION "(in CMake v3.30.3)"), [`CMAKE_HOST_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_PROCESSOR.html#variable: CMAKE_HOST_SYSTEM_PROCESSOR "(in CMake v3.30.3)"); and also the short forms: [`CMAKE_HOST_WIN32`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_WIN32.html#variable: CMAKE_HOST_WIN32 "(in CMake v3.30.3)"), [`CMAKE_HOST_UNIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_UNIX.html#variable: CMAKE_HOST_UNIX "(in CMake v3.30.3)") and [`CMAKE_HOST_APPLE`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_APPLE.html#variable: CMAKE_HOST_APPLE "(in CMake v3.30.3)")
> 名称格式为 `CMAKE_SYSTEM_XXX` 变量都用于描述目标平台，并且有简短的对应变量 `WIN32/UNIX/APPLE`
> 名称格式为 `CMAKE_HOST_SYSTEM_XXX` 变量用于描述本地平台，同样有简短的对应变量

Since CMake cannot guess the target system, it cannot guess which compiler it should use. Setting the following variables defines what compilers to use for the target system.

[`CMAKE_C_COMPILER`](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html#variable:CMAKE_%3CLANG%3E_COMPILER "(in CMake v3.30.3)")
    This specifies the C compiler executable as either a full path or just the filename. If it is specified with full path, then this path will be preferred when searching for the C++ compiler and the other tools (binutils, linker, etc.). If the compiler is a GNU cross-compiler with a prefixed name (e.g. “arm-elf-gcc”), CMake will detect this and automatically find the corresponding C++ compiler (i.e. “arm-elf-c++”). The compiler can also be set via the `CC` environment variable. Setting `CMAKE_C_COMPILER` directly in a toolchain file has the advantage that the information about the target system is completely contained in this file, and it does not depend on environment variables.
> 指定 C 编译器的路径
> 该变量的值也可以通过 `CC` 环境变量设置

[`CMAKE_CXX_COMPILER`](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html#variable:CMAKE_%3CLANG%3E_COMPILER "(in CMake v3.30.3)")
    This specifies the C++ compiler executable as either a full path or just the filename. It is handled the same way as `CMAKE_C_COMPILER`. If the toolchain is a GNU toolchain, it should suffice to set only `CMAKE_C_COMPILER`; CMake should find the corresponding C++ compiler automatically. As for `CMAKE_C_COMPILER`, also for C++ the compiler can be set via the `CXX` environment variable.
> 指定 C++编译器的路径，一般设定 `CMAKE_C_COMPILER` 就足够
> 也可以通过 `CXX` 环境变量设置
## 11.2 Finding External Libraries, Programs and Other Files
Most non-trivial projects make use of external libraries or tools. CMake offers the [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)"), [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.30.3)"), [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.30.3)"), [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.30.3)"), and [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.30.3)") commands for this purpose. They search the file system in common places for these files and return the results. [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.30.3)") is a bit different in that it does not actually search itself, but executes `Find<*>.cmake` modules, which in turn call the [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)"), [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.30.3)"), [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.30.3)"), and [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.30.3)") commands.
> `find_XXX` 形式的命令用于寻找外部成分
> 其中 `find_package` 不进行搜索，而是执行 `Find<>.cmake` 模块，模块调用其他的 `find_XXX` 命令

When cross-compiling, these commands become more complicated. For example, when cross-compiling to Windows on a Linux system, getting `` /usr/lib/libjpeg.so` `` as the result of the command [`find_package(JPEG)`](https://cmake.org/cmake/help/latest/command/find_package.html#command: find_package "(in CMake v3.30.3)") would be useless, since this would be the JPEG library for the host system and not the target system. In some cases, you want to find files that are meant for the target platform; in other cases you will want to find files for the build host. The following variables are designed to give you the flexibility to change how the typical find commands in CMake work, so that you can find both build host and target files as necessary.
> 跨编译时，需要利用以下变量指定是在 build host 找文件还是在 target platform 找文件

The toolchain will come with its own set of libraries and headers for the target platform, which are usually installed under a common prefix. It is a good idea to set up a directory where all the software that is built for the target platform will be installed, so that the software packages don’t get mixed up with the libraries that come with the toolchain.
> 工具链会针对目标平台有自己的一系列库和头文件，它们一般有相同的前缀
> 将为目标平台构建的软件包安装在同一目录可以防止和工具链的库混淆

The [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)") command is typically used to find a program that will be executed during the build, so this should still search in the host file system, and not in the environment of the target platform. [`find_library`](https://cmake.org/cmake/help/latest/command/find_library.html#command: find_library "(in CMake v3.30.3)") is normally used to find a library that is then used for linking purposes, so this command should only search in the target environment. For [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.30.3)") and [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.30.3)"), it is not so obvious; in many cases, they are used to search for headers, so by default they should only search in the target environment. The following CMake variables can be set to adjust the behavior of the find commands for cross-compiling.
> `find_program` 通常用于寻找构建时需要被执行的程序，因此应该在 host 文件系统中寻找，因为构建过程是在 host 中
> `find_library` 一般用于寻找用于链接的库，因此应该只在目标环境寻找
> `find_path/file` 在许多情况下一般用于寻找头文件，因此默认应该仅在目标环境寻找
> 以下的变量用于调节 `find` 系列命令在跨编译时的行为

[`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable:CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)")
    This is a list of the directories that contain the target environment. Each of the directories listed here will be prepended to each of the search directories of every find command. Assuming your target environment is installed under `/opt/eldk/ppc_74xx` and your installation for that target platform goes to `~/install-eldk-ppc74xx`, set [`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable: CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)") to these two directories. Then `find_library(JPEG_LIB jpeg)` will search in `/opt/eldk/ppc_74xx/lib`, `/opt/eldk/ppc_74xx/usr/lib`, `~/install-eldk-ppc74xx/lib`, `~/install-eldk-ppc74xx/usr/lib`, and should result in `/opt/eldk/ppc_74xx/usr/lib/libjpeg.so`.

By default, [`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable: CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)") is empty. If set, first the directories prefixed with the path given in [`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable: CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)") will be searched, and then the unprefixed versions of the same directories will be searched.
> 这里列出的目标环境中的目录会被加入到每个 `find` 命令的搜索目录中
> 该变量默认为空
> 设定该变量实际上就是为 `find` 命令设定了一些新的搜索前缀

By setting this variable, you are basically adding a new set of search prefixes to all of the find commands in CMake, but for some find commands you may not want to search the target or host directories. You can control how each find command invocation works by passing in one of the three following options `NO_CMAKE_FIND_ROOT_PATH`, `ONLY_CMAKE_FIND_ROOT_PATH`, or `CMAKE_FIND_ROOT_PATH_BOTH` when you call it. 
> 通过在调用 `find` 类命令时传入 ` NO_CMAKE_FIND_ROOT_PATH `  或 ` ONLY_CMAKE_FIND_ROOT_PATH ` 或 ` CMAKE_FIND_ROOT_PATH_BOTH ` ，可以控制命令在目标平台搜索还是在 host 搜索

You can also control how the find commands work using the following three variables.
> 使用以下三个变量同样可以控制

[`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.html#variable:CMAKE_FIND_ROOT_PATH_MODE_PROGRAM "(in CMake v3.30.3)")
    This sets the default behavior for the [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)") command. It can be set to NEVER, ONLY, or BOTH. When set to NEVER, [`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable: CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)") will not be used for [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)") calls except where it is enabled explicitly. If set to ONLY, only the search directories with the prefixes coming from [`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable: CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)") will be used by [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)"). The default is BOTH, which means that first the prefixed directories and then the unprefixed directories, will be searched.
> `CMAKE_FIND_ROOT_PATH_MODE_PROGRAM` 用于控制 `find_program` 是否搜索 `CMAKE_FIND_ROOT_PATH` 中的目录

In most cases, [`find_program`](https://cmake.org/cmake/help/latest/command/find_program.html#command: find_program "(in CMake v3.30.3)") is used to search for an executable which will then be executed, e.g. using [`execute_process`](https://cmake.org/cmake/help/latest/command/execute_process.html#command: execute_process "(in CMake v3.30.3)") or [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)"). So in most cases an executable from the build host is required, so setting [`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.html#variable: CMAKE_FIND_ROOT_PATH_MODE_PROGRAM "(in CMake v3.30.3)") to NEVER is normally preferred.
> 一般把 `CMAKE_FIND_ROOT_PATH_MODE_PROGRAM` 设定为 NEVER，即只在本地平台寻找可执行脚本

[`CMAKE_FIND_ROOT_PATH_MODE_LIBRARY`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.html#variable:CMAKE_FIND_ROOT_PATH_MODE_LIBRARY "(in CMake v3.30.3)")
    This is the same as above, but for the [`find_library`](https://cmake. org/cmake/help/latest/command/find_library. html#command: find_library " (in CMake v3.30.3)") command. In most cases this is used to find a library which will then be used for linking, so a library for the target is required. In most cases, it should be set to ONLY.
> 用于控制 `find_library` 对于 `CMAKE_FIND_ROOT_PATH` 是否使用，因为一般会在目标平台寻找库，因此应该设定为 ONLY

[`CMAKE_FIND_ROOT_PATH_MODE_INCLUDE`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.html#variable:CMAKE_FIND_ROOT_PATH_MODE_INCLUDE "(in CMake v3.30.3)")
    This is the same as above and used for both [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.30.3)") and [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.30.3)"). In most cases, this is used for finding include directories, so the target environment should be searched. In most cases, it should be set to ONLY. If you also need to find files in the file system of the build host (e.g. some data files that will be processed during the build); you may need to adjust the behavior for those [`find_path`](https://cmake.org/cmake/help/latest/command/find_path.html#command: find_path "(in CMake v3.30.3)") or [`find_file`](https://cmake.org/cmake/help/latest/command/find_file.html#command: find_file "(in CMake v3.30.3)") calls using the `NO_CMAKE_FIND_ROOT_PATH`, `ONLY_CMAKE_FIND_ROOT_PATH` and `CMAKE_FIND_ROOT_PATH_BOTH` options.
> 用于控制 `find_path/file` ，一般用于寻找 include 目录，所以会设定为 ONLY

With a toolchain file set up as described, CMake now knows how to handle the target platform and the cross-compiler. We should now able to build software for the target platform. For complex projects, there are more issues that must to be taken care of.
## 11.3 System Inspection
> CMake 中最简单检查系统的方式就是查看变量值

Most portable software projects have a set of system inspection tests for determining the properties of the (target) system. The simplest way to check for a system feature with CMake is by testing variables. For this purpose, CMake provides the variables [`UNIX`](https://cmake.org/cmake/help/latest/variable/UNIX.html#variable: UNIX "(in CMake v3.30.3)"), [`WIN32`](https://cmake.org/cmake/help/latest/variable/WIN32.html#variable: WIN32 "(in CMake v3.30.3)"), and [`APPLE`](https://cmake.org/cmake/help/latest/variable/APPLE.html#variable: APPLE "(in CMake v3.30.3)"). When cross-compiling, these variables apply to the target platform, for testing the build host platform there are corresponding variables [`CMAKE_HOST_UNIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_UNIX.html#variable: CMAKE_HOST_UNIX "(in CMake v3.30.3)"), [`CMAKE_HOST_WIN32`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_WIN32.html#variable: CMAKE_HOST_WIN32 "(in CMake v3.30.3)"), and [`CMAKE_HOST_APPLE`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_APPLE.html#variable: CMAKE_HOST_APPLE "(in CMake v3.30.3)").

If this granularity is too coarse, the variables [`CMAKE_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html#variable:CMAKE_SYSTEM_NAME "(in CMake v3.30.3)"), [`CMAKE_SYSTEM`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM.html#variable:CMAKE_SYSTEM "(in CMake v3.30.3)"), [`CMAKE_SYSTEM_VERSION`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_VERSION.html#variable:CMAKE_SYSTEM_VERSION "(in CMake v3.30.3)"), and [`CMAKE_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_PROCESSOR.html#variable:CMAKE_SYSTEM_PROCESSOR "(in CMake v3.30.3)") can be tested, along with their counterparts [`CMAKE_HOST_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html#variable:CMAKE_HOST_SYSTEM_NAME "(in CMake v3.30.3)"), [`CMAKE_HOST_SYSTEM`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM.html#variable:CMAKE_HOST_SYSTEM "(in CMake v3.30.3)"), [`CMAKE_HOST_SYSTEM_VERSION`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_VERSION.html#variable:CMAKE_HOST_SYSTEM_VERSION "(in CMake v3.30.3)"), and [`CMAKE_HOST_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_PROCESSOR.html#variable:CMAKE_HOST_SYSTEM_PROCESSOR "(in CMake v3.30.3)"), which contain the same information, but for the build host and not for the target system.
```cmake
if(CMAKE_SYSTEM MATCHES Windows)
   message(STATUS "Target system is Windows")
endif()

if(CMAKE_HOST_SYSTEM MATCHES Linux)
   message(STATUS "Build host runs Linux")
endif()
```
### 11.3.1 Using Compile Checks
In CMake, there are macros such as [`check_include_files`](https://cmake.org/cmake/help/latest/module/CheckIncludeFiles.html#module: CheckIncludeFiles "(in CMake v3.30.3)") and [`check_c_source_runs`](https://cmake.org/cmake/help/latest/module/CheckCSourceRuns.html#module: CheckCSourceRuns "(in CMake v3.30.3)") that are used to test the properties of the platform. Most of these macros internally use either the [`try_compile`](https://cmake.org/cmake/help/latest/command/try_compile.html#command: try_compile "(in CMake v3.30.3)") or the [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") commands. The [`try_compile`](https://cmake.org/cmake/help/latest/command/try_compile.html#command: try_compile "(in CMake v3.30.3)") command works as expected when cross-compiling; it tries to compile the piece of code with the cross-compiling toolchain, which will give the expected result.
> CMake 提供宏用于测试平台特性，一般它们会和 `try_compile/run` 配合使用

All tests using [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") will not work since the created executables cannot normally run on the build host. In some cases, this might be possible (e.g. using virtual machines, emulation layers like Wine or interfaces to the actual target) as CMake does not depend on such mechanisms. Depending on emulators during the build process would introduce a new set of potential problems; they may have a different view on the file system, use other line endings, require special hardware or software, etc.
> 跨编译时，`try_run` 一般不会有用

If [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") is invoked when cross-compiling, it will first try to compile the software, which will work the same way as when not cross compiling. If this succeeds, it will check the variable [`CMAKE_CROSSCOMPILING`](https://cmake.org/cmake/help/latest/variable/CMAKE_CROSSCOMPILING.html#variable: CMAKE_CROSSCOMPILING "(in CMake v3.30.3)") to determine whether the resulting executable can be executed or not. If it cannot, it will create two cache variables, which then have to be set by the user or via the CMake cache. Assume the command looks like this:
> 在跨编译时调用 `try_run` ，CMake 会编译软件，然后检查变量 `CMAKE_CROSSCOMPILING` 以确定是否可以执行
> 若不行，则创建两个 cache 变量，它们需要之后被用户设置
```cmake
try_run(SHARED_LIBRARY_PATH_TYPE
        SHARED_LIBRARY_PATH_INFO_COMPILED
        ${PROJECT_BINARY_DIR}/CMakeTmp
        ${PROJECT_SOURCE_DIR}/CMake/SharedLibraryPathInfo.cxx
        OUTPUT_VARIABLE OUTPUT
        ARGS "LDPATH"
        )
```
In this example, the source file `SharedLibraryPathInfo.cxx` will be compiled and if that succeeds, the resulting executable should be executed. The variable `SHARED_LIBRARY_PATH_INFO_COMPILED` will be set to the result of the build, i.e. TRUE or FALSE. 
> 变量 `SHARED_LIBRARY_PATH_INFO_COMPILED` 的值会被设定为构建的结果: TRUE or FLASE

CMake will create a cache variable `SHARED_LIBRARY_PATH_TYPE` and preset it to `PLEASE_FILL_OUT-FAILED_TO_RUN`. This variable must be set to what the exit code of the executable would have been if it had been executed on the target. 
> CMake 会创建 cache 变量 `SHARED_LIBRARY_PATH_TYPE` ，该变量需要被设定为 exe 在目标平台执行之后的退出码

Additionally, CMake will create a cache variable `SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT` and preset it to `PLEASE_FILL_OUT-NOTFOUND`. This variable should be set to the output that the executable prints to stdout and stderr if it were executed on the target. 
> CMake 会创建 cache 变量 `SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT` ，该变量需要被设定为 exe 在目标平台执行之后的 stderr or stdout

This variable is only created if the [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") command was used with the `RUN_OUTPUT_VARIABLE` or the `OUTPUT_VARIABLE` argument. You have to fill in the appropriate values for these variables. To help you with this CMake tries its best to give you useful information. To accomplish this CMake creates a file `${CMAKE_BINARY_DIR}/TryRunResults.cmake`, which you can see an example of here:
> 变量的值需要由用户设定，CMake 会创建 `TryRunResults.cmake` 文件提醒用户设定
```cmake
# SHARED_LIBRARY_PATH_TYPE
#   indicates whether the executable would have been able to run
#   on its target platform. If so, set SHARED_LIBRARY_PATH_TYPE
#   to the exit code (in many cases 0 for success), otherwise
#   enter "FAILED_TO_RUN".
# SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT
#   contains the text the executable would have printed on
#   stdout and stderr. If the executable would not have been
#   able to run, set SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT
#   empty. Otherwise check if the output is evaluated by the
#   calling CMake code. If so, check what the source file would
#   have printed when called with the given arguments.
# The SHARED_LIBRARY_PATH_INFO_COMPILED variable holds the build
# result for this TRY_RUN().
#
# Source file: ~/src/SharedLibraryPathInfo.cxx
# Executable : ~/build/cmTryCompileExec-SHARED_LIBRARY_PATH_TYPE
# Run arguments:  LDPATH
#    Called from: [1]   ~/src/CMakeLists.cmake

set(SHARED_LIBRARY_PATH_TYPE
    "0"
    CACHE STRING "Result from TRY_RUN" FORCE)

set(SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT
    ""
    CACHE STRING "Output from TRY_RUN" FORCE)
```
You can find all of the variables that CMake could not determine, from which CMake file they were called, the source file, the arguments for the executable, and the path to the executable. 

CMake will also copy the executables to the build directory; they have the names `cmTryCompileExec-<name of the variable>`, e.g. in this case `cmTryCompileExec-SHARED_LIBRARY_PATH_TYPE`. You can then try to run this executable manually on the actual target platform and check the results.
> CMake 会将 exe 拷贝到构建树，便于我们将这些 exe 放到目标平台执行，得到结果

Once you have these results, they have to be put into the CMake cache. This can be done by using ccmake or cmake-gui. and editing the variables directly in the cache. It is not possible to reuse these changes in another build directory or if CMakeCache.txt is removed.
> 用户要把值写入 CMake cache(CMakeCache. txt)，因此在其他的构建目录无法使用这些值

The recommended approach is to use the `TryRunResults.cmake` file created by CMake. You should copy it to a safe location (i.e. where it will not be removed if the build directory is deleted) and give it a useful name, e.g. TryRunResults-MyProject-eldk-ppc.cmake. The contents of this file have to be edited so that the set commands set the required variables to the appropriate values for the target system. This file can then be used to preload the CMake cache by using the -C option of cmake:
> 推荐使用 `TryRunResults.cmake` 文件来将值写入 cache，即修改文件中 `set` 命令的参数为对应值
> 然后就可以用 `-C` 选项将该文件预加载到 CMake cache 中
```
src/build/ $ cmake -C ~/TryRunResults-MyProject-eldk-ppc.cmake .
```

You do not have to use the other CMake options again as they are now in the cache. This way you can use `MyProjectTryRunResults-eldk-ppc.cmake` in multiple build trees, and it can be distributed with your project so that it is easier for other users to cross compile it.
## 11.4 Running Executables Built in the Project
In some cases it is necessary that during a build, an executable is invoked that was built earlier in the same build; this is usually the case for code generators and similar tools. 
> 在构建时，有时需要调用相同构建中较早的时候的构建的 exe

This does not work when cross compiling, as the executables are built for the target platform and cannot run on the build host (without the use of virtual machines, compatibility layers, emulators, etc.). With CMake, these programs are created using [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)"), and executed with [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") or [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.30.3)"). 
> 在跨编译时则不能实现

The following three options can be used to support these executables with CMake. The old version of the CMake code could look something like this
```cmake
add_executable(mygen gen.c)
get_target_property(mygenLocation mygen LOCATION)
add_custom_command(
  OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/generated.h"
  COMMAND ${mygenLocation}
       -o "${CMAKE_CURRENT_BINARY_DIR}/generated.h" )
```
> 该脚本在构建中使用了同一构建中生成的 exe

Now we will show how this file can be modified so that it works when cross-compiling. The basic idea is that the executable is built only when doing a native build for the build host, and is then exported as an executable target to a CMake script file.  This file is then included when cross-compiling, and the executable target for the executable mygen will be loaded. An imported target with the same name as the original target will be created. [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") recognizes target names as executables, so for the command in [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)"), simply the target name can be used; it is not necessary to use the LOCATION property to obtain the path of the executable:
> 下面介绍跨编译时如何使用该脚本
> 基本思想是该 exe 只会在为 build host 进行本地 build 时才会被构建，然后会被 exported 到一个 CMake script 文件
> 在跨编译时，该文件 CMake script 文件会被 included，然后其中的 exe 目标会被装载，CMake 会创建一个 imported 的目标，名称和 exe 目标相同
> `add_custom_command` 会将该目标识别为可执行文件，因此可以直接在 `add_custom_command` 中使用目标名称，而不需要使用 `LOCATION` 找到其路径之后再引用

```cmake
if(CMAKE_CROSSCOMPILING)
   find_package(MyGen)
else()
   add_executable(mygen gen.c)
   export(TARGETS mygen FILE
          "${CMAKE_BINARY_DIR}/MyGenConfig.cmake")
endif()
```

```cmake
add_custom_command(
  OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/generated.h"
  COMMAND mygen -o "${CMAKE_CURRENT_BINARY_DIR}/generated.h"
  )
```

With the CMakeLists.txt modified like this, the project can be cross-compiled. First, a native build has to be done in order to create the necessary mygen executable. After that, the cross-compiling build can begin. The build directory of the native build has to be given to the cross-compiling build as the location of the MyGen package, so that `find_package(MyGen)` can find it:
> 此时，我们可以先本地构建，创建必要的需要在构建中使用的 exe，然后开始跨编译构建，本地构建的目录作为跨编译构建寻找 MyGen 包的目录
```
mkdir build-native; cd build-native
cmake ..
make
cd ..
mkdir build-cross; cd build-cross
cmake -DCMAKE_TOOLCHAIN_FILE=MyToolchain.cmake \
      -DMyGen_DIR=~/src/build-native/ ..
make
```
## 11.5 Cross-Compiling Hello World
Now let’s actually start with the cross-compiling. The first step is to install a cross-compiling toolchain. If this is already installed, you can skip the next paragraph.
> 跨编译的第一步是安装跨编译工具链

There are many different approaches and projects that deal with cross-compiling for Linux, ranging from free software projects working on Linux-based PDAs to commercial embedded Linux vendors. Most of these projects come with their own way to build and use the respective toolchain. Any of these toolchains can be used with CMake; the only requirement is that it works in the normal file system and does not expect a “sandboxed” environment, like for example the Scratchbox project.

An easy-to-use toolchain with a relatively complete target environment is the Embedded Linux Development Toolkit ([http://www.denx.de/wiki/DULG/ELDK](http://www.denx.de/wiki/DULG/ELDK)). It supports ARM, PowerPC, and MIPS as target platforms. ELDK can be downloaded from [ftp://ftp.sunet.se/pub/Linux/distributions/eldk/](ftp://ftp.sunet.se/pub/Linux/distributions/eldk/). The easiest way is to download the ISOs, mount them, and then install them:
```
mkdir mount-iso/
sudo mount -tiso9660 mips-2007-01-21.iso mount-iso/ -o loop
cd mount-iso/
./install -d /home/alex/eldk-mips/
...
Preparing...           ########################################### [100%]
   1:appWeb-mips_4KCle ########################################### [100%]
Done
ls /opt/eldk-mips/
bin  eldk_init  etc  mips_4KC  mips_4KCle  usr  var  version
```

ELDK (and other toolchains) can be installed anywhere, either in the home directory or system-wide if there are more users working with them. In this example, the toolchain will now be located in /home/alex/eldk-mips/usr/bin/ and the target environment is in /home/alex/eldk-mips/mips_4KC/.

Now that a cross-compiling toolchain is installed, CMake has to be set up to use it. As already described, this is done by creating a toolchain file for CMake. In this example, the toolchain file looks like this:
> CMake 通过创建一个工具链文件来 set up 并且使用工具链
```cmake
# the name of the target operating system
set(CMAKE_SYSTEM_NAME Linux)

# which C and C++ compiler to use
set(CMAKE_C_COMPILER /home/alex/eldk-mips/usr/bin/mips_4KC-gcc)
set(CMAKE_CXX_COMPILER
    /home/alex/eldk-mips/usr/bin/mips_4KC-g++)

# location of the target environment
set(CMAKE_FIND_ROOT_PATH /home/alex/eldk-mips/mips_4KC
                          /home/alex/eldk-mips-extra-install )

# adjust the default behavior of the FIND_XXX() commands:
# search for headers and libraries in the target environment,
# search for programs in the host environment
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
```
The toolchain files can be located anywhere, but it is a good idea to put them in a central place so that they can be reused in multiple projects. We will save this file as ~/Toolchains/Toolchain-eldk-mips4K.cmake. The variables mentioned above are set here: [`CMAKE_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html#variable: CMAKE_SYSTEM_NAME "(in CMake v3.30.3)"), the C/C++ compilers, and [`CMAKE_FIND_ROOT_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html#variable: CMAKE_FIND_ROOT_PATH "(in CMake v3.30.3)") to specify where libraries and headers for the target environment are located. The find modes are also set up so that libraries and headers are searched for in the target environment only, whereas programs are searched for in the host environment only. 
> 工具链文件中设定好了相应的变量，指定了 C/C++ 编译器，指定了目标环境中的库和头文件的位置，并指定了 `find` 的模式


Now we will cross-compile the hello world project from Chapter 2
```cmake
project(Hello)
add_executable(Hello Hello.c)
```

Run CMake, this time telling it to use the toolchain file from above:
```
mkdir Hello-eldk-mips
cd Hello-eldk-mips
cmake -DCMAKE_TOOLCHAIN_FILE=~/Toolchains/Toolchain-eldk-mips4K.cmake ..
make VERBOSE=1
```
This should give you an executable that can run on the target platform. Thanks to the `VERBOSE=1` option, you should see that the cross-compiler is used. 

Now we will make the example a bit more sophisticated by adding system inspection and install rules. We will build and install a shared library named Tools, and then build the Hello application which links to the Tools library.
> 考虑首先构建并且安装一个名为 Tools 的共享库，然后构建链接到该库的 Hello 程序
```cmake
include(CheckIncludeFiles)
check_include_files(stdio.h HAVE_STDIO_H)

set(VERSION_MAJOR 2)
set(VERSION_MINOR 6)
set(VERSION_PATCH 0)

configure_file(config.h.in ${CMAKE_BINARY_DIR}/config.h)

add_library(Tools SHARED tools.cxx)
set_target_properties(Tools PROPERTIES
    VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}
    SOVERSION ${VERSION_MAJOR})

install(FILES tools.h DESTINATION include)
install(TARGETS Tools DESTINATION lib)
```
There is no difference in a normal CMakeLists.txt; no special prerequisites are required for cross-compiling. The CMakeLists.txt checks that the header stdio.h is available and sets the version number for the Tools library. These are configured into config.h, which is then used in tools.cxx. The version number is also used to set the version number of the Tools library. 
> CMakeLists. txt 设定了 Tools 库的版本，检查了 `stdio.h` 是否存在，然后将其配置入了 `config.h` 

The library and headers are installed to ${[`CMAKE_INSTALL_PREFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html#variable: CMAKE_INSTALL_PREFIX "(in CMake v3.30.3)")}/lib and ${`CMAKE_INSTALL_PREFIX`}/include respectively. Running CMake gives this result:
```
mkdir build-eldk-mips
cd build-eldk-mips
cmake -DCMAKE_TOOLCHAIN_FILE=~/Toolchains/Toolchain-eldk-mips4K.cmake \
      -DCMAKE_INSTALL_PREFIX=~/eldk-mips-extra-install ..
-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Check for working C compiler: /home/alex/eldk-mips/usr/bin/mips_4KC-gcc
-- Check for working C compiler:
   /home/alex/eldk-mips/usr/bin/mips_4KC-gcc -- works
-- Check size of void*
-- Check size of void* - done
-- Check for working CXX compiler: /home/alex/eldk-mips/usr/bin/mips_4KC-g++
-- Check for working CXX compiler:
   /home/alex/eldk-mips/usr/bin/mips_4KC-g++ -- works
-- Looking for include files HAVE_STDIO_H
-- Looking for include files HAVE_STDIO_H - found
-- Configuring done
-- Generating done
-- Build files have been written to: /home/alex/src/tests/Tools/build-mips
make install
Scanning dependencies of target Tools
[100%] Building CXX object CMakeFiles/Tools.dir/tools.o
Linking CXX shared library libTools.so
[100%] Built target Tools
Install the project...
-- Install configuration: ""
-- Installing /home/alex/eldk-mips-extra-install/include/tools.h
-- Installing /home/alex/eldk-mips-extra-install/lib/libTools.so
```
As can be seen in the output above, CMake detected the correct compiler, found the stdio.h header for the target platform, and successfully generated the Makefiles. The make command was invoked, which then successfully built and installed the library in the specified installation directory. 
> 运行 CMake，我们成功在目标平台构建了 Tools 库，并安装

Now we can build an executable that uses the Tools library and does some system inspection
```cmake
project(HelloTools)

find_package(ZLIB REQUIRED)

find_library(TOOLS_LIBRARY Tools)
find_path(TOOLS_INCLUDE_DIR tools.h)

if(NOT TOOLS_LIBRARY OR NOT TOOLS_INCLUDE_DIR)
  message FATAL_ERROR "Tools library not found")
endif()

set(CMAKE_INCLUDE_CURRENT_DIR TRUE)
set(CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE TRUE)
include_directories("${TOOLS_INCLUDE_DIR}"
                    "${ZLIB_INCLUDE_DIR}")

add_executable(HelloTools main.cpp)
target_link_libraries(HelloTools ${TOOLS_LIBRARY}
                      ${ZLIB_LIBRARIES})
set_target_properties(HelloTools PROPERTIES
                      INSTALL_RPATH_USE_LINK_PATH TRUE)

install(TARGETS HelloTools DESTINATION bin)
```
Building works in the same way as with the library; the toolchain file has to be used and then it should just work:
```
cmake -DCMAKE_TOOLCHAIN_FILE=~/Toolchains/Toolchain-eldk-mips4K.cmake \
      -DCMAKE_INSTALL_PREFIX=~/eldk-mips-extra-install ..
-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Check for working C compiler: /home/alex/denx-mips/usr/bin/mips_4KC-gcc
-- Check for working C compiler:
   /home/alex/denx-mips/usr/bin/mips_4KC-gcc -- works
-- Check size of void*
-- Check size of void* - done
-- Check for working CXX compiler: /home/alex/denx-mips/usr/bin/mips_4KC-g++
-- Check for working CXX compiler:
   /home/alex/denx-mips/usr/bin/mips_4KC-g++ -- works
-- Found ZLIB: /home/alex/denx-mips/mips_4KC/usr/lib/libz.so
-- Found Tools library: /home/alex/denx-mips-extra-install/lib/libTools.so
-- Configuring done
-- Generating done
-- Build files have been written to:
   /home/alex/src/tests/HelloTools/build-eldk-mips
make
[100%] Building CXX object CMakeFiles/HelloTools.dir/main.o
Linking CXX executable HelloTools
[100%] Built target HelloTools
```

Obviously CMake found the correct zlib and also libTools.so, which had been installed in the previous step.
## 11.6 Cross-Compiling for a Microcontroller
CMake can be used for more than cross-compiling to targets with operating systems, it is also possible to use it in development for deeply-embedded devices with small microcontrollers and no operating system at all.
> 本节考虑为使用小型控制器，没有 OS 的嵌入式设备进行跨编译

As an example, we will use the Small Devices C Compiler ([http://sdcc.sourceforge.net](http://sdcc.sourceforge.net/)), which runs under Windows, Linux, and Mac OS X, and supports 8 and 16 Bit microcontrollers. For driving the build, we will use MS NMake under Windows. 
As before, the first step is to write a toolchain file so that CMake knows about the target platform. For sdcc, it should look something like this
> 第一步是写工具链文件，写明目标平台信息
```cmake
set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_C_COMPILER "c:/Program Files/SDCC/bin/sdcc.exe")
```
The system name for targets that do not have an operating system, “Generic,” should be used as the [`CMAKE_SYSTEM_NAME`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html#variable: CMAKE_SYSTEM_NAME "(in CMake v3.30.3)"). The CMake platform file for “Generic” doesn’t set up any specific features. All that it assumes is that the target platform does not support shared libraries, and so all properties will depend on the compiler and [`CMAKE_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_PROCESSOR.html#variable: CMAKE_SYSTEM_PROCESSOR "(in CMake v3.30.3)"). 
> CMake 对于 Generic 的平台文件会假设它不支持共享库

The toolchain file above does not set the FIND-related variables. As long as none of the find commands is used in the CMake commands, this is fine. In many projects for small microcontrollers, this will be the case. The CMakeLists.txt should look like the following
```cmake
project(Blink C)

add_library(blink blink.c)

add_executable(hello main.c)
target_link_libraries(hello blink)
```
There are no major differences in other CMakeLists.txt files. One important point is that the language “C” is enabled explicitly using the [`project`](https://cmake.org/cmake/help/latest/command/project.html#command:project "(in CMake v3.30.3)") command. If this is not done, CMake will also try to enable support for C++, which will fail as sdcc only has support for C. Running CMake and building the project should work as usual:
> 我们在 `project` 中显式写出了 C，防止 CMake 尝试支持 C++
```
cmake -G"NMake Makefiles" \
      -DCMAKE_TOOLCHAIN_FILE=c:/Toolchains/Toolchain-sdcc.cmake ..
-- The C compiler identification is SDCC
-- Check for working C compiler: c:/program files/sdcc/bin/sdcc.exe
-- Check for working C compiler: c:/program files/sdcc/bin/sdcc.exe -- works
-- Check size of void*
-- Check size of void* - done
-- Configuring done
-- Generating done
-- Build files have been written to: C:/src/tests/blink/build

nmake
Microsoft (R) Program Maintenance Utility Version 7.10.3077
Copyright (C) Microsoft Corporation.  All rights reserved.

Scanning dependencies of target blink
[ 50%] Building C object CMakeFiles/blink.dir/blink.rel
Linking C static library blink.lib
[ 50%] Built target blink
Scanning dependencies of target hello
[100%] Building C object CMakeFiles/hello.dir/main.rel
Linking C executable hello.ihx
[100%] Built target hello
```
This was a simple example using NMake with sdcc with the default settings of sdcc. Of course, more sophisticated project layouts are possible. For this kind of project, it is also a good idea to set up an install directory where reusable libraries can be installed, so it is easier to use them in multiple projects. It is normally necessary to choose the correct target platform for sdcc; not everybody uses i8051, which is the default for sdcc. 

The recommended way to do this is via setting [`CMAKE_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_PROCESSOR.html#variable: CMAKE_SYSTEM_PROCESSOR "(in CMake v3.30.3)").
This will cause CMake to search for and load the platform file `Platform/Generic-SDCC-C-${CMAKE_SYSTEM_PROCESSOR}.cmake`. 

As this happens, right before loading `Platform/Generic-SDCC-C.cmake`, it can be used to set up the compiler and linker flags for the specific target hardware and project. Therefore, a slightly more complex toolchain file is required
> `Platform/Generic-SDCC-C.cmake` 平台文件可以用于设定针对特定平台硬件的编译器和链接器标志
```cmake
get_filename_component(_ownDir
                       "${CMAKE_CURRENT_LIST_FILE}" PATH)
set(CMAKE_MODULE_PATH "${_ownDir}/Modules" ${CMAKE_MODULE_PATH})

set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_C_COMPILER "c:/Program Files/SDCC/bin/sdcc.exe")
set(CMAKE_SYSTEM_PROCESSOR "Test_DS80C400_Rev_1")

# here is the target environment located
set(CMAKE_FIND_ROOT_PATH  "c:/Program Files/SDCC"
                          "c:/ds80c400-install" )

# adjust the default behavior of the FIND_XXX() commands:
# search for headers and libraries in the target environment
# search for programs in the host environment
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
```
This toolchain file contains a few new settings; it is also about the most complicated toolchain file you should ever need. 
[`CMAKE_SYSTEM_PROCESSOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_PROCESSOR.html#variable: CMAKE_SYSTEM_PROCESSOR "(in CMake v3.30.3)") is set to `Test_DS80C400_Rev_1`, an identifier for the specific target hardware. This has the effect that CMake will try to load `Platform/Generic-SDCC-C-Test_DS80C400_Rev_1.cmake`. As this file does not exist in the CMake system module directory, the CMake variable [`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable: CMAKE_MODULE_PATH "(in CMake v3.30.3)") has to be adjusted so that this file can be found.  If this toolchain file is saved to `c:/Toolchains/sdcc-ds400.cmake`, the hardware-specific file should be saved in `c:/Toolchains/Modules/Platform/`.  An example of this is shown below:
> 我们在工具链文件中设定了 `CMAKE_SYSTEM_PROCESSOR` 为目标硬件，这让 CMake 尝试装载平台文件，因为它不在 CMake 系统模块目录里，我们需要调整 `CMAKE_MODULE_PATH` 使得该文件可以被找到
> 平台文件的内容如下所示
```cmake
set(CMAKE_C_FLAGS_INIT "-mds390 --use-accelerator")
set(CMAKE_EXE_LINKER_FLAGS_INIT "")
```
This will select the `DS80C390` as the target platform and add the `–use-accelerator` argument to the default compile flags. 
> 它在默认编译选项中设定了目标平台并且加入了一些参数

In this example the “NMake Makefiles” generator was used. In the same way e.g. the “MinGW Makefiles” generator could be used for a GNU make from MinGW, or another Windows version of GNU make, are available. At least version 3.78 is required, or the “Unix Makefiles” generator under UNIX. Also, any Makefile-based, IDE-project generators could be used; e.g. the Eclipse, CodeBlocks, or the KDevelop3 generator.
## 11.7 Cross-Compiling a Complex Project - VTK
Building a complex project is a multi-step process. Complex in this case means that the project uses tests that run executables, and that it builds executables which are used later in the build to generate code (or something similar). 
> 复杂项目的构建需要多步，复杂的意思是项目运行了用于测试的可执行文件，并且使用了被构建的 exe 来构建

One such project is VTK, which uses several [`try_run`](https://cmake. org/cmake/help/latest/command/try_run. html#command: try_run " (in CMake v3.30.3)") tests and creates several code generators. When running CMake on the project, every [`try_run`](https://cmake. org/cmake/help/latest/command/try_run. html#command: try_run " (in CMake v3.30.3)") command will produce an error message; at the end there will be a `TryRunResults.cmake` file in the build directory. You need to go through all of the entries of this file and fill in the appropriate values. If you are uncertain about the correct result, you can also try to execute the test binaries on the real target platform, where they are saved in the binary directory.

VTK contains several code generators, one of which is ProcessShader. These code generators are added using [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)"); [`get_target_property(LOCATION)`](https://cmake.org/cmake/help/latest/command/get_target_property.html#command: get_target_property "(in CMake v3.30.3)") is used to get the locations of the resulting binaries, which are then used in [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command: add_custom_command "(in CMake v3.30.3)") or [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command: add_custom_target "(in CMake v3.30.3)") commands.
> VTK 包含了不止一个代码生成器，它们使用 `add_executable` 被添加，其结果的二进制文件使用 `get_target_property(LOCATION)` 被定位，以在 `add_custom_command/target` 中被使用

Since the cross-compiled executables cannot be executed during the build, the [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)") calls are surrounded by `if (NOT CMAKE_CROSSCOMPILING)` commands and the executable targets are imported into the project using the [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command: add_executable "(in CMake v3.30.3)") command with the `IMPORTED` option. These import statements are in the file `VTKCompileToolsConfig.cmake`, which does not have to be created manually, but it is created by a native build of VTK.

In order to cross-compile VTK, you need to:
- Install a toolchain and create a toolchain file for CMake.
- Build VTK natively for the build host.
- Run CMake for the target platform.
- Complete `TryRunResults.cmake`.
- Use the `VTKCompileToolsConfig.cmake` file from the native build.
- Build.
> 安装工具链，创建工具链文件
> 本地构建 VTK
> 为目标平台运行 CMake
> 完成文件 `TryRunResults.cmake`
> 使用 `VTKCompileToolsConfig.cmake` 
> 再次构建

So first, build a native VTK for the build host using the standard procedure.

```
cd VTK
mkdir build-native; cd build-native
ccmake ..
make
```
Ensure that all required options are enabled using ccmake; e.g. if you need Python wrapping for the target platform, you must enable Python wrapping in `build-native/`. Once this build has finished, there will be a `VTKCompileToolsConfig.cmake` file in `build-native/`. 
> 首先本地构建让我们得到 `VTKCompileToolsConfig.cmake`

If this succeeded, we can continue to cross compiling the project, in this example for an IBM BlueGene supercomputer.
```
cd VTK
mkdir build-bgl-gcc
cd build-bgl-gcc
cmake -DCMAKE_TOOLCHAIN_FILE=~/Toolchains/Toolchain-BlueGeneL-gcc.cmake \
      -DVTKCompileTools_DIR=~/VTK/build-native/ ..
```
This will finish with an error message for each [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command:try_run "(in CMake v3.30.3)") and a `TryRunResults.cmake file`, that you have to complete as described above. You should save the file to a safe location, or it will be overwritten on the next CMake run.
> 继续跨编译，得到 `TryRunResults.cmake` 文件，我们需要将它们保存以不被下一次 CMake 运行覆盖
```
cp TryRunResults.cmake ../TryRunResults-VTK-BlueGeneL-gcc.cmake
ccmake -C ../TryRunResults-VTK-BlueGeneL-gcc.cmake .
...
make
```

On the second run of ccmake, all the other arguments can be skipped as they are now in the cache. It is possible to point CMake to the build directory that contains a CMakeCache.txt, so CMake will figure out that this is the build directory.
## 11.8 Some Tips and Trick
### 11.8.1 Dealing with try_run tests
In order to make cross compiling your project easier, try to avoid [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") tests and use other methods to test something instead. If you cannot avoid [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") tests, try to use only the exit code from the run and not the output of the process. That way it will not be necessary to set both the exit code and the stdout and stderr variables for the [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") test when cross-compiling. This allows the `OUTPUT_VARIABLE` or the `RUN_OUTPUT_VARIABLE` options for [`try_run`](https://cmake.org/cmake/help/latest/command/try_run.html#command: try_run "(in CMake v3.30.3)") to be omitted.
> 尽量避免 `try_run` 测试


If you have done that, created and completed a correct `TryRunResults.cmake` file for the target platform, you might consider adding this file to the sources of the project, so that it can be reused by others. These files are per-target, per-toolchain.
### 11.8.2 Target platform and toolchain issues
If your toolchain is unable to build a simple program without special arguments, like e.g. a linker script file or a memory layout file, the tests CMake does initially will fail. To make it work the CMake module CMakeForceCompiler offers the following macros:
> 工具链不支持一些常见的参数时，需要修改 CMake 的测试行为，通过以下宏
```
CMAKE_FORCE_SYSTEM(name version processor),
CMAKE_FORCE_C_COMPILER(compiler compiler_id sizeof_void_p)
CMAKE_FORCE_CXX_COMPILER(compiler compiler_id).
```
These macros can be used in a toolchain file so that the required variables will be preset and the CMake tests avoided.

### 11.8.3 RPATH handling under UNIX
For native builds, CMake builds executables and libraries by default with RPATH. In the build tree, the RPATH is set so that the executables can be run from the build tree; i.e. the RPATH points into the build tree. When installing the project, CMake links the executables again, this time with the RPATH for the install tree, which is empty by default.
> CMake 在本地构建默认使用 RPATH
> 构建树中，RPATH 会指向构建树
> 安装项目时，CMake 需要链接可执行文件，此时 RPATH 为空，以让系统在标准的库搜索路径中查找 dll，而不是在特定的安装或构建目录

When cross-compiling you probably want to set up RPATH handling differently. As the executable cannot run on the build host, it makes more sense to build it with the install RPATH right from the start. There are several CMake variables and target properties for adjusting RPATH handling.
```
set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
set(CMAKE_INSTALL_RPATH "<whatever you need>")
```
With these two settings, the targets will be built with the install RPATH instead of the build RPATH, which avoids the need to link them again when installing. If you don’t need RPATH support in your project, you don’t need to set [`CMAKE_INSTALL_RPATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_RPATH.html#variable: CMAKE_INSTALL_RPATH "(in CMake v3.30.3)"); it is empty by default.
> 交叉编译时，最好让构建的目标使用安装 RPATH 而不是构建 RPATH

Setting [`CMAKE_INSTALL_RPATH_USE_LINK_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_RPATH_USE_LINK_PATH.html#variable: CMAKE_INSTALL_RPATH_USE_LINK_PATH "(in CMake v3.30.3)") to `TRUE` is useful for native builds, since it automatically collects the RPATH from all libraries against which a targets links. For cross-compiling it should be left at the default setting of `FALSE`, because on the target the automatically generated RPATH will be wrong in most cases; it will probably have a different file system layout than the build host.
> `CMAKE_INSTALL_RPATH_USE_LINK_PATH` 为 `TRUE` 可以让 CMake 自动从链接的路径中收集 RPATH，但交叉编译时由于运行的平台不同，就应该设定为 FALSE

# 12 Packaging With CPack
CPack is a powerful, easy to use, cross-platform software packaging tool distributed with CMake. It uses the generators concept from CMake to abstract package generation on specific platforms. It can be used with or without CMake, but it may depend on some software being installed on the system. Using a simple configuration file, or using a CMake module, the author of a project can package a complex project into a simple installer. This chapter will describe how to apply CPack to a CMake project.
> CPack 可以脱离 CMake 或者与 CMake 一起使用
> CPack 帮助开发者将项目打包为一个简单的安装程序
## 12.1 CPack Basics
Users of your software may not always want to, or be able to, build the software in order to install it. The software may be closed source, or it may take a long time to compile, or in the case of an end user application, the users may not have the skill or the tools to build the application. For these cases, what is needed is a way to build the software on one machine, and then move the install tree to a different machine. 
> 我们一般需要在一个机器上构建软件，然后能把它移动到另一个机器的安装树上

The most basic way to do this is to use the `DESTDIR` environment variable to install the software into a temporary location, then to tar or zip up that directory and move it to another machine. However, the `DESTDIR` approach falls short on Windows, simply because path names typically start with a drive letter (C:/) and you cannot simply prefix one full path with another and get a valid path name. Another more powerful approach is to use CPack, included in CMake.
> 基础的方式是用 `DESTDIR` 环境变量将软件安装到一个 temp 目录，然后将其 tar zip，然后分发 zip 文件
> 但 Windows 上不能简单给路径加前缀就得到有效的完整路径

CPack is a tool included with CMake, it can be used to create installers and packages for projects. CPack can create two basic types of packages, source and binary. CPack works in much the same way as CMake does for building software. It does not aim to replace native packaging tools, rather it provides a single interface to a variety of tools. Currently CPack supports the creation of Windows installers using NullSoft installer NSIS or WiX, Mac OS X PackageMaker tool, OS X Drag and Drop, OS X X11 Drag and Drop, Cygwin Setup packages, Debian packages, RPMs, .tar.gz, .sh (self extracting .tar.gz files), and .zip compressed files. The implementation of CPack works in a similar way to CMake. For each type of packaging tool supported, there is a CPack generator written in C++ that is used to run the native tool and create the package. For simple tar based packages, CPack includes a library version of tar and does not require tar to be installed on the system. For many of the other installers, native tools must be present for CPack to function.
> CPack 用于为项目创建安装程序和包，它创建源和二进制两种类型的包
> CPack 为多个打包工具提供单一的接口/界面
> CPack 工作方式和 CMake 类似，CPack 为每个它支持的打包工具提供对应的生成器，由生成器运行本地打包工具
> 对于 tar based 的包，CPack 本身就包含了 tar 工具，甚至不需要 tar 被安装在本地系统，而其他工具则需要在本地先安装

With source packages, CPack makes a copy of the source tree and creates a zip or tar file. For binary packages, the use of CPack is tied to the install commands working correctly for a project. When setting up install commands, the first step is to make sure the files go into the correct directory structure with the correct permissions. The next step is to make sure the software is relocatable and can run in an installed tree. This may require changing the software itself, and there are many techniques to do that for different environments that go beyond the scope of this book. Basically, executables should be able to find data or other files using relative paths to the location of where it is installed. CPack installs the software into a temporary directory, and copies the install tree into the format of the native packaging tool. Once the install commands have been added to a project, enabling CPack in the simplest case is done by including the CPack.cmake file into the project.
> 对于源包，CPack 会拷贝源树，然后创建 zip 或 tar 文件
> 对于二进制包，CPack 需要和项目的安装命令配合
> 设定安装命令的第一步为保证文件以正确权限安装到正确目录结构内，第二步为保证软件可以重定位，且可以在安装树中运行，这可能需要软件本身的代码也要写好
> 基本的思考就是可执行文件需要可以利用相对路径和它所安装的位置来找到数据和其他文件
> CPack 对于二进制包的行为是先安装到一个 tmp 目录，然后将安装树 copy into 本地打包工具的格式
> 当项目中有安装命令时，使用 CPack 最简单的方法就是将 CPack. cmake 文件 include 进项目

### 12.1.1 Simple Example
The most basic CPack project would look like this
```cmake
cmake_minimum_required(VERSION 3.20)
project(CoolStuff)
add_executable(coolstuff coolstuff.cxx)
install(TARGETS coolstuff RUNTIME DESTINATION bin)
include(CPack)
```
In the CoolStuff project, an executable is created and installed into the directory bin. Then the CPack file is included by the project. At this point project CoolStuff will have CPack enabled. 

To run CPack for a CoolStuff, you would first build the project as you would any other CMake project. CPack adds several targets to the generated project. These targets in Makefiles are package and package_source, and PACKAGE in Visual Studio and Xcode. For example, to build a source and binary package for CoolStuff using a Makefile generator you would run the following commands:
> 要使用 CPack，首先正常构建，CPack 会为生成的项目添加一些目标，我们只需构建这些目标即可
```
mkdir build
cd build
cmake ../CoolStuff
make
make package
make package_source
```
This would create a source zip file called `CoolStuff-0.1.1-Source.zip`, a NSIS installer called `CoolStuff-0.1.1-win32.exe`, and a binary zip file `CoolStuff-0.1.1-win32.zip`. 

The same thing could be done using the CPack command line.
> 也可以使用 CPack 命令行
```
cd build
cpack --config CPackConfig.cmake
cpack --config CPackSourceConfig.cmake
```
### 12.1.2 What Happens When CPack.cmake Is Included?
When the `include(CPack)` command is executed, the `CPack.cmake` file is included into the project. By default this will use the [`configure_file`](https://cmake.org/cmake/help/latest/command/configure_file.html#command: configure_file "(in CMake v3.30.3)") command to create `CPackConfig.cmake` and `CPackSourceConfig.cmake` in the binary tree of the project. These files contain a series of set commands that set variables for use when CPack is run during the packaging step. The names of the files that are configured by the `CPack.cmake` file can be customized with these two variables; `CPACK_OUTPUT_CONFIG_FILE` which defaults to `CPackConfig.cmake` and `CPACK_SOURCE_OUTPUT_CONFIG_FILE` which defaults to `CPackSourceConfig.cmake`.
> `include(CPack)` 让项目包含了 `CPack.cmake` 文件，`CPack.cmake` 默认会使用 `configure_file` 在二进制树创建 `CPackConfig.cmake` 和 `CPackSourceConfig.cmake` ，它们包含了 CPack 打包时需要运行的命令和需要的变量
> 这两个文件的名称可以通过变量 `CPACK_OUTPUT_CONFIG_FILE` 和 `CPACK_SOURCE_OUTPUT_CONFIG_FILE` 自定义

The source for these files can be found in the `Templates/CPackConfig.cmake.in`. This file contains some comments, and a single variable that is set by `CPack.cmake`. The file contains this line of CMake code:
```
@_CPACK_OTHER_VARIABLES_@
```
If the project contains the file `CPackConfig.cmake.in` in the top level of the source tree, that file will be used instead of the file in the Templates directory. If the project contains the file `CPackSourceConfig.cmake.in`, then that file will be used for the creation of `CPackSourceConfig.cmake`.
> `configure_file` 的输入文件在 `Templates/CPackConfig.cmake.in` 可以找到
> 如果在项目的顶层目录也有这个文件，则CMake 优先使用顶层目录的该文件

The configuration files created by `CPack.cmake` will contain all the variables that begin with “`CPACK_`" in the current project. This is done using the command
```
get_cmake_property(res VARIABLES)
```
The above command gets all variables defined for the current CMake project. Some CMake code then looks for all variables starting with “CPACK_", and each variable found is configured into the two configuration files as CMake code. 
> `CPack.cmake` 创建的 configuratoin 文件将会包含当前项目中所有以 `CPACK_` 开头的变量，即 `CPack.cmake`  会自己寻找项目中前缀为 ` CPACK_ ` 的所有变量，将它们 configure 进 configuration 文件

For example, if you had a variable set like this in your CMake project
```
set(CPACK_PACKAGE_NAME "CoolStuff")
```

`CPackConfig.cmake` and `CPackSourceConfig.cmake` would have the same thing in them:
```
set(CPACK_PACKAGE_NAME "CoolStuff")
```

It is important to keep in mind that CPack is run after CMake on the project. CPack uses the same parser as CMake, but will not have the same variable values as the CMake project. It will only have the variables that start with CPACK_, and these variables will be configured into a configuration file by CMake. 
> 但要注意的是 CPack 是在 CMake 之后运行，CPack 和 CMake 使用相同的分析器，但和 CMake 项目中的变量值可能会有不同
> CPack 只会有以 `CPACK_` 开头的变量，然后使用 CMake 将它们 configure 到 configuration 文件中

This can cause some errors and confusion if the values of the variables use escape characters. Since they are getting parsed twice by the CMake language, they will need double the level of escaping. For example, if you had the following in your CMake project:
> 因为这些以 `CPACK_` 开头的变量会被 CMake 分析两次，因此如果其中有转义字符，需要多添加几层转义 
```
set(CPACK_PACKAGE_VENDOR "Cool \"Company\"")
```

The resulting CPack files would have this:
```
set(CPACK_PACKAGE_VENDOR "Cool "Company"")
```

That would not be exactly what you would want or expect. In fact, it just wouldn’t work. To get around this problem, there are two solutions. The first is to add an additional level of escapes to the original set command like this:

```
set(CPACK_PACKAGE_VENDOR "Cool \\\"Company\\\"")
```

This would result in the correct `set` command which would look like this:
```
set(CPACK_PACKAGE_VENDOR "Cool \"Company\"")
```

The second solution to the escaping problem is to use a CPack project config file, explained in the next section.
### 12.1.3 Adding Custom CPack Options
To avoid the escaping problem, a project specific CPack configure file can be specified. This file will be loaded by CPack after `CPackConfig.cmake` or `CPackSourceConfig.cmake` is loaded, and [`CPACK_GENERATOR`](https://cmake.org/cmake/help/latest/module/CPack.html#variable: CPACK_GENERATOR "(in CMake v3.30.3)") will be set to the CPack generator being run. Variables set in this file only require one level of CMake escapes. 
> 除了多添加几层转义外，也可以使用一个 CPack configure 文件解决该问题
> 该 configure 文件会被 CPack 在 `CPackConfig.cmake` 或 `CPackSourceConfig.cmake` 之后装载，并且它的 `CPACK_GENERATOR` 会被设定为 CPack 正在运行的生成器
> 该 configure 文件中的变量仅需要一层的 CMake 转义

This file can be configured or not, and contains regular CMake code. In the example above, you could move `CPACK_PACKAGE_VENDOR` into a file `MyCPackOptions.cmake.in` and configure that file into the build tree of the project. 
> 对于之前的例子，我们可以将变量 `CPACK_PACKAGE_VENDOR` 移动到 configure 文件 `MyCPackOptions.cmake.in` 中，然后将该文件 configure 到项目的构建树中

Then set the project configuration file path like this:
```cmake
configure_file ("${PROJECT_SOURCE_DIR}/MyCPackOptions.cmake.in"
                "${PROJECT_BINARY_DIR}/MyCPackOptions.cmake"
                @ONLY)
set (CPACK_PROJECT_CONFIG_FILE
     "${PROJECT_BINARY_DIR}/MyCPackOptions.cmake")
```

Where `MyCPackOptions.cmake.in` contained:
```
set(CPACK_PACKAGE_VENDOR "Cool \"Company\"")
```
The [`CPACK_PROJECT_CONFIG_FILE`](https://cmake.org/cmake/help/latest/module/CPack.html#variable: CPACK_PROJECT_CONFIG_FILE "(in CMake v3.30.3)") variable should contain the full path to the CPack config file for the project, as seen in the above example. 
> 然后，我们设定 `CPACK_PROJECT_CONFIG_FILE` 为 `MyPackOptions.cmake` 的路径，注意路径应该是完整路径

This has the added advantage that the CMake code can contain if statements based on the [`CPACK_GENERATOR`](https://cmake.org/cmake/help/latest/module/CPack.html#variable: CPACK_GENERATOR "(in CMake v3.30.3)") value, so that packager specific values can be set for a project. 
> 可以基于 `CPACK_GENERATOR` 的值进行 if 逻辑判断，为项目设定针对 packager 的值

For example, the CMake project sets the icon for the installer in this file:
```
set (CPACK_NSIS_MUI_ICON
     "@CMake_SOURCE_DIR@/Utilities/Release\\CMakeLogo.ico")
```
Note that the path has forward slashes except for the last part which has an escaped as the path separator. As of the writing of this book, NSIS needed the last part of the path to have a Windows style slash. If you do not do this, you may get the following error:
```
File: ".../Release/CMakeLogo.ico" -> no files found.
Usage: File [/nonfatal] [/a] ([/r] [/x filespec [...]]
       filespec [...] | /oname=outfile one_file_only)
```
### 12.1.4 Options Added by CPack
In addition to creating the two configuration files, `CPack.cmake` will add some advanced options to your project. The options added depend on the environment and OS that CMake is running on, and control the default packages that are created by CPack. These options are of the form `CPACK_<CPack Generator Name>`, where generator names available on each platform can be found in the following table:
> `CPack.cmake` 除了会创建两个配置文件，还会为项目添加一些高级选项
> 加入的选项取决于当前运行 CMake 的环境和 OS，这些选项会控制 CPack 创建的默认 packages
> 这些选项的形式是 `CPACK_<CPack Generator Name>`

| Windows    | Cygwin        | Linux/UNIX | Mac OS X     |
| ---------- | ------------- | ---------- | ------------ |
| NSIS       | CYGWIN_BINARY | DEB        | PACKAGEMAKER |
| ZIP        | SOURCE_CYGWIN | RPM        | DRAGNDROP    |
| SOURCE_ZIP |               | STGZ       | BUNDLE       |
|            |               | TBZ2       | OSXX11       |
|            |               | TGZ        |              |
|            |               | TZ         |              |
|            |               | SOURCE_TGZ |              |
|            |               | SOURCE_TZ  |              |

Turning these options on or off affects the packages that are created when running CPack with no options. If the option is off in the CMakeCache.txt file for the project, you can still build that package type by specifying the `-G` option to the CPack command line.
> 在 CPack 命令行中也可以通过 `-G` 指定选项
## 12.2 CPack Source Packages
Source packages in CPack simply copy the entire source tree for a project into a package file, and no install rules are used as they are in the case of binary packages. Out of source builds should be used to avoid having extra binary stuff polluting the source package. 
> CPack 中的源包就是仅仅将项目的整个源树拷贝到一个package 文件中，不会使用任何的安装规则
> 在构建时，需要在源树以外的目录构建，防止污染源树

If you have files or directories in your source tree that are not wanted in the source package, you can use the variable [`CPACK_SOURCE_IGNORE_FILES`](https://cmake.org/cmake/help/latest/module/CPack.html#variable: CPACK_SOURCE_IGNORE_FILES "(in CMake v3.30.3)") to exclude things from the package. This variable contains a list of regular expressions. Any file or directory that matches a regular expression in that list will be excluded from the sources. The default setting is as follows:
> 如果打包时想要排除源树中的一些文件，可以使用 `CPACK_SOURCE_IGNORE_FILES` 变量，该变量包含一个正则表达式列表，用于匹配需要排除的文件或目录
> 默认设定如下
```
"/CVS/;/\\\\\\\\.svn/;\\\\\\\\.swp$;\\\\\\\\.#;/#"
```
There are many levels of escapes used in the default value as this variable is parsed by CMake once and CPack again. 
> `CPACK_SOURCE_IGNORE_FILES` 变量中有太多转义符，因为它会被 CMake 和 CPack 分别解析一遍

It is important to realize that the source tree will not use any install commands, it will simply copy the entire source tree minus the files it is told to ignore into the package. To avoid the multiple levels of escape, the file referenced by [`CPACK_PROJECT_CONFIG_FILE`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_PROJECT_CONFIG_FILE "(in CMake v3.30.3)") should be used to set this variable. The expression is a regular expression and not a wild card statement, see Chapter 4 for more information about CMake regular expressions.
> 注意源树不会用到任意的安装命令，而是简单地将整个源树减去需要去除的文件然后拷贝到 package 中
> 为了避免太多转义，可以利用 `CPACK_PROJECT_CONFIG_FILE` 所指向的文件 ( CPack 会装载的配置文件 ) 来设置 `CPACK_SOURCE_IGNORE_FILES` 的值，要注意该变量的值应该是正则表达式而不是通配符
## 12.3 CPack Installer Commands
Since binary packages require CPack to interact with the install rules of the project being packaged, this section will cover some of the options CPack provides to interact with the install rules of a project. CPack can work with CMake’s install scripts or with external install commands.
> 本节介绍 CPack 打包二进制包时和安装命令的互动
> CPack 可以和 CMake 的安装脚本工作，也可以和外部的安装脚本工作
### 12.3.1 CPack and CMake install commands
In most CMake projects, using the CMake install rules will be sufficient to create the desired package. By default CPack will run the install rule for the current project. 
> 对于多数 CMake 项目，使用 CMake 安装规则就足够打包软件了，CPack 默认就是运行当前项目的安装规则

However, if you have a more complicated project, you can specify sub-projects and install directories with the variable [`CPACK_INSTALL_CMAKE_PROJECTS`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_INSTALL_CMAKE_PROJECTS "(in CMake v3.30.3)"). This variable should hold quadruplets of install directory, install project name, install component, and install subdirectory. 
> 对于复杂的项目，可以用变量 `CPACK_INSTALL_CMAKE_PROJECTS` 指定子项目和安装目录，该变量应该包含安装目录、安装项目名称、安装组件、安装子目录四个值

For example, if you had a project with a sub project called MySub that was compiled into a directory called SubProject, and you wanted to install all of its components, you would have this:
```cmake
SET(CPACK_INSTALL_CMAKE_PROJECTS  "SubProject;MySub;ALL;/")
```
### 12.3.2 CPack and DESTDIR
By default CPack does not use the [`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") option during the installation phase. Instead it sets the [`CMAKE_INSTALL_PREFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html#variable:CMAKE_INSTALL_PREFIX "(in CMake v3.30.3)") to the full path of the temporary directory being used by CPack to stage the install package. 
> CPack 默认在安装时不使用 `DESTDIR` 选项，而是将变量 `CMAKE_INSTALL_PREFIX` 的值设置为 CPack 用于安装 package 的目录的路径

This can be changed by setting [`CPACK_SET_DESTDIR`](https://cmake.org/cmake/help/latest/variable/CPACK_SET_DESTDIR.html#variable:CPACK_SET_DESTDIR "(in CMake v3.30.3)") to on. If the [`CPACK_SET_DESTDIR`](https://cmake.org/cmake/help/latest/variable/CPACK_SET_DESTDIR.html#variable:CPACK_SET_DESTDIR "(in CMake v3.30.3)") option is on, CPack will use the project’s cache value for `CPACK_INSTALL_PREFIX`, and set [`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") to the temporary staging area. This allows absolute paths to be installed under the temporary directory. Relative paths are installed into `DESTDIR/${project's CMAKE_INSTALL_PREFIX}` where [`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") is set to the temporary staging area.
> 要改变这一行为，考虑将变量 `CPACK_SET_DESTDIR` 设定为 True，此时 CPack 不会设定 `CMAKE_INSTALL_PREFIX` ，而是保持该变量的值为项目的 cache 值，并且将 `DESTDIR` 设定为安装目标
> 这样的话可以让 `DESTDIR` 下包含项目的绝对路径，即 `DESTDIR/${project's CMAKE_INSTALL_PREFIX}`

As noted earlier, the [`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") approach does not work when the install rules reference files by Windows full paths beginning with drive letters (C:/).
> 但注意如果安装规则在引用文件时带上了 Windows 的盘符，`DESTDIR` 方法就不会有效

When doing a non-[`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") install for packaging, which is the default, any absolute paths are installed into absolute directories, and not into the package. Therefore, projects that do not use the [`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") option, must not use any absolute paths in install rules. Conversely, projects that use absolute paths, must use the [`DESTDIR`](https://cmake.org/cmake/help/latest/envvar/DESTDIR.html#envvar:DESTDIR "(in CMake v3.30.3)") option.
> 默认情况下，即非 `DESTDIR` 方法下，install 命令中如果提供的是绝对路径，则包就会被安装在绝对路径下
> 因此，默认情况下，项目不使用 `DESTDIR` ，就不要在 install 规则中使用绝对路径，在 install 规则中使用了绝对路径的话，就一定要使用 `DESTDIR`

One other variable can be used to control the root path projects are installed into, the [`CPACK_PACKAGING_INSTALL_PREFIX`](https://cmake.org/cmake/help/latest/variable/CPACK_PACKAGING_INSTALL_PREFIX.html#variable:CPACK_PACKAGING_INSTALL_PREFIX "(in CMake v3.30.3)"). By default many of the generators install into the directory /usr. That variable can be used to change that to any directory, including just /.
> 变量 `CPACK_PACKGING_INSTALL_PREFIX` 指定了项目要安装到的根目录，默认情况下大多数生成器是 /usr
### 12.3.3 CPack and other installed directories
It is possible to run other install rules if the project is not CMake based. This can be done by using the variables [`CPACK_INSTALL_COMMANDS`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_INSTALL_COMMANDS "(in CMake v3.30.3)"), and [`CPACK_INSTALLED_DIRECTORIES`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_INSTALLED_DIRECTORIES "(in CMake v3.30.3)").
> 若项目不基于 CMake，无法运行 CMake 的安装规则，但要使用 CPack，可以考虑使用变量 `CPACK_ISNTALL_COMMANDS` ，`CPACK_ISNTALLED_DIRECTORIES` 

[`CPACK_INSTALL_COMMANDS`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_INSTALL_COMMANDS "(in CMake v3.30.3)") are commands that will be run during the installation phase of the packaging. [`CPACK_INSTALLED_DIRECTORIES`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_INSTALLED_DIRECTORIES "(in CMake v3.30.3)") should contain pairs of directory and subdirectory. The subdirectory can be ‘.’ to be installed in the top-level directory of the installation. The files in each directory will be copied to the corresponding subdirectory of the CPack staging directory and packaged with the rest of the files.
> `CPACK_INSTALL_COMMAND` 指定了安装阶段需要运行的命令
> `CPACK_INSTALL_DIRECTORIES` 指定了安装的源目录和目标目录
## 12.4 CPack for Windows Installer NSIS
To create Windows style wizard based installer programs, CPack uses NSIS (NullSoft Scriptable Install System). More information about NSIS can be found at the NSIS home page: [http://nsis.sourceforge.net/](http://nsis.sourceforge.net/) NSIS is a powerful tool with a scripting language used to create professional Windows installers. To create Windows installers with CPack, you will need NSIS installed on your machine.
> CPack 使用 NSIS 创建 Windows 风格的 installer wizard

CPack uses configured template files to control NSIS. There are two files configured by CPack during the creation of a NSIS installer. Both files are found in the CMake Modules directory. `Modules/NSIS.template.in` is the template for the NSIS script, and `Modules/NSIS.InstallOptions.ini.in` is the template for the modern user interface or MUI used by NSIS. The install options file contains the information about the pages used in the install wizard. This section will describe how to configure CPack to create an NSIS install wizard.
> CPack 使用 configured 的模板文件控制 NSIS，包括两个 `Modlues/NSIS.template.in` , `Modules/NSIS.InstallOptions.ini.in` 
> 本节描述如何配置这两个文件以创建 NSIS install wizard
### 12.4.1 CPack Variables Used by CMake for NSIS
This section contains screen captures from the CMake NSIS install wizard. For each part of the installer that can be changed or controlled from CPack, the variables and values used are given.

The first thing that a user will see of the installer in Windows is the icon for the installer executable itself. By default the installer will have the Null Soft Installer icon, as seen in Figure [1](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-iconforinstallerinwindowsexplorer) for the 20071023 CMake installer. This icon can be changed by setting the variable `CPACK_NSIS_MUI_ICON`. The installer for 20071025 in the same figure shows the CMake icon being used for the installer.
> 安装程序的图标可以通过变量 `CPACK_NSIS_MUI_ICON` 设定

![../_images/IconforinstallerinWindowsExplorer.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/IconforinstallerinWindowsExplorer.png)

**Figure 1: Icon for installer in Windows Explorer**

![../_images/UninstallIconforNSISinstaller.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/UninstallIconforNSISinstaller.png)

**Figure 2: Uninstall Icon for NSIS installer**

The last thing a users will see of the installer in Windows is the icon for the uninstall executable, as seen in Figure [2](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-uninstalliconfornsisinstaller). This option can be set with the `CPACK_NSIS_MUI_UNIICON` variable. Both the install and uninstall icons must be the same size and format, a valid windows .ico file usable by Windows Explorer. 
> 变量 `CPACK_NSIS_MUI_UNICON` 用于设定卸载程序的图标
> installer 和 uninstaller 的图标应该有相同的大小和格式，Windows Explorer 使用 .ico 后缀的文件

The icons are set like this:
```cmake
# set the install/uninstall icon used for the installer itself
set (CPACK_NSIS_MUI_ICON
     "${CMake_SOURCE_DIR}/Utilities/Release\\CMakeLogo.ico")
set (CPACK_NSIS_MUI_UNIICON
     "${CMake_SOURCE_DIR}/Utilities/Release\\CMakeLogo.ico")
```

![../_images/AddorRemoveProgramsEntry.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/AddorRemoveProgramsEntry.png)

**Figure 3: Add or Remove Programs Entry**

On Windows, programs can also be removed using the Add or Remove Programs tool from the control panel as seen in Figure [3](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-addorremoveprogramsentry). The icon for this should be embedded in one of the installed executables. This can be set like this:
> Windows 还支持从控制面板使用 Add or Remove Programs 工具卸载软件，该条目的图标应该是安装的可执行程序其中之一的图标，可以如下设置
```cmake
# set the add/remove programs icon using an installed executable
SET(CPACK_NSIS_INSTALLED_ICON_NAME "bin\\cmake-gui.exe")
```


![../_images/FirstScreenofInstallWizard.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/FirstScreenofInstallWizard.png)

**Figure 4: First Screen of Install Wizard**

When running the installer, the first screen of the wizard will look like Figure [4](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-firstscreenofinstallwizard). In this screen you can control the name of the project that shows up in two places on the screen. The name used for the project is controlled by the variable [`CPACK_PACKAGE_INSTALL_DIRECTORY`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_PACKAGE_INSTALL_DIRECTORY "(in CMake v3.30.3)") or [`CPACK_NSIS_PACKAGE_NAME`](https://cmake.org/cmake/help/latest/cpack_gen/nsis.html#variable:CPACK_NSIS_PACKAGE_NAME "(in CMake v3.30.3)"). In this example, it was set to “CMake 2.5” like this:
> Install Wizard 的第一页中，项目的名称通过 `CPACK_PACKAGE_INSTALL_DIRECTORY` 或 `CPACK_NSIS_PACKAGE_NAME` 设定
```cmake
set (CPACK_PACKAGE_INSTALL_DIRECTORY "CMake
     ${CMake_VERSION_MAJOR}.${CMake_VERSION_MINOR}")

or this:

set (CPACK_NSIS_PACKAGE_NAME "CMake
     ${CMake_VERSION_MAJOR}.${CMake_VERSION_MINOR}")
```

![../_images/SecondScreenofInstallWizard.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/SecondScreenofInstallWizard.png)

**Figure 5: Second Screen of Install Wizard**

The second page of the install wizard can be seen in Figure [5](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-secondscreenofinstallwizard). This screen contains the license agreement and there are several things that can be configured on this page. The banner bitmap to the left of the “License Agreement” label is controlled by the variable `CPACK_PACKAGE_ICON` like this:
> 第二页包含了许可证，其中的 banner 位图通过变量 `CPACK_PACKAGE_ICON` 控制
```cmake
set (CPACK_PACKAGE_ICON
     "${CMake_SOURCE_DIR}/Utilities/Release\\CMakeInstall.bmp")
```
[`CPACK_PACKAGE_INSTALL_DIRECTORY`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_PACKAGE_INSTALL_DIRECTORY "(in CMake v3.30.3)") is used again on this page everywhere you see the text “CMake 2.5”. 

The text of the license agreement is set to the contents of the file specified in the [`CPACK_RESOURCE_FILE_LICENSE`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_RESOURCE_FILE_LICENSE "(in CMake v3.30.3)") variable. CMake does the following:
> 许可证的文本通过 `CPACK_RESOURCE_FILE_LICENSE` 指定
```cmake
set (CPACK_RESOURCE_FILE_LICENSE
     "${CMAKE_CURRENT_SOURCE_DIR}/Copyright.txt")
```

![../_images/Thirdpageofinstallerwizard.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/Thirdpageofinstallerwizard.png)

**Figure 6: Third page of installer wizard**

The third page of the installer can be seen in Figure [6](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-thirdpageofinstallerwizard). This page will only show up if [`CPACK_NSIS_MODIFY_PATH`](https://cmake.org/cmake/help/latest/cpack_gen/nsis.html#variable:CPACK_NSIS_MODIFY_PATH "(in CMake v3.30.3)") is set to on. If you check the Create “name” Desktop Icon button, and you put executable names in the variable [`CPACK_CREATE_DESKTOP_LINKS`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_CREATE_DESKTOP_LINKS "(in CMake v3.30.3)"), then a desktop icon for those executables will be created. 
> 如果 `CPACK_NSIS_MODIFY_PATH` 设定为 True，则用户可以修改安装路径
> Create “name” Desktop Icon checkbox 被 check 且变量 `CPACK_CREATE_DESKTOP_LINKS` 的值被设定为可执行文件的名称，则会为这些可执行文件创建桌面图标

For example, to create a desktop icon for the cmake-gui program of CMake, the following is done:
```cmake
set (CPACK_CREATE_DESKTOP_LINKS cmake-gui)
```
Multiple desktop links can be created if your application contains more than one executable. The link will be created to the Start Menu entry, so [`CPACK_PACKAGE_EXECUTABLES`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_PACKAGE_EXECUTABLES "(in CMake v3.30.3)"), which is described later in this section, must also contain the application in order for a desktop link to be created.
> 项目中包含多个 exe 就可以创建多个桌面图标/链接
> 同时这些桌面链接也会被创建到开始菜单，因此要求 `CPACK_PACKAGE_EXECUTABLES` 必须也包含需要创建桌面链接的应用程序

![../_images/Fourthpageofinstallerwizard.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/Fourthpageofinstallerwizard.png)

**Figure 7: Fourth page of installer wizard**

The fourth page of the installer seen in Figure [7](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-fourthpageofinstallerwizard) uses the variable [`CPACK_PACKAGE_INSTALL_DIRECTORY`](https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_PACKAGE_INSTALL_DIRECTORY "(in CMake v3.30.3)") to specify the default destination folder in Program Files. The following CMake code was used to set that default:
> 默认安装路径是 Program Files + `CPACK_PACKAGE_INSTALL_DIRECTORY`
```cmake
set (CPACK_PACKAGE_INSTALL_DIRECTORY "CMake
     ${CMake_VERSION_MAJOR}.${CMake_VERSION_MINOR}")
```
The remaining pages of the installer wizard do not use any additional CPack variables, and are not included in this section. 

Another important option that can be set by the NSIS CPack generator is the registry key used. There are several CPack variables that control the default key used. The key is defined in the `NSIS.template.in` file as follows:
```
!define MUI_STARTMENUPAGE_REGISTRY_KEY
    "Software\@CPACK_PACKAGE_VENDOR@\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@"
```
Where the `CPACK_PACKAGE_VENDOR` value defaults to Kitware, and `CPACK_PACKAGE_INSTALL_REGISTRY_KEY` defaults to `${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION}`

So for CMake 2.5.20071025 the registry key would look like this:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Kitware\CMake 2.5.20071025
```
> NSIS CPack 生成器还可以设定使用的注册表 key，和其关联的变量有 `CPACK_PACKAGE_VENDOR` , `CPACK_PACKAGE_INSTALL_REGISTRY_KEY`
### 12.4.2 Creating Windows Short Cuts in the Start Menu
There are two variables that control the short cuts that are created in the Windows Start menu by NSIS. The variables contain lists of pairs, and must have an even number of elements to work correctly. 
> 两个变量用于控制 NSIS 在 Windows 开始菜单界面创建的快捷方式，变量值为 lists of pairs，并且元素数量需要为偶数

The first is `CPACK_PACKAGE_EXECUTABLES`, it should contain the name of the executable file followed by the name of the shortcut text. For example in the case of CMake, the executable is called cmake-gui, but the shortcut is named “CMake”. CMake does the following to create that shortcut:
> `CPACK_PACKAGE_EXECUTABLES` 的值应该是 exe 文件的名称 + 快捷方式的名称
```cmake
set (CPACK_PACKAGE_EXECUTABLES "cmake-gui" "CMake" )
```

The second is `CPACK_NSIS_MENU_LINKS`. This variable contains arbitrary links into the install tree, or to external web pages. The first of the pair is always the existing source file or location, and the second is the name that will show up in the Start menu. To add a link to the help file for cmake-gui and a link to the CMake web page add the following:
> `CPACK_NSIS_MENU_LINKS` 包含了到安装树或者到外部网络的任意链接
> pair 的第一个值一般是源文件位置，第二个值为开始菜单中要出现的名称
```cmake
set (CPACK_NSIS_MENU_LINKS
     "doc/cmake-${VERSION_MAJOR}.${VERSION_MINOR}/cmake-gui.html"
     "cmake-gui Help" "http://www.cmake.org" "CMake Web Site")
```
### 12.4.3 Advanced NSIS CPack Options
In addition to the variables already discussed, CPack provides a few additional variables that are directly configured into the NSIS script file. These can be used to add NSIS script fragments to the final NSIS script used to create the installer. They are as follows:
> CPack 提供了高级的变量用于配置 NSIS 脚本文件

**CPACK_NSIS_EXTRA_INSTALL_COMMANDS**
    Extra commands used during install.

**CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS**
    Extra commands used during uninstall.

**CPACK_NSIS_CREATE_ICONS_EXTRA**
    Extra NSIS commands in the icon section of the script.

**CPACK_NSIS_DELETE_ICONS_EXTRA**
    Extra NSIS commands in the delete icons section of the script.

When using these variables the NSIS documentation should be referenced, and the author should look at the `NSIS.template.in` file for the exact placement of the variables.
### 12.4.4 Setting File Extension Associations With NSIS
One example of a useful thing that can be done with the extra install commands is to create associations from file extensions to the installed application. For example, if you had an application CoolStuff that could open files with the extension `.cool`, you would set the following extra install and uninstall commands:
> 使用 `CPACK_NSIS_EXTRA_INSTALL_COMMAND` 可以用于将文件拓展名关联到安装的应用程序
> 例如将 `.cool` 拓展名和应用程序 CoolStuff 关联
```cmake
set (CPACK_NSIS_EXTRA_INSTALL_COMMANDS "
     WriteRegStr HKCR '.cool' '' 'CoolFile'
     WriteRegStr HKCR 'CoolFile' '' 'Cool Stuff File'
     WriteRegStr HKCR 'CoolFile\\shell' '' 'open'
     WriteRegStr HKCR 'CoolFile\\DefaultIcon' \\
                      '' '$INSTDIR\\bin\\coolstuff.exe,0'
     WriteRegStr HKCR 'CoolFile\\shell\\open\\command' \\
                      '' '$INSTDIR\\bin\\coolstuff.exe \"%1\"'
     WriteRegStr HKCR \"CoolFile\\shell\\edit' \\
                      '' 'Edit Cool File'
     WriteRegStr HKCR 'CoolFile\\shell\\edit\\command' \\
                      '' '$INSTDIR\\bin\\coolstuff.exe \"%1\"'
     System::Call \\
       'Shell32::SHChangeNotify(i 0x8000000, i 0, i 0, i 0)'
     ")

set (CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS "
     DeleteRegKey HKCR '.cool'
     DeleteRegKey HKCR 'CoolFile'
     ")
```
This creates a Windows file association to all files ending in `.cool`, so that when a user double clicks on a `.cool` file, `coolstuff.exe` is run with the full path to the file as an argument. This also sets up an association for editing the file from the windows right-click menu to the same `coolstuff.exe` program. 
> 该脚本创建了 Windows 文件关联，将以 `.cool` 结尾的文件关联到了
> 当用户双击 `.cool` 文件，`coolstuff.exe` 就会以该文件的完整路径作为参数运行
> 同时，这也为右键点击菜单中的 “编辑/打开” 关联了 `coolstuff.exe` 

The Windows explorer icon for the file is set to the icon found in the `coolstuff.exe` executable. When it is uninstalled, the registry keys are removed. 
> 该文件在 Windows explorer 中的图标会被设定为在 `coolstuff.exe` 中找到的图标
> 当程序卸载时，注册表 key 会被移除

Since the double quotes and Windows path separators must be escaped, it is best to put this code into the `CPACK_PROJECT_CONFIG_FILE` for the project.
> 因为双引号和 Windows 路径分隔符必须要被转义，因此建议将这段代码放在 `CPACK_PROJECT_CONFIG_FILE` 中
```cmake
configure_file(
  ${CoolStuff_SOURCE_DIR}/CoolStuffCPackOptions.cmake.in
  ${CoolStuff_BINARY_DIR}/CoolStuffCPackOptions.cmake @ONLY)

set (CPACK_PROJECT_CONFIG_FILE
  ${CoolStuff_BINARY_DIR}/CoolStuffCPackOptions.cmake)
include (CPack)
```
### 12.4.5 Installing Microsoft Run Time Libraries
Although not strictly an NSIS CPack command, if you are creating applications on Windows with the Microsoft compiler you will most likely want to distribute the run time libraries from Microsoft alongside your project. 
> 若在 Windows 上使用 Microsoft 编译器创建应用时，我们一般会在我们发布的项目中带上 Microsoft 的运行时库

In CMake, all you need to do is the following:
```cmake
include (InstallRequiredSystemLibraries)
```
This will add the compiler run time libraries as install files that will go into the bin directory of your application. 
> `include (InstallRequiredSystemLibraries)` 会将编译器 runtime 库和加入为安装文件，这些 runtime 库会在我们应用的 bin 目录下

If you do not want the libraries to go into the bin directory, you would do this:
```cmake
set (CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP TRUE)
include (InstallRequiredSystemLibraries)
install (PROGRAMS ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS}
        DESTINATION mydir)
```
> 若不希望库被安装在 bin 目录下，可以自己设定

It is important to note that the run time libraries must be right next to the executables of your package in order for Windows to find them. With Visual Studio 2005 and 2008, side by side manifest files are also required to be installed with your application when distributing the run time libraries. If you want to package a debug version of your software you will need to set `CMAKE_INSTALL_DEBUG_LIBRARIES` to ON prior to the include. Be aware, however, that the license terms may prohibit you from re-distributing the debug libraries. Double check the licensing terms for the version of Visual Studio you’re using before deciding to set `CMAKE_INSTALL_DEBUG_LIBRARIES` to ON.
> 注意在 Windows 中，运行时库要和 exe 处在同一目录
> 要打包一个 debug 版本时，注意需要将 `CMAKE_INSTALL_DEBUG_LIBRARIES` 在 include 之前设定为 ON，以让 debug 库也随着应用程序分发
> 要注意重分发 debug 库之前需要确认对应的许可证
### 12.4.6 CPack Component Install Support
By default, CPack’s installers consider all of the files installed by a project as a single, monolithic unit: either the whole set of files is installed, or none of the files are installed. However, with many projects it makes sense for the installation to be subdivided into distinct, user-selectable components. Some users may want to install only the command-line tools for a project, while other users might want the GUI or the header files.
> CPack 的安装程序默认将项目安装的所有文件视为单个整体的单元，安装时要么全部安装，要么都不安装
> 一些项目需要将安装分为多个独立的、用户可选的组件，例如一些用于仅安装命令行，一些用户会安装 GUI 或头文件

This section describes how to configure CPack to generate component-based installers that allow users to select the set of project components that they wish to install. 
> 本节介绍如何配置 CPack 以生成基于组件的安装程序

![../_images/MacandWindowsComponentInstallers.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/MacandWindowsComponentInstallers.png)

**Figure 8: Mac and Windows Component Installers**[](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#id8 "Permalink to this image")

As an example, a simple installer will be created for a library that has three components: a library binary, a sample application, and a C++ header file. When finished the resulting installers for Windows and Mac OS X look like the ones in Figure [8](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-macandwindowscomponentinstallers).
> 我们创建一个具有三个组件的安装程序：二进制库、应用程序、C++头文件

The simple example we will be working with is as follows; it has a library and an executable. CPack commands that have already been covered are used.
```cmake
cmake_minimum_required(VERSION 3.20 FATAL_ERROR)
project(MyLib)

add_library(mylib mylib.cpp)

add_executable(mylibapp mylibapp.cpp)
target_link_libraries(mylibapp mylib)

install(TARGETS mylib ARCHIVE DESTINATION lib)
install(TARGETS mylibapp RUNTIME DESTINATION bin)
install(FILES mylib.h DESTINATION include)
# add CPack to project
set(CPACK_PACKAGE_NAME "MyLib")
set(CPACK_PACKAGE_VENDOR "CMake.org")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY
    "MyLib - CPack Component Installation Example")
set(CPACK_PACKAGE_VERSION "1.0.0")
set(CPACK_PACKAGE_VERSION_MAJOR "1")
set(CPACK_PACKAGE_VERSION_MINOR "0")
set(CPACK_PACKAGE_VERSION_PATCH "0")
set(CPACK_PACKAGE_INSTALL_DIRECTORY "CPack Component Example")

# This must always be after all CPACK\_\* variables are defined
include(CPack)
```
#### 12.4.5.1 Specifying Components
The first step in building a component-based installation is to identify the set of installable components. In this example, three components will be created: the library binary, the application, and the header file. This decision is arbitrary and project-specific, but be sure to identify the components that correspond to units of functionality important to your user, rather than basing the components on the internal structure of your program.
> 构建基于组件的安装的第一步是确定需要安装的组件集合
> 本例中，有三个组件：库二进制文件、app、头文件
> 注意要确保各部分的组件对应于应用的一个单元的功能，而不是按照组件在我们程序中内部的结构来划分

For each of these components, we need to identify which component each of the installed files belong in. For each [`install`](https://cmake.org/cmake/help/latest/command/install.html#command:install "(in CMake v3.30.3)") command in CMakeLists.txt, add an appropriate `COMPONENT` argument stating which component the installed files will be associated with:
> 对于各个组件，我们需要确定安装的各个文件都属于具体哪个组件，然后在 CMakeLists.txt 中添加合适的 `COMPONENT` 参数，表明要安装的文件属于哪个组件
```cmake
install(TARGETS mylib
  ARCHIVE
  DESTINATION lib
  COMPONENT libraries)
install(TARGETS mylibapp
  RUNTIME
  DESTINATION bin
  COMPONENT applications)
install(FILES mylib.h
  DESTINATION include
  COMPONENT headers)
```
Note that the `COMPONENT` argument to the [`install`](https://cmake.org/cmake/help/latest/command/install.html#command:install "(in CMake v3.30.3)") command is not new; it has been a part of CMake’s [`install`](https://cmake.org/cmake/help/latest/command/install.html#command:install "(in CMake v3.30.3)"). If using any of the older installation commands ([`install_targets`](https://cmake.org/cmake/help/latest/command/install_targets.html#command:install_targets "(in CMake v3.30.3)"), [`install_files`](https://cmake.org/cmake/help/latest/command/install_files.html#command:install_files "(in CMake v3.30.3)"), etc.), you will need to convert them to [`install`](https://cmake.org/cmake/help/latest/command/install.html#command:install "(in CMake v3.30.3)") commands in order to use components.

The next step is to notify CPack of the names of all of the components in your project by calling the `cpack_add_component` function for each component of the package:
> 下一步是调用 `cpack_add_component` 让 CPack 知道我们项目中所有组件的名字
```
cpack_add_component(applications)
cpack_add_component(libraries)
cpack_add_component(headers)
```
At this point you can build a component-based installer with CPack that will allow one to independently install the applications, libraries, and headers of MyLib. The Windows and Mac OS X installers will look like the ones shown in Figure [9](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-windowsandmacosxcomponentinstallerfirstpage).

![../_images/WindowsandMacOSXComponentInstallerFirstPage.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/WindowsandMacOSXComponentInstallerFirstPage.png)

**Figure 9: Windows and Mac OS X Component Installer First Page**
#### 12.4.5.2 Naming Components
At this point, you may have noted that the names of the actual components in the installer are not very descriptive: they just say “applications,” “libraries,” or “headers,” as specified in the component names. 
These names can be improved by using the `DISPLAY_NAME` option in the ` cpack_add_component ` function:
> 可以在 `cpack_add_component` 函数中使用 `DISPLAY_NAME` 选项修改组件在安装程序中展示的名称
```
cpack_add_component(applications DISPLAY_NAME
"MyLib Application")
cpack_add_component(libraries DISPLAY_NAME "Libraries")
cpack_add_component(headers DISPLAY_NAME "C++ Headers")
```

Any macro prefixed with `CPACK_COMPONENT_${COMPNAME}`, where `${COMPNAME}` is the uppercase name of a component, is used to set a particular property of that component in the installer. 
> 任意形式为 `CPACK_COMPONENT_${COMPNAME}` 的宏都是用于设定该组件在安装程序中特定性质的宏

Here, we set the `DISPLAY_NAME` property of each of our components so that we get human-readable names. These names will be listed in the selection box rather than the internal component names “applications,” “libraries,” “headers,”

![../_images/WindowsandMacOSXInstallerswithnamedcomponents.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/WindowsandMacOSXInstallerswithnamedcomponents.png)

**Figure 10: Windows and Mac OS X Installers with named components**
#### 12.4.5.3 Adding Component Descriptions
There are several other properties associated with components, including the ability to make a component hidden, required, or disabled by default, that provide additional descriptive information. Of particular note is the `DESCRIPTION` property, which provides some descriptive text for the component. This descriptive text will show up in a separate “description” box in the installer, and will be updated either when the user’s mouse hovers over the name of the corresponding component (Windows), or when the user clicks on a component (Mac OS X). We will add a description for each of our components below:
> `DESCRIPTION` 属性可以用于为组件提供描述
```cmake
 cpack_add_component(applications DISPLAY_NAME "MyLib Application"
  DESCRIPTION
  "An extremely useful application that makes use of MyLib"
  )
cpack_add_component(libraries DISPLAY_NAME "Libraries"
  DESCRIPTION
  "Static libraries used to build programs with MyLib"
  )
cpack_add_component(headers DISPLAY_NAME "C++ Headers"
  DESCRIPTION "C/C++ header files for use with MyLib"
  )
```

Generally, descriptions should provide enough information for the user to make a decision on whether to install the component, but should not themselves be more than a few lines long (the “Description” box in the installers tends to be small). Figure [11](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-componentinstallerswithdescriptions) shows the description display for both the Windows and Mac OS X installers.
> 描述应该为用户提供是否安装组件的足够信息，但不应该太长

![../_images/ComponentInstallerswithdescriptions.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/ComponentInstallerswithdescriptions.png)

**Figure 11: Component Installers with descriptions**
#### 12.4.5.4 Component Interdependencies
With most projects the various components are not completely independent. For example, an application component may depend on the shared libraries in another component to execute properly, such that installing the application component without the corresponding shared libraries would result in an unusable installation. CPack allows you to express the dependencies between components, so that a component will only be installed if all of the other components it depends on are also installed.
> CPack 允许表达组件之间的依赖性，即一个组件只有在所有它依赖的组件被安装时才被安装

To illustrate component dependencies we will place a simple restriction on our component-based installer. Since we do not provide source code in our installer, the C++ header files we distribute can only actually be used if the user also installs the library binary to link their program against. Thus, the “headers” component depends on the availability of the “libraries” component. We can express this notion by setting the `DEPENDS` property for the `HEADERS` component as such:
> 使用 `DEPENDS` 属性表示依赖
```cmake
cpack_add_component(headers DISPLAY_NAME "C++ Headers"
  DESCRIPTION
  "C/C++ header files for use with MyLib"
  DEPENDS libraries
  )
```
The `DEPENDS` property for a component is actually a list, as such a component can depend on several other components. By expressing all of the component dependencies in this manner you can ensure that users will not be able to select an incomplete set of components at installation time.
> `DEPENDS` 依赖可以是一个列表
#### 12.4.5.5 Grouping Components
When the number of components in your project grows large, you may need to provide additional organization for the list of components. To help with this organization, CPack includes the notion of component groups. A component group is simply a way to provide a name for a group of related components. Within the user interface a component group has its own name, and underneath that group are the names of all of the components in that group. Users will have the option to (de-)select the installation of all components in the group with a single click, or expand the group to select individual components.
> CPack 可以为组件分组

We will expand our example by categorizing its three components, “applications,” “libraries,” and “headers,” into “Runtime” and “Development” groups. We can place a component into a group by using the `GROUP` option to the `cpack_add_component` function as follows:
> 使用 `GROUP` 选项
```cmake
 cpack_add_component(applications
  DISPLAY_NAME "MyLib Application"
  DESCRIPTION
   "An extremely useful application that makes use of MyLib"
  GROUP Runtime)
cpack_add_component(libraries
  DISPLAY_NAME "Libraries"
  DESCRIPTION
  "Static libraries used to build programs with MyLib"
  GROUP Development)
cpack_add_component(headers
  DISPLAY_NAME "C++ Headers"
  DESCRIPTION "C/C++ header files for use with MyLib"
  GROUP Development
  DEPENDS libraries
  )
```

Like components, component groups have various properties that can be customized, including the `DISPLAY_NAME` and `DESCRIPTION`. For example, the following code adds an expanded description to the “Development” group:
> 组件的 group 同样可以自定义一些属性
```cmake
cpack_add_component_group(Development
 EXPANDED
 DESCRIPTION
"All of the tools you'll ever need to develop software")
```

Once you have customized the component groups to your liking, rebuild the binary installer to see the new organization: the MyLib application will show up under the new “Runtime” group, while the MyLib library and C++ header will show up under the new “Development” group. One can easily turn on/off all of the components within a group using the installer’s GUI. This can be seen in Figure [12](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-componentgrouping).

![../_images/ComponentGrouping.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/ComponentGrouping.png)

**Figure 12: Component Grouping**
#### 12.4.5.6 Installation Types (NSIS Only)
When a project contains a large number of components, it is common for a Windows installer to provide pre-selected sets of components based on specific user needs. For example, a user wanting to develop software against a library will want one set of components, while an end user might use an entirely different set. CPack supports this notion of pre-selected component sets via installation types. An installation type is simply a set of components. When the user selects an installation type, exactly that set of components is selected. Then the user is permitted to further customize their installation as desired. Currently this is only supported by the NSIS generator.
> CPack 支持根据安装类型提供预先选择好的组件，一个安装类型就是指一组组件，目前仅有 NSIS 生成器支持

For our simple example, we will create two installation types: a “Full” installation type that contains all of the components, and a “Developer” installation type that includes only the libraries and headers. To do this we use the function `cpack_add_install_type` to add the types.
>  `cpack_add_install_type` 用于添加安装类型
```
cpack_add_install_type(Full DISPLAY_NAME "Everything")
cpack_add_install_type(Developer)
```

Next, we set the `INSTALL_TYPES` property of each component to state which installation types will include that component. This is done with the INSTALL_TYPES option to the `cpack_add_component` function.
> 通过 `INSTALL_TYPES` 选项为组件设定安装类型
```
 cpack_add_component(libraries DISPLAY_NAME "Libraries"
  DESCRIPTION
   "Static libraries used to build programs with MyLib"
  GROUP Development
  INSTALL_TYPES Developer Full)
cpack_add_component(applications
  DISPLAY_NAME "MyLib Application"
  DESCRIPTION
   "An extremely useful application that makes use of MyLib"
  GROUP Runtime
  INSTALL_TYPES Full)
cpack_add_component(headers
  DISPLAY_NAME "C++ Headers"
  DESCRIPTION "C/C++ header files for use with MyLib"
  GROUP Development
  DEPENDS libraries
  INSTALL_TYPES Developer Full)
```

Components can be listed under any number of installation types. If you rebuild the Windows installer, the components page will contain a combo box that allows you to select the installation type, and therefore its corresponding set of components as shown in Figure [13](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html#figure-nsisinstallationtypes).

![../_images/NSISInstallationTypes.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/NSISInstallationTypes.png)

**Figure 13: NSIS Installation Types**
#### 12.4.5.7 Variables that control CPack components
The functions `cpack_add_install_type`, `cpack_add_component_group`, and `cpack_add_component` just set `CPACK_` variables. Those variables are described in the following list:
> `cpack_add_install_type` , `cpack_add_component_group` , `cpack_add_component` 实际的作用就是设定了 `CPACK_` 变量，这些变量如下所示

**CPACK_COMPONENTS_ALL**
    This is a list containing the names of all components that should be installed by CPack. The presence of this macro indicates that CPack should build a component-based installer. Files associated with any components not listed here or any installation commands not associated with any component will not be installed.
> 要安装的所有组件列表

**CPACK_COMPONENT_${COMPNAME}\_DISPLAY\_NAME**
    The displayed name of the component ${COMPNAME}, used in graphical installers to display the component name. This value can be any string.

**CPACK_COMPONENT_${COMPNAME}\_DESCRIPTION**
    An extended description of the component ${COMPNAME}, used in graphical installers to give the user additional information about the component. Descriptions can span multiple lines using “\\n” as the line separator.

**CPACK_COMPONENT_${COMPNAME}\_HIDDEN**
    A flag that indicates that this component will be hidden in the graphical installer, and therefore cannot be selected or installed. Only available with NSIS.

**CPACK_COMPONENT_${COMPNAME}\_REQUIRED**
    A flag that indicates that this component is required, and therefore will always be installed. It will be visible in the graphical installer but it cannot be unselected.

**CPACK_COMPONENT_${COMPNAME}\_DISABLED**
    A flag that indicates that this component should be disabled (unselected) by default. The user is free to select this component for installation.

**CPACK_COMPONENT_${COMPNAME}\_DEPENDS**
    Lists the components on which this component depends. If this component is selected, then each of the components listed must also be selected.

**CPACK_COMPONENT_${COMPNAME}\_GROUP**
    Names a component group that this component is a part of. If not provided, the component will be a standalone component, not part of any component group.

**CPACK_COMPONENT_${COMPNAME}\_INSTALL_TYPES**
    Lists the installation types that this component is a part of. When one of these installations types is selected, this component will automatically be selected. Only available with NSIS.

**CPACK_COMPONENT_GROUP_${GROUPNAME}\_DISPLAY_NAME**
    The displayed name of the component group ${GROUPNAME}, used in graphical installers to display the component group name. This value can be any string.

**CPACK_COMPONENT_GROUP_${GROUPNAME}\_DESCRIPTION**
    An extended description of the component group ${GROUPNAME}, used in graphical installers to give the user additional information about the components contained within this group. Descriptions can span multiple lines using “\\n” as the line separator.

**CPACK_COMPONENT_GROUP_${GROUPNAME}\_BOLD_TITLE**
    A flag indicating whether the group title should be in bold. Only available with NSIS.

**CPACK_COMPONENT_GROUP_${GROUPNAME}\_EXPANDED**
    A flag indicating whether the group should start out “expanded”, showing its components. Otherwise only the group name itself will be shown until the user clicks on the group. Only available with NSIS.

**CPACK_INSTALL_TYPE_${INSTNAME}\_DISPLAY_NAME**
    The displayed name of the installation type. This value can be any string.
## 12.5 CPack for Cygwin Setup
pass
## 12.6 CPack for Mac OS X PackageMaker
pass
## 12.7 CPack for Mac OS X Drag and Drop
pass
## 12.8 CPack for Debian Packages
A Debian package `.deb` is simply an “ar” archive. CPack includes the code for the BSD style ar that is required by Debian packages. The Debian packager uses the standard set of CPack variables to initialize a set of Debian specific variables. These can be overridden in the `CPACK_PROJECT_CONFIG_FILE`; the name of the generator is “DEB”. The variables used by the DEB generator are as follows:
> Debian package `.deb` 实际上就是一个归档文件
> Debian packager 会使用 CPack 的一系列变量来初始化一些 Debian 特定的变量

**CPACK_DEBIAN_PACKAGE_NAME**
    defaults to lower case of `CPACK_PACKAGE_NAME`.

**CPACK_DEBIAN_PACKAGE_ARCHITECTURE**
    defaults to `i386`.

**CPACK_DEBIAN_PACKAGE_DEPENDS**
     This must be set to other packages that this package depends on, and if empty a warning is emitted.

**CPACK_DEBIAN_PACKAGE_MAINTAINER**
    defaults to value of `CPACK_PACKAGE_CONTACT`

**CPACK_DEBIAN_PACKAGE_DESCRIPTION**
    defaults to value of `CPACK_PACKAGE_DESCRIPTION_SUMMARY`

**CPACK_DEBIAN_PACKAGE_SECTION**
    defaults to `devl`

**CPACK_DEBIAN_PACKAGE_PRIORITY**
    defaults to `optional`
## 12.9 CPack for RPM
CPack has support for creating Linux RPM files. The name of the generator as set in `CPACK_GENERATOR` is “RPM”. The RPM package capability requires that rpmbuild is installed on the machine and is in PATH. The RPM packager uses the standard set of CPack variables to initialize RPM specific variables. The RPM specific variables are as follows:

**CPACK_RPM_PACKAGE_SUMMARY**
    defaults to value of `CPACK_PACKAGE_DESCRIPTION_SUMMARY`

**CPACK_RPM_PACKAGE_NAME**
    defaults to lower case of `CPACK_PACKAGE_NAME`

**CPACK_RPM_PACKAGE_VERSION**
    defaults to value of `CPACK_PACKAGE_VERSION`.

**CPACK_RPM_PACKAGE_ARCHITECTURE**
    defaults to `i386`

**CPACK_RPM_PACKAGE_RELEASE**
    defaults to `1`. This is the version of the RPM file, not the version of the software being packaged.
> RPM 文件的版本，不是要打包的软件的版本

**CPACK_RPM_PACKAGE_GROUP**
    defaults to `none`.

**CPACK_RPM_PACKAGE_VENDOR**
    defaults to value of `CPACK_PACKAGE_VENDOR`
## 12.10 CPack Files
There are a number of files that are used by CPack that can be useful for learning more about how CPack works and what options you can set. These files can also be used as the starting point for other generators for CPack. These files can mostly be found in the Modules and Templates directories of CMake and typically start with the prefix CPack. 
As of version 2.8.8, you may also refer to `cpack --help-variable-list` and `cpack --help-variable` for the full set of documented `CPACK_*` variables.
# 13 Testing With CMake and CTest
Testing is a key tool for producing and maintaining robust, valid software. This chapter will examine the tools that are part of CMake to support software testing. We will begin with a brief discussion of testing approaches, and then discuss how to add tests to your software project using CMake.
> 本章讨论测试

The tests for a software package may take a number of forms. At the most basic level there are smoke tests, such as one that simply verifies that the software compiles. While this may seem like a simple test, with the wide variety of platforms and configurations available, smoke tests catch more problems than any other type of test. Another form of smoke test is to verify that a test runs without crashing. This can be handy for situations where the developer does not want to spend the time creating more complex tests, but is willing to run some simple tests. Most of the time these simple tests can be small example programs. Running them verifies not only that the build was successful, but that any required shared libraries can be loaded (for projects that use them), and that at least some of the code can be executed without crashing.
> 最基本的对软件包的测试是 smoke 测试，例如仅仅验证软件是可以编译的
> 另一种形式的 smoke 测试是验证程序可以运行不会崩溃
> 大多数情况下，这类简单的测试可以是小的样本程序，运行这些程序不仅验证了构建是成功的，也验证了动态链接库的装载是没有问题的，并且至少部分代码是可以在不崩溃的情况下运行的

Moving beyond basic smoke tests leads to more specific tests such as regression, black-, and white-box testing. Each of these has its strengths. 
> 基础的 smoke 测试之上就是更加具体的测试，例如回归测试、黑盒白盒测试

Regression testing verifies that the results of a test do not change over time or platform. This is very useful when performed frequently, as it provides a quick check that the behavior and results of the software have not changed. When a regression test fails, a quick look at recent code changes can usually identify the culprit. Unfortunately, regression tests typically require more effort to create than other tests.
> 回归测试验证测试的结果不会随着时间或平台而改变，它提供了对于软件的行为和结果是否改变的快速检查
> 若回归测试失败，则需要迅速检查最近的代码修改，判断原因
> 回归测试通常需要更多精力来创建

White- and black-box testing refer to tests written to exercise units of code (at various levels of integration), with and without knowledge of how those units are implemented respectively. White-box testing is designed to stress potential failure points in the code knowing how that code was written, and hence its weaknesses. As with regression testing, this can take a substantial amount of effort to create good tests. Black-box testing typically knows little or nothing about the implementation of the software other than its public API. Black-box testing can provide a lot of code coverage without too much effort in developing the tests. This is especially true for libraries of object oriented software where the APIs are well defined. A black-box test can be written to go through and invoke a number of typical methods on all the classes in the software.
> 白盒黑盒测试指用于在不同的集成等级检查代码单元的测试，分别带有和不带有这些单元是如何实现的知识
> 白盒测试意在了解代码的编写方式，从而了解其弱点，进而找到潜在的故障点
> 白盒测试和回归测试一样需要大量精力创建
> 黑盒测试对于软件的实现了解甚少，甚至一无所知，只知道它的公共 API，黑盒测试可以在不太费力开发测试的情况下提供大量的代码覆盖率，因此该测试非常适合以目标为导向的且良定义了 API 的软件
> 可以编写黑盒测试遍历并调用软件中所有类的典型方法

The final type of testing we will discuss is software standard compliance testing. While the other test types we have discussed are focused on determining if the code works properly, compliance testing tries to determine if the code adheres to the coding standards of the software project. This could be a check to verify that all classes have implemented some key method, or that all functions have a common prefix. The options for this type of test are limitless and there are a number of ways to perform such testing. There are software analysis tools that can be used, or specialized test programs (maybe python scripts etc) could be written. The key point to realize is that the tests do not necessarily have to involve running some part of the software. The tests might run some other tool on the source code itself.
> 软件标准合规性测试是我们将要讨论的最后一种测试类型
> 我们讨论的其他测试类型都集中在确定代码是否正常工作，但合规性测试试图确定代码是否遵守软件项目的编码标准
> 这可以是检查所有类是否实现了某个关键方法，或者所有函数是否有一个共同的前缀
> 这种测试的选项是无限的，执行这种测试的方法也有很多，可以使用软件分析工具，或者编写专门的测试程序比如 Python 脚本等
> 需要意识到的关键点是，这些测试不一定涉及运行软件的某部分，测试可能会在源代码本身上运行一些其他工具

There are a number of reasons why it helps to have testing support integrated into the build process. First, complex software projects may have a number of configuration or platform-dependent options. The build system knows what options can be enabled and can then enable the appropriate tests for those options. For example, the Visualization Toolkit (VTK) includes support for a parallel processing library called MPI. If VTK is built with MPI support then additional tests are enabled that make use of MPI and verify that the MPI-specific code in VTK works as expected. Secondly, the build system knows where the executables will be placed, and it has tools for finding other required executables (such as perl, python etc). The third reason is that with UNIX Makefiles it is common to have a test target in the Makefile so that developers can type make test and have the test(s) run. In order for this to work, the build system must have some knowledge of the testing process.
> 集中测试和构建是有益的
> 其一，复杂的软件有大量配置和依赖于平台的选型，构建系统知道这些信息，包括哪些选项是启用的，因此可以运行相应的测试
> 其二，构建系统知道 exe 的位置，并且可以找到其他要求的 exe
> 其三，Makefiles 一般会有一个 test 目标，make test 即运行 test
## 13.1 How Does CMake Facilitate Testing?
CMake facilitates testing your software through special testing commands and the [`CTest`](https://cmake.org/cmake/help/latest/manual/ctest.1.html#manual:ctest(1) "(in CMake v3.30.3)") executable. First, we will discuss the key testing commands in CMake. To add testing to a CMake-based project, simply [`include(CTest)`](https://cmake.org/cmake/help/latest/command/include.html#command:include "(in CMake v3.30.3)") and use the [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command. 
> CMake 使用 CTest 进行测试
> 首先 `include(CTest)` ，然后使用 `add_test` 添加测试

The [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command has a simple syntax as follows:
```cmake
add_test(NAME TestName COMMAND ExecutableToRun arg1 arg2 ...)
```
The first argument is simply a string name for the test. This is the name that will be displayed by testing programs. The second argument is the executable to run. The executable can be built as part of the project or it can be a standalone executable such as python, perl, etc. The remaining arguments will be passed to the running executable. 
> 要运行的 exe 可以由项目构建，也可以是外部的 exe

A typical example of testing using the [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command would look like this:
```cmake
add_executable(TestInstantiator TestInstantiator.cxx)
target_link_libraries(TestInstantiator vtkCommon)
add_test(NAME TestInstantiator
         COMMAND TestInstantiator)
```
The [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command is typically placed in the CMakeLists file for the directory that has the test in it. 
> 带有  `add_test` 的 CMakeLists 一般放在和测试 exe 同一目录

For large projects, there may be multiple CMakeLists files with [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") commands in them. Once the [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") commands are present in the project, the user can run the tests by invoking the “test” target of Makefile, or the `RUN_TESTS` target of Visual Studio or Xcode. 
> 大型项目可能会有多个 CMakeLists 有 `add_test` 
> `add_test` 会在 Makefile 中添加 test 目标，或者在 VS 中添加 `RUN_TESTS` 目标

An example of running tests on the CMake tests using the Makefile generator on Linux would be:
```
$ make test
Running tests...
Test project
     Start 2: kwsys.testEncode
 1/20 Test  #2: kwsys.testEncode ..........   Passed    0.02 sec
     Start 3: kwsys.testTerminal
 2/20 Test  #3: kwsys.testTerminal ........   Passed    0.02 sec
     Start 4: kwsys.testAutoPtr
 3/20 Test  #4: kwsys.testAutoPtr .........   Passed    0.02 sec
```
## 13.2 Additional Test Properties
By default a test passes if all of the following conditions are true:
- The test executable was found
- The test ran without exception
- The test exited with return code 0
> test 在：test exe 被找到、test 运行没有异常、test 退出的返回码是0 的时候表示测试通过

That said, these behaviors can be modified using the [`set_property`](https://cmake.org/cmake/help/latest/command/set_property.html#command:set_property "(in CMake v3.30.3)") command:
```
set_property(TEST test_name
             PROPERTY prop1 value1 value2 ...)
```
> 可以用 `set_property` 为测试设定其他性质

This command will set additional properties for the specified tests. Example properties are:

[`ENVIRONMENT`](https://cmake.org/cmake/help/latest/prop_test/ENVIRONMENT.html#prop_test:ENVIRONMENT "(in CMake v3.30.3)")
    Specifies environment variables that should be defined for running a test. If set to a list of environment variables and values of the form `MYVAR=value`, those environment variables will be defined while the test is running. The environment is restored to its previous state after the test is done.
> 指定运行 test 需要定义的环境变量，在测试完成后，环境变量会恢复原来的状态

[`LABELS`](https://cmake.org/cmake/help/latest/prop_test/LABELS.html#prop_test:LABELS "(in CMake v3.30.3)")
    Specifies a list of text labels associated with a test. These labels can be used to group tests together based on what they test. For example, you could add a label of MPI to all tests that exercise MPI code.
> 指定 test 关联的文本标签

[`WILL_FAIL`](https://cmake.org/cmake/help/latest/prop_test/WILL_FAIL.html#prop_test:WILL_FAIL "(in CMake v3.30.3)")
    If this option is set to true, then the test will pass if the return code is not 0, and fail if it is. This reverses the third condition of the pass requirements.
> 指定 test 在返回非零表示通过

[`PASS_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/PASS_REGULAR_EXPRESSION.html#prop_test:PASS_REGULAR_EXPRESSION "(in CMake v3.30.3)")
    If this option is specified, then the output of the test is checked against the regular expression provided (a list of regular expressions may be passed in as well). If none of the regular expressions match, then the test will fail. If at least one of them matches, then the test will pass.
> 检查 test 的输出是否匹配正则表达式

[`FAIL_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/FAIL_REGULAR_EXPRESSION.html#prop_test:FAIL_REGULAR_EXPRESSION "(in CMake v3.30.3)")
    If this option is specified, then the output of the test is checked against the regular expression provided (a list of regular expressions may be passed in as well). If none of the regular expressions match, then the test will pass. If at least one of them matches, then the test will fail.

If both [`PASS_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/PASS_REGULAR_EXPRESSION.html#prop_test:PASS_REGULAR_EXPRESSION "(in CMake v3.30.3)") and [`FAIL_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/FAIL_REGULAR_EXPRESSION.html#prop_test:FAIL_REGULAR_EXPRESSION "(in CMake v3.30.3)") are specified, then the [`FAIL_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/FAIL_REGULAR_EXPRESSION.html#prop_test:FAIL_REGULAR_EXPRESSION "(in CMake v3.30.3)") takes precedence. The following example illustrates using the [`PASS_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/PASS_REGULAR_EXPRESSION.html#prop_test:PASS_REGULAR_EXPRESSION "(in CMake v3.30.3)") and [`FAIL_REGULAR_EXPRESSION`](https://cmake.org/cmake/help/latest/prop_test/FAIL_REGULAR_EXPRESSION.html#prop_test:FAIL_REGULAR_EXPRESSION "(in CMake v3.30.3)"):
> `FAIL_REGUAR_EXPRESSION` 优先级高于 `PASS_XXX_XXX`

```cmake
add_test (NAME outputTest COMMAND outputTest)

set (passRegex "^Test passed" "^All ok")
set (failRegex "Error" "Fail")

set_property (TEST outputTest
              PROPERTY PASS_REGULAR_EXPRESSION "${passRegex}")
set_property (TEST outputTest
              PROPERTY FAIL_REGULAR_EXPRESSION "${failRegex}")
```
## 13.3 Testing Using CTest
When you run the tests from your build environment, what really happens is that the build environment runs [`CTest`](https://cmake.org/cmake/help/latest/manual/ctest.1.html#manual:ctest(1) "(in CMake v3.30.3)"). [`CTest`](https://cmake.org/cmake/help/latest/manual/ctest.1.html#manual:ctest(1) "(in CMake v3.30.3)") is an executable that comes with CMake; it handles running the tests for the project. While CTest works well with CMake, you do not have to use CMake in order to use CTest. The main input file for CTest is called `CTestTestfile.cmake`. This file will be created in each directory that was processed by CMake (typically every directory with a CMakeLists file). 
> 构建环境会运行 CTest 来测试
> CTest 可以不和 CMake 一起使用
> CTest 接受 `CTestTestfile.cmake` 作为输入文件，该文件会在 CMake 处理的所有目录被创建 (所有包含 CMakeLists 的目录)

The syntax of `CTestTestfile.cmake` is like the regular CMake syntax, with a subset of the commands available. If CMake is used to generate testing files, they will list any subdirectories that need to be processed as well as any [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") calls. The subdirectories are those that were added by the [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command:add_subdirectory "(in CMake v3.30.3)") commands. CTest can then parse these files to determine what tests to run. 
> 当使用 CMake 生成测试文件时，这些测试文件会列出所有需要处理的子目录以及所有的 `add_test` 调用，其中子目录会通过 `add_subdirectory` 被添加
> CTest 然后就可以解析这些测试文件，然后决定要运行哪些测试

An example of such a file is shown below:
```cmake
# CMake generated Testfile for
# Source directory: C:/CMake
# Build directory: C:/CMakeBin
#
# This file includes the relevant testing commands required
# for testing this directory and lists subdirectories to
# be tested as well.

add_test (SystemInformationNew ...)

add_subdirectory (Source/kwsys)
add_subdirectory (Utilities/cmzlib)
...
```

When CTest parses the `CTestTestfile.cmake` files, it will extract the list of tests from them. These tests will be run, and for each test CTest will display the name of the test and its status. Consider the following sample output:
> CTest 解析 `CTestTestfile.cmake` 时，会从中提取出 the list of tests，这些 tests 就会被运行，并且其中的每个 test 的名称和状态都会被输出
```
$ ctest
Test project C:/CMake-build26
        Start 1: SystemInformationNew
 1/21 Test  #1: SystemInformationNew ......   Passed    5.78 sec
        Start 2: kwsys.testEncode
 2/21 Test  #2: kwsys.testEncode ..........   Passed    0.02 sec
        Start 3: kwsys.testTerminal
 3/21 Test  #3: kwsys.testTerminal ........   Passed    0.00 sec
        Start 4: kwsys.testAutoPtr
 4/21 Test  #4: kwsys.testAutoPtr .........   Passed    0.02 sec
        Start 5: kwsys.testHashSTL
 5/21 Test  #5: kwsys.testHashSTL .........   Passed    0.02 sec
...
100% tests passed, 0 tests failed out of 21
Total Test time (real) =  59.22 sec
```
CTest is run from within your build tree. It will run all the tests found in the current directory as well as any subdirectories listed in the `CTestTestfile.cmake`. For each test that is run CTest will report if the test passed and how long it took to run the test.
> CTest 会在构建树内部运行，它会运行当前目录以及 `CTestTestfile.cmake` 中所有可以找到的测试，并报告状态

The CTest executable includes some handy command line options to make testing a little easier. We will start by looking at the options you would typically use from the command line.
```
-R <regex>            Run tests matching regular expression
-E <regex>            Exclude tests matching regular expression
-L <regex>            Run tests with labels matching the regex
-LE <regex>           Run tests with labels not matching regexp
-C <config>           Choose the configuration to test
-V,--verbose          Enable verbose output from tests.
-N,--show-only        Disable actual execution of tests.
-I [Start,End,Stride,test#,test#|Test file]
                      Run specific tests by range and number.
-H                                        Display a help message
```
The `-R` option is probably the most commonly used. It allows you to specify a regular expression; only the tests with names matching the regular expression will be run.  Using the `-R` option with the name (or part of the name) of a test is a quick way to run a single test.
> `-R` 即仅运行名称匹配正则的 test

 The `-E` option is similar except that it excludes all tests matching the regular expression. 
 > `-E` 则是排除
 
 The `-L` and `-LE` options are similar to `-R` and `-E`, except that they apply to test labels that were set using the [`set_property`](https://cmake.org/cmake/help/latest/command/set_property.html#command:set_property "(in CMake v3.30.3)") command described previously. 
 The `-C` option is mainly for IDE builds where you might have multiple configurations, such as Release and Debug in the same tree. The argument following the `-C` determines which configuration will be tested. 
 > `-C` 决定需要测试的 configuration
 
 The `-V` argument is useful when you are trying to determine why a test is failing. With `-V`, CTest will print out the command line used to run the test, as well as any output from the test itself. The `-V` option can be used with any invocation of CTest to provide more verbose output. 
 The `-N` option is useful if you want to see what tests CTest would run without actually running them.

Running the tests and making sure they all pass before committing any changes to the software is a sure-fire way to improve your software quality and development process. 
> 提高软件质量：在提交任意修改之前运行测试且保证全部通过

Unfortunately, for large projects the number of tests and the time required to run them may be prohibitive. In these situations the `-I` option of CTest can be used. The `-I` option allows you to flexibly specify a subset of the tests to run. For example, the following invocation of CTest will run every seventh test.
> `-I` 指定需要运行的测试子集，对于大型项目有用
```
ctest -I ,,7
```

While this is not as good as running every test, it is better than not running any and it may be a more practical solution for many developers. Note that if the start and end arguments are not specified, as in this example, then they will default to the first and last tests. In another example, assume that you always want to run a few tests plus a subset of the others. In this case you can explicitly add those tests to the end of the arguments for `-I`. For example:
```
ctest -I ,,5,1,2,3,10
```
will run tests 1, 2, 3, and 10, plus every fifth test. You can pass as many test numbers as you want after the stride argument.
## 13.4 Using CTest to Drive Complex Tests
Sometimes to properly test a project you need to actually compile code during the testing phase. There are several reasons for this. First, if test programs are compiled as part of the main project, they can end up taking up a significant amount of the build time. Also, if a test fails to build, the main build should not fail as well. Finally, IDE projects can quickly become too large to load and work with. 
> 有时我们需要在测试阶段编译代码，原因在于 1. 如果测试程序作为主程序的一部分编译，会占用时间 ( 因此在测试阶段编译 ) 2. 如果测试构建失败，主构建也应该失败 ( 因此应该迁移一部分主构建到测试阶段 ) 3. IDE 项目容易变得很大，不易装载 ( 因此测试应该可以在 IDE 项目外分别调用 )

The CTest command supports a group of command line options that allow it to be used as the test executable to run. When used as the test executable, CTest can run CMake, run the compile step, and finally run a compiled test. 
We will now look at the command line options to CTest that support building and running tests.
> CTest 可以作为 test exe 运行，它可以运行 CMake，运行编译步骤，然后运行编译好的测试
```
--build-and-test  src_directory build_directory
Run cmake on the given source directory using the specified build directory.
--test-command        Name of the program to run.
--build-target        Specify a specific target to build.
--build-nocmake       Run the build without running cmake first.
--build-run-dir       Specify directory to run programs from.
--build-two-config    Run cmake twice before the build.
--build-exe-dir       Specify the directory for the executable.
--build-generator     Specify the generator to use.
--build-project       Specify the name of the project to build.
--build-makeprogram   Specify the make program to use.
--build-noclean       Skip the make clean step.
--build-options       Add extra options to the build step.
```

For an example, consider the following [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command taken from the CMakeLists.txt file of CMake itself. It shows how CTest can be used both to compile and run a test.
```
add_test(simple ${CMAKE_CTEST_COMMAND}
   --build-and-test "${CMAKE_SOURCE_DIR}/Tests/Simple"
                    "${CMAKE_BINARY_DIR}/Tests/Simple"
   --build-generator ${CMAKE_GENERATOR}
   --build-makeprogram ${CMAKE_MAKE_PROGRAM}
   --build-project Simple
   --test-command simple)
```
In this example, the [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command is first passed the name of the test, “simple”. After the name of the test, the command to be run is specified. In this case, the test command to be run is CTest. The CTest command is referenced via the [`CMAKE_CTEST_COMMAND`](https://cmake.org/cmake/help/latest/variable/CMAKE_CTEST_COMMAND.html#variable:CMAKE_CTEST_COMMAND "(in CMake v3.30.3)") variable. This variable is always set by CMake to the CTest command that came from the CMake installation used to build the project.
> 本例中，运行的测试命令是 CTest，通过 CTest exe 的命令行选项指定其他测试参数

Next, the source and binary directories are specified. The next options to CTest are the `--build-generator` and `--build-makeprogram` options. These are specified using the CMake variables [`CMAKE_MAKE_PROGRAM`](https://cmake.org/cmake/help/latest/variable/CMAKE_MAKE_PROGRAM.html#variable:CMAKE_MAKE_PROGRAM "(in CMake v3.30.3)") and [`CMAKE_GENERATOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_GENERATOR.html#variable:CMAKE_GENERATOR "(in CMake v3.30.3)"). Both [`CMAKE_MAKE_PROGRAM`](https://cmake.org/cmake/help/latest/variable/CMAKE_MAKE_PROGRAM.html#variable:CMAKE_MAKE_PROGRAM "(in CMake v3.30.3)") and [`CMAKE_GENERATOR`](https://cmake.org/cmake/help/latest/variable/CMAKE_GENERATOR.html#variable:CMAKE_GENERATOR "(in CMake v3.30.3)") are defined by CMake. This is an important step as it makes sure that the same generator is used for building the test as was used for building the project itself. 
> 同时我们指定了源和二进制目录，以及 generator 和 makeprogram ( 和构建项目使用的一致 )
  
The `--build-project` option is passed `Simple`, which corresponds to the [`project`](https://cmake.org/cmake/help/latest/command/project.html#command:project "(in CMake v3.30.3)") command used in the Simple test. The final argument is the `--test-command` which tells CTest the command to run once it gets a successful build, and should be the name of the executable that will be compiled by the test.
## 13.5 Handling a Large Number of Tests
When a large number of tests exist in a single project, it is cumbersome to have individual executables available for each test. That said, the developer of the project should not be required to create tests with complex argument parsing. 
This is why CMake provides a convenience command for creating a test driver program. This command is called [`create_test_sourcelist`](https://cmake.org/cmake/help/latest/command/create_test_sourcelist.html#command:create_test_sourcelist "(in CMake v3.30.3)"). A test driver is a program that links together many small tests into a single executable. This is useful when building static executables with large libraries to shrink the total required size. 
> CMake 提供 `create_test_sourcelist` 作为测试驱动程序，方便处理测试数量较多的情况，测试驱动程序即将多个小测试链接为单个 exe 的程序
> 在构建需要静态链接大的库的多个可执行测试文件时，这样可以减少总的文件的大小

The signature for [`create_test_sourcelist`](https://cmake.org/cmake/help/latest/command/create_test_sourcelist.html#command:create_test_sourcelist "(in CMake v3.30.3)") is as follows:
```cmake
create_test_sourcelist (SourceListName
                        DriverName
                        test1 test2 test3
                        EXTRA_INCLUDE include.h
                        FUNCTION function
                        )
```
The first argument is the variable which will contain the list of source files that must be compiled to make the test executable. The DriverName is the name of the test driver program (e.g. the name of the resulting executable).

The rest of the arguments consist of a list of test source files. Each test source file should have a function in it that has the same name as the file with no extension (`foo.cxx` should have `int foo(argc, argv);`).
> 每个测试源文件中应该有和它文件名相同的函数

The resulting executable will be able to invoke each of the tests by name on the command line. The `EXTRA_INCLUDE` and `FUNCTION` arguments support additional customization of the test driver program. 
> 最后得到的 exe 可以通过名称调用各个测试

Consider the following CMakeLists file fragment to see how this command can be used:
```
# create the testing file and list of tests
set (TestToRun
  ObjectFactory.cxx
  otherArrays.cxx
  otherEmptyCell.cxx
  TestSmartPointer.cxx
  SystemInformation.cxx
  ...
)
create_test_sourcelist (Tests CommonCxxTests.cxx ${TestToRun})

# add the executable
add_executable (CommonCxxTests ${Tests})

# Add all the ADD_TEST for each test
foreach (test ${TestsToRun})
  get_filename_component (TName ${test} NAME_WE)
  add_test (NAME ${TName} COMMAND CommonCxxTests ${TName})
endforeach ()
```
The [`create_test_sourcelist`](https://cmake.org/cmake/help/latest/command/create_test_sourcelist.html#command:create_test_sourcelist "(in CMake v3.30.3)") command is invoked to create a test driver. In this case it creates and writes `CommonCxxTests.cxx` into the binary tree of the project, using the rest of the arguments to determine its contents. 

Next, the [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html#command:add_executable "(in CMake v3.30.3)") command is used to add that executable to the build. Then a new variable called `TestsToRun` is created with an initial value of the sources required for the test driver. 
> 变量 `TestsToRun` 会被创建，初始值是测试驱动程序的源列表

Then, a [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command:foreach "(in CMake v3.30.3)") command is used to loop over the remaining sources. For each source, its name without a file extension is extracted and put in the variable `TName`, then a new test is added for `TName`. 
The end result is that for each source file in the [`create_test_sourcelist`](https://cmake.org/cmake/help/latest/command/create_test_sourcelist.html#command:create_test_sourcelist "(in CMake v3.30.3)") an [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command is called with the name of the test. As more tests are added to the [`create_test_sourcelist`](https://cmake.org/cmake/help/latest/command/create_test_sourcelist.html#command:create_test_sourcelist "(in CMake v3.30.3)") command, the [`foreach`](https://cmake.org/cmake/help/latest/command/foreach.html#command:foreach "(in CMake v3.30.3)") loop will automatically call [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") for each one.
> 为各个测试调用 `add_test`
## 13.6 Managing Test Data
In addition to handling large numbers of tests, CMake contains a system for managing test data. It is encapsulated in an [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") CMake module, downloads large data on an as-needed basis, retains version information, and allows distributed storage.
> CMake 使用 `ExternalData` 模块处理测试数据

The design of the [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") follows that of distributed version control systems using hash-based file identifiers and object stores, but it also takes advantage of the presence of a dependency-based build system. 
> `ExternalData` 使用基于哈希的文件 id 和基于对象的存储

The figure below illustrates the approach. Source trees contain lighweight “content links” referencing data in remote storage by hashes of their content. The [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") module produces build rules to download the data to local stores and reference them from build trees by symbolic links (copies on Windows).

![../_images/ExternalDatamoduleflowchart.png](https://cmake.org/cmake/help/book/mastering-cmake/_images/ExternalDatamoduleflowchart.png)

**Figure 1: ExternalData module flow chart**

A content link is a small, plain text file containing a hash of the real data. Its name is the same as its data file, with an additional extension identifying the hash algorithm e.g. img.png.md5. Content links always take the same (small) amount of space in the source tree regardless of the real data size. The CMakeLists.txt CMake configuration files refer to data using a DATA{} syntax inside calls to the [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") module API. For example, DATA{img.png} tells the [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") module to make img.png available in the build tree even if only a img.png.md5 content link appears in the source tree.
> 内容链接就是对应数据的哈希值，名称和数据文件一致
> CMakeLists 中使用 `DATA{}` 语法引用 `ExternalData` 数据

The [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") module implements a flexible system to prevent duplication of content fetching and storage. Objects are retrieved from a list of (possibly redundant) local and remote locations specified in the [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") CMake configuration as a list of “URL templates”. The only requirement of remote storage systems is the ability to fetch from a URL that locates content through specification of the hash algorithm and hash value. Local or networked file systems, an Apache FTP server or a [Midas](http://www.midasplatform.org/) server , for example, all have this capability. Each URL template has %(algo) and %(hash) placeholders for [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") to replace with values from a content link.
> 对象通过一个 URL template 列表来检索，远端存储系统需要能够通过 URL 取得对应数据，URL template 中的 %(algo) 和 %(hash) 占位符需要被内容链接对应的内容替换

A persistent local object store can cache downloaded content to share among build trees by setting the `ExternalData_OBJECT_STORES` CMake build configuration variable. This is helpful to de-duplicate content for multiple build trees. It also resolves an important pragmatic concern in a regression testing context; when many machines simultaneously start a nightly dashboard build, they can use their local object store instead of overloading the data servers and flooding network traffic.
> 设定 `ExternalData_OBJECT_STORES` 可以在本地缓存下载的内容，以在多个构建树之间共享

Retrieval is integrated with a dependency-based build system, so resources are fetched only when needed. For example, if the system is used to retrieve testing data and `BUILD_TESTING` is OFF, the data are not retrieved unnecessarily. When the source tree is updated and a content link changes, the build system fetches the new data as needed.
> 内容的检索和基于依赖的构建系统是集成的，因此资源之后再需要的时候才会被取得

Since all references leaving the source tree go through hashes, they do not depend on any external state. Remote and local object stores can be relocated without invalidating content links in older versions of the source code. Content links within a source tree can be relocated or renamed without modifying the object stores. Duplicate content links can exist in a source tree, but download will only occur once. Multiple versions of data with the same source tree file name in a project’s history are uniquely identified in the object stores.
> 引用仅使用哈希，不依赖任何外部状态
> 源树中的内容链接可以重定位或重命名，不会影响检索

Hash-based systems allow the use of untrusted connections to remote resources because downloaded content is verified after it is retrieved. Configuration of the URL templates list improves robustness by allowing multiple redundant remote storage resources. Storage resources can also change over time on an as-needed basis. If a project’s remote storage moves over time, a build of older source code versions is always possible by adjusting the URL templates configured for the build tree or by manually populating a local object store.
> 基于哈希的系统允许使用不信任的链接，因为下载的内容会在被检索后被验证，因此 URL 可以按需修改

A simple application of the [`ExternalData`](https://cmake.org/cmake/help/latest/module/ExternalData.html#module:ExternalData "(in CMake v3.30.3)") module looks like the following:
```cmake
include(ExternalData)
set(midas "http://midas.kitware.com/MyProject")

# Add standard remote object stores to user's
# configuration.
list(APPEND ExternalData_URL_TEMPLATES
 "${midas}?algorithm=%(algo)&hash=%(hash)"
 "ftp://myproject.org/files/%(algo)/%(hash)"
 )
# Add a test referencing data.
ExternalData_Add_Test(MyProjectData
 NAME SmoothingTest
 COMMAND SmoothingExe DATA{Input/Image.png}
                    SmoothedImage.png
 )
# Add a build target to populate the real data.
ExternalData_Add_Target(MyProjectData)
```
The `ExternalData_Add_Test` function is a wrapper around CMake’s [`add_test`](https://cmake.org/cmake/help/latest/command/add_test.html#command:add_test "(in CMake v3.30.3)") command. The source tree is probed for a Input/Image.png.md5 content link containing the data’s MD5 hash. After checking the local object store, a request is made sequentially to each URL in the `ExternalData_URL_TEMPLATES` list with the data’s hash. Once found, a symlink is created in the build tree. The DATA{Input/Image.png} path will expand to the build tree path in the test command line. Data are retrieved when the MyProjectData target is built.
# 14 CMake Tutorial