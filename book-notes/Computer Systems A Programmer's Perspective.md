# Part 0
## CH1 A Tour of Computer Systems
### 1.1 Information Is Bits + Context
从 `hello.c` 程序开始：
```c
#include <stdio.h>

int main()
{
	printf("hello, world\n");
	return 0;
}
```

`hello.c` 以文本文件/text files(即仅由ASCII字符构成的文件)的形式存储，我们称其为源程序或源文件
文本文件对于计算机来说，视为一串比特/位流，但它实际是以字节(8比特)为单位组织的

在采用ASCII编码标准的情况下，每个文本字符正好与一个8位二进制数表示的整数值对应，因此源文件虽然以字节流的形式存储，但是通过将每个字节解码成ASCII字符，源文件就可以以人类可读的形式展示

注意源文件中，每个行的后面实际上都有一个newline字符 `\n` ，它的ASCII码值是10
空格(SP)的AICII码值是32

文本文件以外的文件统称为二进制文件/binary files

所有的磁盘文件、内存中的程序、内存中的用户数据、通过网络传输的数据，都可以视为比特流或字节流
但注意，在不同的上下文下，同样的字节流完全可以解码出不同的含义，它们可以代表一个整数、一个浮点数、一个字符串、或是一条机器指令

因为数字在计算机系统中也只能用二进制表示，因此对于一些实数，我们不能在计算机中将其精确表示，只能采用它的有限近似

>***Aside***  _Origins of the C programming language_
>C开发于1969-1973，最早遵循1989年的ANSI C标准，后来由ISO制定标准
>C标准包括了C语言本身以及C标准库(C standard library)
>《K&R》详细写明了ANSI C标准
>C最初为Unix OS开发，Unix几乎全部由C完成
>C是一门小型简洁的语言
>C适合系统层面编程，C缺乏对于类、对象、异常等抽象概念的支持，因此相较于C，C++和Java更适合应用层面的编程

### 1.2 Programs Are Translated by Other Programs into Different Forms
`hello.c` 是人类可读的，但不是机器可读的
它需要被翻译成一系列的低级机器指令
这些机器指令以可执行目标程序/文件的形式被打包在一起
可执行目标程序/文件以二进制磁盘文件的形式被存储

Unix/Linux系统中，从源程序到目标程序的翻译由GCC编译器驱动程序(或简单称为GCC编译器)完成：`linux> gcc -o hello.c hello`

这条指令调用了GCC编译器驱动器，GCC将调用编译系统，包括预处理器，编译器，汇编器，链接器，共4个程序，进行4阶段的处理，最后将源程序`hello.c` 翻译成目标程序 `hello`

编译系统的4个阶段：
- 预处理阶段
	预处理器(cpp)主要处理 `hello.c` 中带 `#` 的预处理语句
	如 `#include<stdio.h>` 告诉了预处理器将系统头文件 `stdio.h` 的所有内容直接插入源文件 `hello.c` 中 `#include<stdio.h>` 的位置，输出一个新的C程序 `hello.i` ，称其为被修改过的源程序(modified source program)，它仍是文本文件
- 编译阶段
	编译器(cc1)将由C语言语句构成的 `hello.i` 翻译成由汇编语言语句构成的 `hello.s` ，输出一个新的汇编程序 `hello.s` (assembly program)，它仍是文本文件
	汇编程序其中的每一句汇编指令都对应了一条低级的机器指令，可以说汇编指令是机器指令的文本表示
	注意不同的高级语言可以被编译成相同的汇编语言，如C和Fortran
- 汇编阶段
	汇编器(as)将 `hello.s` 中的每一条汇编指令翻译成机器指令，将它们打包，输出目标文件 `hello.o` ，称其为可重定位的目标程序(relocatable program)，文件变为了二进制文件(不再由ASCII码编码，直接包含二进制机器指令)
- 链接阶段
	因为 `hello` 程序调用了 `printf` 函数，而该函数定义于C标准库(每个C编译器都会提供完整的C标准库定义)
	也就是说 `printf` 函数的定义在另一个预编译过的目标文件(二进制文件) `printf.o` 中
	因此需要链接器(ld)将 `printf.o` 与 `hello.o` 进行链接，最后得到可执行目标程序 `hello` (executable object program)，文件是二进制文件，可以直接被加载到内存并执行

>***Aside*** _The GNU project_
>GNU(GNU's Not Unix)项目起源于1984年，该项目的目标是构建一个完整的类Unix系统，而且代码开源
>GNU项目最终开发了一个包含了所有Unix操作系统组件的环境(包括了EMACS，GCC，GDB等)，除了操作系统内核，内核后来由Linux项目开发
>现代开源运动起源于GNU项目的标语 “自由软件”

### 1.3 It Pays to Understand How Compilation Systems Work
为什么要理解编译系统：
- 优化程序性能
- 理解链接时错误
- 避免安全漏洞

### 1.4 Processors Read and Interpret Instructions Stored in Memory
截至目前，我们的 `hello` 程序已经编译完成，作为一个可执行二进制文件存储于硬盘中，要运行它，我们在shell中输入它的名字：
```shell
linux> ./hello
hello, world
linux>
```

shell是一个命令行解释器，shell的功能就是打印一个提示符(如 `linux>`)，等待用户输入命令，然后执行该命令
如果用户输入的第一个单词没有与任何一个shell内置的命令名对应，则shell就会认为这是一个可执行文件的名字，将它从硬盘中加载并交给CPU执行，shell会等待该程序执行结束，然后打印提示符，等待新的命令

#### 1.4.1 Hardware Organization of a System
![[CSAPP-Fig 1.4.png | 图1.4 计算机系统的硬件组织]]

**Buses**
将系统的各个部件相连的电气导管称为总线(buses)，总线一般以字(word)为单位传输信息，一般一个字可以由4个字节构成，即字长是32位($4\times 8 = 32$)，或由8个字节构成，即字长是64位($8\times 8 = 64$)，字长(word size)是计算机系统的基础参数之一

**I/O Devices**
输入输出设备/IO设备用于连接计算机系统和外界，示例系统中，有两个输入设备：键盘和鼠标，有两个输出设备：显示器和硬盘(或硬盘驱动器)
其中，键鼠用于接收用户输入，显示器用于向用户显示输出，硬盘用于长期存储数据和程序

每一个IO设备都通过控制器(controller)或适配器(adapter)与IO总线相连，控制器是位于IO设备自身或位于系统主板(motherboard)上的芯片组，而适配器则是插入主板插槽的卡，它们都用于在IO设备与IO总线之间传输信息

**Main Memory**
主存用于存储CPU执行程序时所需要的数据以及程序本身的暂时性存储设备
物理上，主存由一系列动态随机存取存储器(Dynamic Random Access Memory/DRAM)芯片的集合组成
逻辑上，主存被组织为一个线性的字节数组，每个字节都有自己的唯一地址，或者说数组索引，地址是从零开始的

一般来说，一个机器指令需要多个字节存储，不同的数据类型需要的字节个数也不同

**Processor**
中央处理单元(central processing unit/CPU)，简称处理器(processor)，对内存中的指令进行翻译和执行，处理器的核心处有仅一个字长大小的寄存器，称为程序计数器(program counter/PC)，程序计数器在任意时刻都存储一个机器指令在内存中的地址
从CPU上电开始到CPU断电结束，CPU反复地做两件事：执行PC所指向的机器指令，然后更新PC，使其指向下一个要执行的指令

从CPU的上层看，CPU依据它的指令执行模型运行，而它由指令集架构(instruction set architecture)所定义，在这个由指令集架构定义的模型中，指令按照严格的顺序执行，每一条指令的执行都包含了一系列步骤：CPU根据PC从内存中读取指令，CPU翻译指令中的二进制位，CPU执行指令所对应的操作，CPU更新PC使其指向下一个要执行的指令

CPU执行指令所对应的操作时，这些操作是围绕着内存、寄存器堆(register file)、ALU(arithmetic/logic unit)执行的，其中寄存器堆是由一系列字大小的寄存器组成的存储设备，每个寄存器都有自己独立的名字，ALU用于计算新的数据和地址

这些操作一般包括：
- Load
	将一个字节或一个字从主存拷贝到寄存器中，覆盖写
- Store
	将一个字节或一个字从寄存器拷贝到主存中，覆盖写
- Operate
	将两个寄存器的内容拷贝到ALU，执行运算，将结果存储至一个寄存器，覆盖写
- Jump
	从一个指令内部提取出一个字，将这个字写入PC，覆盖写

从CPU的上层看，处理器是对其指令集架构的简单实现，但现代处理器为了加快指令执行速度，都采用了微指令集架构(microarchitecture)，我们可以用微指令集架构描述每个机器指令的作用，理解处理器的实际实现

#### 1.4.2 Running the hello Program
最开始，shell程序执行中，等待用户输入指令，我们通过键盘输入 `./hello` ，shell程序读取这个输入，将其先读入寄存器，然后将其存入主存

我们键入enter，shell读取后明白输入结束，然后执行一系列指令，将可执行 `hello` 文件从磁盘读取到内存(包括拷贝文件中的代码和数据，数据即字符串 `hello world!\n` )
使用DMA(direct memory access)技术，数据直接从磁盘传到了内存，无需经过CPU

代码和数据都装载到内存后，CPU从 `hello` 的对应于main函数内的机器指令开始执行，CPU根据这些指令将字符串 `hello, world\n` 从内存中取出至寄存器，然后传输到显示设备

### 1.5 Caches Matter
计算机系统大量开销于数据移动，比如，`hello` 程序的机器指令，装载时从磁盘到内存，执行时从内存到寄存器，比如，数据 `hello , world!\n` ，装载时从磁盘到内存，执行时从内存到寄存器再到显示器
系统设计的一大目标是使得这些数据的拷贝操作更快

根据物理规则，大容量存储器更慢，小容量存储器更快，例如CPU读取内外存数据的速度差异可以达到1万倍，又例如，一个寄存器堆只能存储几百个字节的信息，但CPU读取寄存器的速度100倍快于读取主存

处理器-存储差异(processor-memory gap)，让CPU更快比让主存更快往往更简单和更便宜

缓冲存储器(cached memory/cache)用于缓解processor-memory gap，利用了程序的局部性(程序往往会访问一个较局部区域的数据和代码)，CPU通过访问cache代替访问主存，速度接近访问寄存器
L1 cache一般可以存储10K字节左右数据，速度和寄存器接近，L2 cache一般可以存储100K到1M字节左右的数据，速度比主存快5-10倍

cache由静态随机存取存储器构成(static random access memeory/SRAM)
cache和CPU有专门总线连接

### 1.6 Storage Devices Form a Hierarchy
![[CSAPP-Fig1.9.png|图1.9 存储架构示例]]
存储架构中的每一层都可以认为是其下一层的缓存

### 1.7 The Operating Systems Manages the Hardware
OS是介于应用程序和硬件之间的一层软件，任何运行于计算机上的程序都通过OS与硬件交互，而非直接交互

OS的目标：
1. 防止应用程序错误使用硬件以保护硬件
2. 在复杂和多样的底层硬件之上提供一个统一和简单的操作接口

OS通过三大基本抽象实现这两个目标：
1. 进程(processes)
	进程是对处理器、主存和IO设备的抽象
2. 虚拟存储(virtual memory)
	虚拟存储是对主存和IO设备的抽象
3. 文件(files)
	文件是对IO设备的抽象

#### 1.7.1 Processes
从一个程序的角度看，它是唯一运行于系统上的程序，它独占了处理器、主存、IO设备，它们只服务于该程序，而这层抽象是由进程这一概念提供的

进程是OS对一个正在运行中的程序的抽象，多个进程是并发地运行在同一系统上的(多核处理器可以完全同时，即并行执行多个进程)，处理器在进程之间切换执行，OS为此提供了上下文切换(contex switching)机制

OS会追踪一个程序运行时的状态信息，包括了当前的PC值、寄存器栈的内容、以及主存内的内容，称其为程序的上下文(context)

当OS决定需要切换执行进程时，它将执行上下文切换，包括了：
1. 存储当前进程的上下文
2. 恢复新进程的上下文
3. 转移控制权给新进程
之后，新进程从它之前中断的地方继续运行直到下一次切换

之前的示例中有两个并发的程序：shell程序和hello程序，开始时，shell程序运行，获取用户输入，用户输入后，shell程序认为要执行hello程序，会调用一个特别的函数，称其为系统调用(system call)，以将控制权转移给OS，OS执行上下文切换，保存shell的上下文，创建一个新的hello进及它的上下文，然后移交控制权给hello程序，hello程序结束后，OS获取控制权，恢复shell的上下文，移交控制权给shell程序

实际上执行上下文切换操作的是OS内核(kernel)，内核是OS全部代码的核心部分，也是OS代码中一直在内存中的部分
应用程序向OS请求操作时，都会通过系统调用，以转交控制权给OS，OS执行所要求的操作后再移交回控制权

内核不是一个单独的进程，是一系列用于管理所有进程的代码和数据结构

> ***Aside*** _Unix, Posix, Standard Unix Specification_
> 1960年后，大型、复杂的系统比如IBM's OS/360，Honeywell's Multics Systems出现
> IBM’s OS/360取得成功，而Multics迟迟达不到大规模的使用，贝尔实验室作为Multics的最初合作者之一，在1969年退出合作
> 而贝尔实验室的一部分研究者在1969年开始为一个Digital Equipment Corporation PDP-7计算机写一个更简单的OS，完全用机器语言
> 这个系统对Multics作了很多借鉴，包括层次级的文件系统、shell作为一个用户级别的应用程序
> 1970年，这个系统被命名为Unix
> 1973年，Unix的内核用C重写
> 贝尔实验室将Unix的源码对大学开放，因此Unix也在大学中进一步扩展
> 最有影响力的工作来自于UCB，完成于1970s-1980s，伯克利的研究者为Unix增加了虚拟内存以及网络协议，称其为Unix 4.xBSD(Berkeley Software Distribution)
> 同时贝尔实验室也发布了它们自己的版本，称为System V Unix
> Sun Microsystems Solaris system就是源自于System V Unix和BSD
> 1980s中期，IEEE赞助了Unix的标准化工作，后来称为Posix标准，Posix标准规定了Unix系统调用的C语言接口、shell程序、实用程序、线程、网络编程
> 后来Standard Unix Specification也加入Posix，为Unix系统建立单独统一的标准
#### 1.7.2 Threads
一个进程不一定只有一个控制流，在现代系统中，一个进程往往由多个执行单元构成，称其为线程(threads)

这些执行单元/线程共享进程的上下文、代码、全局数据，在线程中共享数据比在进程中共享数据容易，多线程比多进程更轻量和效率

#### 1.7.3 Virtual Memoery
虚拟内存为每个进程提供了它在独占使用内存的抽象，每个进程对内存的视角都是统一的，即它的虚拟地址空间
![[CSAPP-Fig1.13.png|图1.13 进程的虚拟地址空间]]

Linux系统中，进程的虚拟地址空间包括几个区域：
- 程序代码和数据(Program code and data)
	对于所有的进程，代码都从虚拟地址空间的同一个固定地址开始，代码段后即数据，一般是全局的C变量
	进程的代码段和数据段直接根据可执行对象文件来初始化
- 堆(Heap)
	代码和数据之后紧接的是运行时堆(run-time heap)，代码和数据的大小在进程开始运行时就固定不变，而堆的大小会动态变化
- 共享库(Shared libraries)
	接近地址空间的中间部分区域用于存储共享库的代码和数据，比如C标准库
- 栈(Stack)
	用户虚拟地址空间的顶端一般是用户栈(user stack)，当调用一个函数时，栈增长，当函数返回时，栈缩减
- 内核虚拟内存(Kernel virtual memeory)
	虚拟地址空间的顶部一般为内核保留，应用程序不允许对这段数据进行读写，也不允许直接调用定义内核代码中的函数，需要调用内核执行这些操作

#### 1.7.4 Files
文件(file)，本质上就是一个字节序列
所有的IO设备，包括磁盘，键盘、显示器、甚至网络，都被建模为一个文件
所有的IO操作，都以读写文件的方式执行，通过一些称为Unix I/O的系统调用执行

文件的抽象为应用程序提供了一个对各种不同的IO设备的一个统一的抽象

### 1.8 Systems Communicate with Other Systems Using Networks
计算机系统与计算机系统之间不是相互孤立的，它们通过网络互相连接

从一个计算机系统的视角出发，网络可以视作一个IO设备，计算机系统与网络之间通过网络适配器连接
![[CSAPP-Fig1.14.png|图1.14 计算机系统将网络视为IO设备]]

大量的应用程序，包括email、即时消息、万维网(World Wide Web)、FTP、telnet等都基于网络在计算机系统之间传输信息的能力

以用telnet远程运行 `hello` 程序为例，解释典型的网络中信息交换的模式：
![[CSAPP-Fig1.15.png|图1.15 用telnet远程运行 hello 程序的过程]]
首先我们本地主机作为telnet的客户端(client)，需要登录远程主机，即telnet服务器(server)，然后在远程主机运行shell程序，等待用户输入
之后会经过5个步骤：
1. 用户在本地主机键入 `./hello` 
2. telnet客户端将该 `./hello` 通过网络发送给telnet服务器
3. telnet服务器从网络中接收 `./hello` ，将其传给shell程序，shell程序负责在服务器上执行 `hello` 程序，然后将程序输出 `hello, world!\n` 传回给telnet服务器
4. telnet服务器将程序输出 `hello, world!\n` 通过网络发送给telnet客户端
5. telnet客户端接收到程序输出，在本地显示器上将其打印
### 1.9 Important Themes
#### 1.9.1 Amdahl's Law
考虑一个计算机系统执行一个程序的时间是$T_{old}$
假设整个执行过程的一部分占全部执行时间的$\alpha$，我们将这部分过程加速至原来的$k$倍，则加速后，全部的执行时间是$T_{new} = (1-\alpha)T_{old}+\alpha T_{oldl}/k = T_{old}[(1-\alpha)+\alpha/k]$

故加速比是：
$$S = T_{old}/T_{new} = \frac 1 {(1-\alpha) + \alpha/k}$$

阿姆达尔定律说明了如果我们需要极大地加速整个系统，则必须加速整个系统的一大部分

> ***Aside*** _Expressing relative performance_
> 表示性能提升最好的方式是用比值$T_{old}/T_{new}$
> 如果性能提升了，则该值会大于1
> 我们用一个$\times$后缀表示这个比值，比如$2.2\times$就表示这个比值是$2.2$，即$T_{old}$是$T_{new}$的$2.2$倍

阿姆达尔定律实际为任何过程的加速都提供了同一的准则

#### 1.9.2 Concurrency and Parallelism
并发(concurrency)指在一个系统内同一时间有多个活动进行
并行(parallelism)则指对并发概念的利用使得系统运行得更快

并行性在计算机系统中具有多个抽象层次，在这里强调三个层次，从系统层次结构的最高层到最低层：

**Thread-Level Concurrency**
基于进程这一抽象概念，我们可以使得一个系统有多个程序在同一时间执行，即并行性
基于线程这一抽象概念，我们可以在一个进程内执行多个控制流

对于并发性执行的支持出现于1960年代分时系统出现的时候，在单一的处理器单元上，并发性执行是通过在不断切换执行进程模拟的
这种形式的并发性允许多个用户在同一时间段与同一系统交互，比如多个用户从一个Web服务器获取页面，它同时允许一个用户在同一时间段进行多个任务，即享受多个服务进程的服务

多处理器系统从1980年代开始出现，标志性技术有多核处理器和超线程技术

多核处理器：
![[CSAPP-Fig1.17.png|图1.17 多核处理器的组织结构]]
图中是一个典型的多核处理器的组织结构，在同一个芯片内，有4个CPU核心，每个核心有自己的L1，L2 cache，且每个L1 cache都分为两部分，一部分存储指令，一部分存储数据，这4个核心共享L3 cache、内存等更高层的存储，共享与主存的接口

超线程：
超线程也称为同时多线程(simultaneous multi-threading)，这项技术允许单个CPU核执行多个控制流，超线程技术中，一个CPU核内有多个PC、寄存器堆，但共享单个ALU
一个常规的CPU需要20000个时钟周期切换一个线程，而使用超线程基础，CPU会在每个时钟周期都决定要执行的是哪个线程并切换
超线程技术让处理器资源得到了更好的利用，比如当一个线程必须等待数据装入cache时，CPU就可以先执行另一个线程

多处理技术减少了需要模拟并发的需要，也可以加速一个进程的执行(如果该进程可以用允许同时执行的多线程的概念表示)

**Instruction-Level Parallelism**
比线程级抽象更底层的抽象是指令级抽象，现代的处理器在一次可以同时执行多个指令，称其为指令级别的并行

早期的微处理器，比如1978-vintage Intel 8086，需要多个时钟周期(一般是3-10个)以执行单个指令，最近的处理器则可以保持一个时钟周期2-4个指令的执行速率
实际上，一个指令可能需要多个时钟周期才能完成，比如20个时钟周期，但处理器在同一时间内可以处理多个指令(比如流水线技术，将一条指令的执行分成多个步骤，将处理器的运行分成多个阶段，每个阶段执行一个步骤，而这些阶段可以达到并行执行，执行不同指令的不同步骤)，比如100个指令，因此计算下来可以保持一个时钟周期多个指令的执行速率

可以保持高于一个时钟周期一个指令的执行速率的处理器称为超标量处理器(superscalar processors)，多数现代处理器都支持超标量操作

**Single-Instruction, Multiple-Data(SIMD) Parallelism**
在最底层，现代的处理器都具有特殊的硬件结构，允许单个指令引发多个并行的操作发生，称这个模式为单指令多数据并行
比如，现代的AMD和Intel处理器可以通过一条指令并行完成8对浮点数(C中的 `float` 类型)的加法

SIMD技术可以加速图像、声音、视频数据的处理，要利用SIMD技术，最好的方式是利用编译器支持的向量(vector)数据类型

#### 1.9.3 The Impartance of Abstractions in Computer Systems
抽象(abstractions)的使用是计算机科学中最重要的概念之一

我们已经了解过了计算机系统中的不同层次的抽象
![[CSAPP-Fig1.18.png|图1.18 计算机系统中的一些抽象]]
比如在处理器级别，指令集架构提供了一层对处理器硬件的抽象，在这层抽象上，从一个被处理器执行的机器语言程序的角度出发，它将每次正好被处理器执行一个机器指令，而实际底层的硬件结构往往更复杂，比如支持多个指令的并行执行，但总会与上层的简单、串行执行模型保持一致
保持同样的执行模型，不同结构的处理器可以执行同样的机器语言程序

在OS级别，我们了解了三层抽象：将IO设备抽象为文件、将程序内存抽象为虚拟内存、将运行中的程序抽象为进程

这里介绍一层新的抽象：虚拟机(virtual machine)，它是对整个计算机系统的抽象，包括了OS、处理器、程序，虚拟机的概念由IBM在1960年代提出

### 1.10 Summary
计算机系统由硬件和软件协同组成，目标是运行应用程序
计算机系统内的信息以比特流的形式存储，基于不同上下文，有不同的解释
程序会被翻译成各种不同的形式，从ASCII文本开始，经过编译器、链接器，最后成为二进制可执行文件
处理器读取、解释、执行存储于主存的二进制指令
计算机花费大量时间在存储设备之间搬运信息，整个系统的存储设备按照层次结构组织，高层存储设备速度更快，每比特价格更高，低层存储设备反之
高层存储设备以低层存储设备的缓存形式工作
OS内核是硬件和应用程序的中间层，OS提供了三层基本抽象：IO设备抽象为文件、IO设备+内存抽象为虚拟内存、IO设备+内存+处理器抽象为进程
网络用于连接计算机系统，从一个计算机系统的角度出发，网络被视为一个IO设备

# Part 1 Program Structure and Execution
## CH2 Representing and Manipulating Information
现代计算机利用二值信号存储和处理信息，二进制值可以方便地表示打孔纸上孔的存在与否、导线上的电压是高或低、磁场方向是顺时针或逆时针
对特定的二进制数组合给予特定的解释，可以表示任何有限集合内的元素

最重要的三种数字表示形式：
1. 无符号编码(Unsigned encodings)
	基于数字传统的二进制表示法，可以用于表示任何大于等于0的数
2. 二进制补码编码(Two's-complement encodings)
	表示有符号整型(signed integers)最常用的方式
3. 浮点编码(Floating-point encodings)
	表示实数的科学记数法的以2为基数的版本

计算机用有限个二进制位表示数，因此当数字超出了表示范围，会导致溢出(overflow)问题

计算机中的整型算数仍满足结合律和交换律，但因为浮点数受表示精度的限制，浮点数算数不满足结合律，比如在大多数机器上，C表达式 `(3.14+1e20)-1e20` 的值是 `0.0` ，而 `3.14+(1e20-1e20)` 的值是 `3.14` 
整型表示是精确的，但浮点数表示只能是近似的

### 2.1 Information Storage
多数计算机系统将字节(8bit)作为存储的最小可寻址单位
对于一个机器级别程序来说，计算机系统的存储以虚拟内存(virtual memeory)的形式展现，而虚拟内存的形式就是一个大型的字节数组
其中，每个字节都有自己独立的地址(address)，所有可能地址的集合就是虚拟地址空间(virtual address space)
虚拟地址空间是呈现给程序的概念图像，它实际上由内存DRAM、闪存、磁盘存储、特殊硬件和OS软件共同提供

编译器(compiler)和运行时系统(run-time system)会将虚拟内存分割成若干个可管理的单元，以存储不同的程序对象(program objects)(比如程序数据、指令、控制信息)

C中的指针，不论它指向的是什么，它的值就是该对象在虚拟地址空间中所占据的存储块的第一个字节的地址
C编译器会将指针与类型(type)信息关联，以便根据类型信息生成不同的机器级别代码，以准确访问该指针所指向的对象的值
注意C编译器会维护类型信息，但是编译生成的机器级程序不会包含任何数据类型相关的信息，对于机器级程序来说，每个程序对象以及程序本身都仅仅是一串字节流

> ***Aside*** _The evolution of the C programming language_
> C语言诞生之前，大多数系统级程序，包括OS，都不得不大部分用汇编语言编写，以访问不同数据结构的底层表示
> 因为那个时代的高级语言没有像C一样提供 `melloc` 这样的内存接口库函数
> 最初的C由第一版的K&R规定
> 对C第一次重要的修订是1989年的ANSI C标准，它在第二版的K&R中被描述
> 对C制定标准的责任后来由ISO接手，ISO在1990年发布了"ISO C90"标准，这个标准大部分和ANSI C相同
> ISO在1999年发布了"ISO C99"标准，引入了新的数据类型、对非英文字符的字符串提供了支持
> 最近的标准是"ISO C11"，发布于2011年，加入了新的数据类型和特性
> 大部分的标准都是向后兼容(backward compatible)的，即根据早先的标准编写的C程序(至少兼容到"ISO C90")，即使依照新标准编译，程序的行为也不会变化
> GCC(The GNU Compiler Collection)可以根据不同的标准对C程序编译，只需要提供命令行选项，比如要根据ISO C11编译，则输入：
> `linux> gcc -std=c11 prog.c`
> 注意选项 `-ansi` 和 `-std=c89` 在GCC中是一样的，都依据ISO C90编译(C90有时也可称为C89，因为标准化工作开始于89年，完成于90年)
> 默认情况下，GCC会基于C90编译，但是会包括C99、C11，C++的一些特性
> GNU项目正基于C11，结合一些特性开发GNU 11标准，它将成为GCC的默认编译选项
> GCC中的一些C标准选项：
> GNU 89： `none, -std=gnu89`
   ANSI, ISO C90： `-ansi, -std=c89`
   ISO C99： `-std=c99`
   ISO C11： `-std=c11`

#### 2.1.1 Hexadecimal Notation
一个字节包括八位二进制数，范围从$00000000_2$到$11111111_2$ ，即从$0_{10}$到$255_{10}$
二进制表示过于冗长，十进制表示不方便和二进制表示相互转换
因此采用十六进制(hexadecimal)，则单个字节的范围从$00_{16}$到$FF_{16}$

C中，以 `0x` 或 `0X` 开头的数字常量都解释为16进制数，字母A-F可以是大写也可以是小写，也可以混写
比如十六进制数$FA1D37B_{16}$在C中可以写为 `0xFA1D37B` 或 `0xfa1d37b` 或 `0xFa1D37b`

数的十六进制表示到二进制表示的转换只需要展开每个十六进制位即可
数的二进制表示到十六进制表示的转换需要以4个位为一组分组(必要时添加先导0)，然后将每组二进制位转换为一个十六进制位即可

当一个数是2的幂次，即$x=2^n$，它的二进制表示就是1后跟$n$个0，因为一个16进制位0等价于4个二进制位0，故我们把$n$个0写成$i+4j(0\le i\le 3)$个0的形式，故第一个十六进制位就和$i$的大小有关：$1(i=0),2(i=1),4(i=2),8(i=3)$
比如：$x=2048=2^{11}$，则$11 = 3+4\times 2$，故$x$的十六进制表示为 `0x800`

数的十进制表示到十六进制表示的转换需要反复将数除以16，即将数$x$写成$x = q\times 16 + r$的形式，然后将余数$r$作为$x$的16进制表示的最低有效位，再对商$q$重复这个过程，即$q = q'\times 16 + r'$，将$r'$作为次低位，再对$q'$重复，依此类推
例如：
$$\begin{aligned}314156 &=19634\times 16+12\\
19634 &=1227\times16+2\\
1227 &=76\times 16+11\\
76 &= 4\times 16 + 12\\
4 &=0\times 16+4
\end{aligned}$$
则314156的16进制表示为 `0x4CB2C`

数的十六进制表示到十进制表示的转换只要将对应十六进制位乘上对应位的权重，最后相加即可

#### 2.1.2 Data Sizes
每个计算机系统都有字长(word size)，字长大小就是指针数据的标准大小
指针数据指向了一个虚拟地址空间内的地址，因此指针大小也决定了虚拟地址空间的最大大小
对于一个字长为$w$位的机器，它的虚拟地址空间范围从$0$到$2^w-1$，即最多存储$2^w$个字节，也说明了一个程序最多只能访问$2^w$个字节

32位机的字长为32位，因此它的虚拟地址空间最多只有$2^{32}$字节即$4$GB(gigabytes)，大约$4\times 10^9$字节
64位机的字长为64位，因此它的虚拟地址空间最多有$2^{64}$字节即$16$EB(exabytes)，大约$1.84\times 10^{19}$字节

大多数64位机也可以运行为32位机编译的程序，即向后兼容，比如以 `linux> gcc -m32 prog.c` 命令编译的程序，可以在64位和32位机上都正确运行
但以 `linux> gcc -m64 prog.c` 命令编译的程序则只能在64位机上运行

我们可以称一个程序是64位程序(64-bit program)或32位程序(32-bit program)以区分它是如何被编译的

计算机系统和编译器支持多种数据类型以编码不同类的数据，对于同类的数据，也支持不同的长度
C中不同的类型有不同的大小，典型的大小由C标准定义：
![[CSAPP-Fig2.3.png|图2.3 C中不同数据类型的大小]]
注意对于相同的数据类型，在为不同字长的机器编译时，实际的大小也不同，即32位程序和64位程序的差异
整数数据类型有有符号(signed)和无符号(unsigned)的区别，无符号数只允许数据非负
`char` 类型的大小只有一个字节，`char` 类型也可以用于存储整数数据

ISO C99引入了一些数据类型，它们的大小是固定的，和编译器、机器的设定无关，其中就有 `int32_t` 和 `int64_t` ，各自的长度是4个字节和8个字节
使用这些固定大小的数据类型可以让我们在不同的环境都可以确定我们所使用的数据大小

多数数据类型默认为有符号，若需要无符号，则添加 `unsigned` 前缀
而在C标准中，并没有明确规定 `char` 类型默认是有符号的，虽然大多数机器和编译器默认 `char` 类型默认为 `signed` 
可以显式声明 `signed char` 以保证使用的 `char` 类型是有符号的

C允许在类型声明中使用不同的顺序或忽略可选关键词，比如 `unsigned long` , `unsigned long int` , `long unsigned` , `long unsigned int` 的含义是一样的

C中指针类型数据的大小一般为机器字长大小

要让我们的程序对不同的机器和编译器都有可移植性，而可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感
C标准规定了不同数据类型所包括的数据范围的下界，但没有规定上界(除了固定大小类型(fix-sized types)
数据类型的大小不同问题在将程序从32位机迁移到64位机时常常会导致bug，比如在32位程序中，可以用 `int` 类型存储指针数据，但在64位机中会导致问题

#### 2.1.3 Addressing and Byte Ordering
对于占据了多个字节大小的程序对象，需要有两个规定：
- 这个对象的地址是什么
- 如何排列这个对象在内存中的字节顺序

在几乎所有机器中，一个多字节对象都以一个连续的字节序列的形式存储
而对象的地址即这些字节的地址中最小的一个地址

例如：
`int` 类型变量 `x` 的地址是 `0x100` ，那么表达式 `&x` 的值就是 `0x100` ，且 `int` 类型占据的4个字节的地址分别是 `0x100` , `0x101` , `0x102` , `0x103`

考虑一个大小是$w$位的对象$[x_{w-1},x_{w-2},\cdots,x_1,x_0]$，其中$x_{w-1}$称为最高有效位(the most significant bit)，$x_0$称为最低有效位(the least significant bit)
设$w$被8整除，则将这些位以8个为一组分组，则字节$[x_{w-1},x_{w-2},\cdots,x_{w-8}]$称为最高有效字节(the most significant byte)，字节$[x_7,x_6,\cdots,x_0]$称为最低有效字节(the least significant byte)

当存储对象时，如果存储的顺序是从最低有效字节到最高有效字节，即最低有效字节在前，称其为小端序(little endian)
当存储对象时，如果存储的顺序是从最高有效字节到最低有效字节，即最高有效字节在前，称其为大端序(big endian)

例如：
`int` 类型变量 `x` 的地址是 `0x100` ，且其值的16进制形式是 `0x01234567` ，该变量一共占据了 `0x100` , `0x101` , `0x102` , `0x103` 四个地址
若按大端序存储，则按地址从小到大，其字节序是 `01` , `23` , `45` ,` 67`
若按小端序存储，则按地址从小到大，其字节序是 `67` , `45` , `23` , `01`

大多数兼容Intel的机器都仅采用小端序，而大多数IBM和Oracle机器则采用大端序，但IBM和Oracle也制造使用Intel兼容处理器的计算机，而采用的是小端序
许多现代的微处理芯片采用双端序，意味着它们可以即被配置为在大端序机器上运行，也可以被配置为在小端序机器上运行
但在实际中，字节序在选择了特定的OS时就已经固定了
例如用于移动系统的ARM微处理器支持双端序，但移动端常见的两大OS——Android(来自于Google公司)、IOS(来自于Apple公司)都仅在小端序模式下运行

并没有技术上的原因表明哪一种字节序优于哪一种字节序，仅仅是惯例的问题

从大多数应用程序的视角出发，机器使用的字节序是完全透明的，在使用了不同字节序的机器上编译同一程序，程序的运行结果也是相同的


当不同机器通过网络进行数据通讯时，字节序的差异会导致问题，同一串字节流，两边机器的解读顺序却相反
因此在为网络应用编码时，必须遵循共识的字节序惯例，保证发送端机器发送前将内在机器表示转化为网络标准表示，接收端机器收到后将网络标准表示转化为内在机器表示

在审查汇编程序和机器码程序时，也需要注意字节序
例如：
有一个将运行于Intel x86-64处理器上的机器指令
`01 05 43 0b 20 00`
通过反汇编器(disassembler)，将机器指令转化为汇编指令
`add %eax,0x200b43(%rip)`
则可以看出，这个指令的作用先将PC内的值(PC内的值是下一个要执行的指令的地址)和 `0x200b43` 相加得到一个地址，然后将寄存器 `eax` 内的数加到位于该地址的数上
很显然，机器指令中 `43 0b 20 00` 这最后4个字节是作为立即数的，但由于机器采用的是小端字节序，则要得到正确的值，需要将字节反序 `00 20 0b 43` ，在去掉前导零，立即数应该是 `0x200b43` ，正好是汇编指令中的值
因此，在阅读为采用了小端序的机器生成的机器级程序时，常常可以发现字节是反序的(因为我们习惯从左到右、从最高有效位到最低有效位书写一个数)

在试图规避通常的类别系统时，也要注意字节序的影响
在C中，我们可以通过使用 `cast` 和 `union` 以允许根据一个和该对象创建时所属的类型完全不同的类型访问该对象，这种技巧在应用级程序中不推荐，但在系统级编程时可能是必须的
```c
#include<stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len){
	int i;
	for(int i = 0; i < len; i++){
		printf(" %.2x", start[i]);
	}
	printf("\n");
}

void show_int(int x){
	show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x){
	show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
	show_bytes((byte_pointer) &x, sizeof(void *));
}
```
这部分代码就利用了强制类型转换以访问并打印程序对象的字节表示
我们用 `typedef` 定义了指向 `unsigned char` 的指针的类型为 `byte_pointer` ，那么 `byte_pointer` 就指向了一系列连续字节的起始地址，其中的每个字节都认为表示一个非负的整数
函数 `show_bytes` 接受一个 `byte_pointer` 指向一系列字节的起始地址，接收一个 `size_t` 表示字节的个数，然后逐个将这些字节以其16进制的形式打印
函数 `show_int` , `show_float` , `show_pointer` 使用了 `show_bytes` 以打印类型为 `int` , `float` , `void *` 的程序对象的字节表示，它们将 `&x` 的类型强制转换为 `byte_pointer` ，这使得编译器将这部分数据看作一个个连续的字节，而不是整体的一个 `int` / `float` / `void *` 类型的程序对象，同时它们都使用了 `sizeof` 运算符，计算程序对象占据的字节数

在4个不同的环境中运行测试代码，环境包括了：
- Linux32：Intel IA32处理器，运行Linux系统
- Windows：Intel IA32处理器，运行Windows系统
- Sun：Sun Microsystems SPARC处理器，运行Solaris系统(该机器现在由Oracle提供)
- Linux64：Intel x86-64处理器，运行Linux系统

测试代码：
```c
void test_show_bytes(int val){
	int ival = val;
	float fval = (float) val;
	int* pval = &ival;
	show_int(ival);
	show_float(fval);
	show_pointer(pval);
}
```

结果如图：
![[CSAPP-Fig2.6.png|图2.6 相同程序对象在不同机器上的字节表示]]
我们传入的参数 `val = 12345` ，其十六进制表示是 `0x00003039` 
类型是 `int` 时，字节表示都相同，除了字节序不同，具体地说，在Linux32、Windows、Linux64上，最低有效字节 `0x39` 在前，说明它们采用小端序，而Sun采用大端序
类型是 `float` 时，结果和 `int` 相同
类型是 `int *` 时，指针变量的值完全不同，结果则由机器的存储分配决定，注意到Linux64使用了8字节地址(64位)，而其他机器使用4字节地址(32位)

注意类型是 `int` 和 `float` 时，即使值都是 `12345` ，其表示却完全不同，一个是 `0x00003039` ，一个是 `0x00e44046`，因为它们使用了不同的编码方法

#### 2.1.4 Representing Strings
C中的字符串实际以字符数组的形式存储，并且会以 `null` 字符结尾( `null` 字符的值为0)，字符的值遵循某个标准编码，其中最常用的是ASCII字符编码
例如：
在使用ASCII编码的机器上运行 `show_bytes("12345", 6)` (这里把长度指定为6是为了包括结尾的终止字符)，会得到结果 `31 32 33 34 35 00` (ASCII编码中，对于十进制数字$x$的编码是 `0x3x`)，注意终止字符的编码是 `0x00`
在任何使用ASCII编码的机器上运行这一程序，我们得到的都是相同的结果，因为在C中，字符串中的字符简单遵循按顺序依次存储，存储顺序与字节序无关
因此，文本数据相较于二进制数据更具有平台无关性

> ***Aside*** _The Unicode standard for text encoding_
> ASCII字符集适用于对英语文档进行编码，但缺少对其他特殊字符的编码，比如希腊语、俄语、汉语等
> Unicode联盟(The Unicode Consortium)设计了最全面和被最广泛接受的文本编码标准，即Unicode标准
> Unicode标准(7.0版)拥有超过100000个字符的编码，支持多种语言，包括埃及和巴比伦的古代语言
> 基础编码(the base encoding)，或者说Unicode的“通用字符集(Univsersal Character Set)”，统一使用32个二进制位表示每一个字符，即4个字节
   但对于一些常见的字符，可以使用替代编码(alternative coding)，替代编码中，常见字符只需要1或2个字节，不常见字符则需要更多
   UTF-8表示以字节序列的形式将每个字符编码，对于标准ASCII字符，UTF-8使用与ASCII相同的单字节编码
   Java使用Unicode作为其字符编码，C也可以使用程序库以支持Unicode
#### 2.1.5 Representing Code
相同的程序，在不同的计算机系统上编译，生成的机器码是完全不同的
不同的机器类型使用的指令和指令编码一般是不同且不兼容的，即使是运行不同操作系统的相同处理器，其指令编码约定也存在差异，因此也不是二进制兼容的(binary compatible)

因此二进制代码一般都不是跨平台可移植的

计算机系统的一个基础概念就是从机器的角度出发，一个程序仅仅是一串字节序列，机器对于源程序的信息是不可知的

#### 2.1.6 Intruduction to Boolean Algebra
George Boole(1815-1864)建立了布尔代数(Boolean Algebra)，布尔将逻辑值(logic values) `TRUE` , `FALSE` 以二进制值(binary valuse) `0` , `1` 编码，因此公式化了逻辑推理的基本原则

最简单的布尔代数定义于二元集合 {0,1}，这个代数系统中的运算如图
![[CSAPP=Fig2.7.png|图2.7 布尔代数中的运算]]
表中运算的表示符号和C中的位操作符相同
表中的布尔运算符 `~` 对应逻辑运算符 `NOT`，书面上以 $\neg$ 标识
表中的布尔运算符 `&` 对应逻辑运算符 `AND`，书面上以 $\land$ 标识
表中的布尔运算符 `|` 对应逻辑运算符 `OR`，书面上以 $\lor$ 标识
表中的布尔运算符 `^` 对应逻辑运算符 `EXCLUSIVE-OR`，书面上以 $\oplus$ 标识

Claude Shannon(1916-2001)首先将布尔逻辑和数字逻辑(digit logic)联系，将布尔逻辑应用于机电继电器网络(networks of electromechanical relays)的设计和分析
布尔逻辑仍在数字系统(digital systems)的设计和分析中起关键作用

可以将对单个元素的布尔运算拓展至对位向量(bit vectors)的运算，长度$w$的位向量与长度$w$的位向量作布尔运算，结果仍是一个长度$w$的位向量，运算以逐位操作的形式进行

位向量可以用于表示有限个集合，可以用位向量$[a_{w-1},\dots,a_1,a_0]$表示集合$\{0,1,\dots,w-1\}$的任意一个子集$A\ ( A\in\{0,1,\dots,w-1\})$，其中$a_i = 1$当且仅当$i\in A$，否则$a_i=0$
例如：
$a=[01101001]$表示集合$A=\{0,3,5,6\}$，$b=[01010101]$表示集合$B=\{0,2,4,6\}$
位向量与特定集合一一对应，而布尔运算也可以与集合运算一一对应，比如 `|` , `&` , `~` 就对应集合的并运算，交运算和补运算

#### 2.1.7 Bit-Level Operations in C
C支持逐位布尔运算(bitwise boolean operations)，先前使用的布尔运算符的表示符号 `~` , `&`, `|` , `^` 和C中逐位布尔运算符的符号的是一致的
这些运算符可以对任意的“整数型”数据类型("integral" data type)使用(包括 `char` , `short` , `int` , `long` , `int32_t` , `int64_t` 等)

要手动求值位级表达式(bit-level expression)，最好的方法是将十六进制表示转换为二进制表示，逐位运算，然后将结果从二进制表示再转回十六进制表示

位级运算常用于执行掩蔽操作(masking operations)，其中掩码(mask)是指示字内的所选比特集的比特模式(bit pattern)
例如：
掩码 `0xFF` 只有最低有效的8位为1，其余位为0，该掩码表示了一个字的最低有效字节，位级操作 `x&0xFF` 的结果保留 `x` 的最低有效字节，将其他位都置为0，比如当 `x=0x89ABCDEF` ， `x&0xFF` 的结果是 `0x000000EF`
表达式 `~0` 的结果是所有位全为1的掩码

#### 2.1.8 Logical Operations in C
C也提供了逻辑运算符(logical opeartors)，包括 `||` , `&&` , `!` ，分别与逻辑运算 `OR` , `AND` , `NOT` 对应
注意逻辑运算符和位级运算符是完全不同的，位级运算符接收位向量，返回位向量，而逻辑运算符只返回单值，且只有两种可能： `0`(代表 `FALSE`)，或 `1` (代表 `TRUE`)
逻辑运算符将任何非零参数都视为 `TRUE` ，否则视为 `FALSE`

逻辑表达式的值：
- `!0x41`：`0x00 `
- `!0x00`：`0x01`
- `!!0x41`：`0x01`
- `0x69 && 0x55`：`0x01`
- `0x69 || 0x55`：`0x01`

如果位级运算符接收的参数都是单个的0或1，则它的行为与逻辑运算符相同

逻辑运算符 `&&` , `||` 和位运算符 `&` , `|` 的另一个区别是如果逻辑运算符根据第一个参数就可以确定表达式的值时，逻辑运算符不会对第二个参数求值
因此，表达式 `a && 5/a` 将永远不会引发除零异常，表达式 `p && *p++` 将永远不会导致对空指针的解引用

#### 2.1.9 Shift Operation in C
C提供了移位运算符(shift operatiors)以对位模式(bit patterns)执行向左/向右移位的操作

对于一个$w$位操作数(operand) `x` ，其位表示(bit representation)为$[x_{w-1},x_{w-2},\dots,x_0]$
- 左移
	表达式 `x<<k` 的值是$[x_{w-k-1},x_{w-k-2},\dots,x_0,,\dots,0]$，即 `x` 向左移了 `k` 位，原来的前 `k` 个最高有效位被丢弃，并且在右端补齐 `k` 个 `0`
	注意位移量 `k` 的取值范围应该在 `0` 到 `w-1` 之间
	位移运算符的连接性是从左到右，因此表达式 `x<<j<<k` 与 `(x<<j)<<k` 等价
- 右移
	通常计算机系统支持两种形式的右移：
	逻辑型(Logical)：逻辑右移将原来的后 `k` 个最低有效位丢弃，在左边填充 `0` ，例如将 `x` 逻辑右移 `k` 位的结果是$[0,\dots,0,x_{w-1},x_{w-2},\dots,x_k]$
	算术型(Arithmetic)：算数右移将原来的后 `k` 个最低有效位丢弃，在左边填充原来的最高有效位，例如将 `x` 算数右移 `k` 位的结果是$[x_{w-1},\dots,x_{w-1},x_{w-1},x_{w-2},\dots,x_k]$
	算数右移主要用于处理有符号整型

C标准没有明确规定对于有符号数应该使用哪种类型的右移，不过在实际中几乎所有的编译器和机器对于有符号数都使用的是算数右移
对于无符号数，右移类型必须为逻辑右移

与C不同的是，Java明确定义了两种右移运算符：`x>>k` 表示算术右移， `x>>>k`表示逻辑右移

> ***Aside*** _Shifting by `k`, for large values of `k`_
> 在大多数机器上，对于一个只有 `w` 位的数据类型进行移位操作时，只会考虑移位量 `k` 的低$log_2 w$位，因此实际考虑的移位量一定满足严格小于 `w` ，当$k\ge w$时，实际考虑的移位量等于 `k mod w` 
> 例如对 `int` 类型的数据进行移位时，`w = 32`，只考虑 `k` 的低$log_232 = 5$位
> 当 `k = 32` ，实际移位量为 `32 mod 32 = 0` 
> 当 `k = 36` ，实际移位量为 `36 mod 32 = 4`
> 当 `k = 40` ，实际移位量为 `40 mod 32 = 8`
> C标准中没有明确定义这种行为，而Java则明确定义了实际位移量应该以这种取余数的方式计算得到

> ***Aside*** _Operator precedence issues with shift opeartions_
> 在C中，`1<<2+3<<4` 等价于 `1<<(2+3)<<4` ，而不是 `(1<<2)+(3<<4)` 因为加减运算符的优先级高于移位运算符，再根据左至右的结合性规则(left-to-right associativity rule)，实际上的运算顺序是 `(1<<(2+3))<<4`

### 2.2 Integer Representations
本节介绍两种用bits编码整数的方法，其中一种只能表示非负整数，而另一种可以表示负整数、零、正整数

#### 2.2.1 Integral Data Types
C支持一系列整数型数据类型(integral data types)，即可以表示有限范围内的整数的数据类型

对于32位程序
![[CSAPP-Fig2.9.png|图2.9 32位C程序中整数型数据类型的表示范围]]

对于64位程序![[CSAPP-Fig2.10.png|图2.10 64位C程序中整数型数据类型的表示范围]] ^525095

不同的数据类型有不同的大小，因此表示的范围也不同
`long` , `unsigned long` 类型由于使用的字节数与机器有关，故其所表示的范围与机器也有关，其中64位程序使用8个字节，而32位程序使用4个字节

数据表示的范围也不是对称的，例如 `char` 表示的范围是$[-128,127]$，`short` 表示的范围是$[-32768,23767]$，负数的范围总比正数多一

C标准定义了每个数据类型必须能够表示的最小范围
![[CSAPP-Fig2.11.png|图2.11 C标准中整数型数据类型必须表示的最小范围]]
标准中规定的范围总是小于或等于实际中的范围，比如 `int` 和 `long` 要求的范围，且标准只要求了对称的表示范围(除了固定大小的类型)
对于固定大小的类型，标准和实践保持一致，无论是范围大小还是范围对称性

#### 2.2.2 Unsigned Encodings
考虑一个$w$位的整数数据类型，我们将其位向量记为$\vec x = [x_{w-1},x_{w-2},\dots,x_0]$

将$\vec x$作为一个数的二进制形式，就得到了$\vec x$的无符号解释(unsigned interpretation)
$\vec x$的无符号解释中，每一位$x_i$表示值$x_i\times 2^i$，所有位的值相加，得到位向量代表的值

用函数$B2U_w$(binary to unsigned, length $w$)表示无符号解释
**Principle**: Definition of unsigned encoding
对于位向量$\vec x=[x_{w-1},x_{w-2},\dots,x_0]$
$$B2U_w(\vec x) \doteq\sum_{i=0}^{w-1}x_i2^i$$
其中$\doteq$表示等式左边被定义为等于等式右边
函数$B2U_w$将一个长度为$w$，仅包含0和1的字符串(或者说位向量，字符串是位向量的表示形式)映射为一个非负的整数

例如：
$B2U_4([0001]) = 0\cdot2^3 + 0\cdot2^2 + 0\cdot 2^1 + 1\cdot 2^0 = 0+0+0+1=1$
$B2U_4([0101]) = 0\cdot2^3 + 1\cdot2^2 + 0\cdot 2^1 + 1\cdot 2^0 =0+4+0+1= 5$
$B2U_4([1011]) = 1\cdot2^3 + 0\cdot2^2 + 1\cdot 2^1 + 1\cdot 2^0 =8+0+2+1= 11$
$B2U_4([1111]) = 1\cdot2^3 + 1\cdot2^2 + 1\cdot 2^1 + 1\cdot 2^0=8+4+2+1 = 15$

对于一个$w$位的位向量$\vec x$，$B2U_w(\vec x)$的最小值是$B2U_w([00\dots0])=0$，最大值是$B2U_w([11\dots1]) = UMax_w \doteq \sum_{i=0}^{w-1}2^i = 2^w-1$

因此$B2U_w$可以定义为映射：
$B2U_w:\{0,1\}^w \to \{0,\dots, UMax_w\}$

任意$w$位位向量的无符号解释都对应在$0$和$2^w-1$之间唯一的一个数，任意在$0$和$2^w-1$之间的数都对应一个唯一的$w$位位向量的无符号表示
**Principle**: Uniqueness of unsigned encoding
函数$B2U_w$是双射函数

作为双射函数，$B2U_w$将一个$w$位的位向量映射到一个在$[0,2^w-1]$的唯一的整数，而它的反函数，我们定义为$U2B_w$(unsigned to binary)，将一个在$[0,2^w-1]$内的整数映射到一个唯一的$w$位位向量

#### 2.2.3 Two's-Complement Encodings
计算机系统最常用的表示有符号数的表示法是补码(two's-complement)

补码表示法将最高有效位的权重定为负数，我们用函数$B2T_w$(binary to two's complement, length $w$)表示它
**Principle**: Definition of two's-complement encoding
对于位向量$\vec x=[x_{w-1},x_{w-2},\dots,x_0]$
$$B2T_w(\vec x)\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2_i$$
最高有效位$x_{w-1}$称为符号位(sign bit)，它的权重是$-2^{w-1}$，是其无符号表示的权重的相反数

对于一个补码，当符号位为1，则它表示的值为负数，当符号位为0，则它表示的值是非负数
例如：
$B2T_4([0001]) = -0\cdot2^3 + 0\cdot2^2 + 0\cdot 2^1 + 1\cdot 2^0 = 0+0+0+1=1$
$B2T_4([0101]) = -0\cdot2^3 + 1\cdot2^2 + 0\cdot 2^1 + 1\cdot 2^0 =0+4+0+1= 5$
$B2T_4([1011]) = -1\cdot2^3 + 0\cdot2^2 + 1\cdot 2^1 + 1\cdot 2^0 =-8+0+2+1= -5$
$B2T_4([1111]) = -1\cdot2^3 + 1\cdot2^2 + 1\cdot 2^1 + 1\cdot 2^0=-8+4+2+1 = -1$

可以发现，对于同一个比特模式，当它的最高有效位为0，补码表示和无符号表示的值是一样的，而当它的最高有效位为1，则不同，因为补码表示法定义最高有效位的权重为负，而无符号表示法定义最高有效位的权重为正

对于一个$w$位的位向量$\vec x$，$B2T_w(\vec x)$的最小值是$B2T_w([10\dots0])=TMin_w\doteq -2^{w-1}$，最大值是$B2T_w([01\dots1])=TMax_w\doteq 2^{w-1}-1$

因此$B2T_w$可以定义为映射：
$B2T_w:\{0,1\}^w \to \{TMin_w,\dots, TMax_w\}$

任意$w$位位向量的补码解释都对应在$-2^{w-1}$和$2^{w-1}-1$之间唯一的一个数，任意在$-2^{w-1}$和$2^{w-1}-1$之间的数都对应一个唯一的$w$位位向量的补码表示
**Principle**: Uniquess of two's-complement encoding
函数$B2T_w$是双射

作为双射函数，$B2T_w$将一个$w$位的位向量映射到一个在$[-2^{w-1},2^{w-1}-1]$的唯一的整数，而它的反函数，我们定义为$T2B_w$(two's complement to binary)，将一个在$[-2^{w-1},2^{w-1}-1]$内的整数映射到一个唯一的$w$位位向量

![[CSAPP-Fig2.14.png|图2.14 几个重要的数值对应的不同字长下的比特模式]]
显然，补码表示的值域$[-2^{w-1},2^{w-1}-1]$不是对称的
($TMin_w = -2^{w-1},TMax_w = 2^{w-1}-1$，$|TMin| = |TMax| + 1$)
对于所有的$w$位的比特模式，采用补码解释时，一半的比特模式表示负数(最高有效位为1)，一半的比特模式表示非负数(最高有效位为0)，0为非负数，因此表示的正数的数量就比负数的数量少一

无符号表示的最大值$UMax$和补码表示的最大值$TMax$的关系是$UMax=2TMax+1$($2^w-1 = 2\times(2^{w-1} - 1) + 1$)

比特模式$[1\dots1]$，其无符号表示的值为$UMax$，其补码表示的值为$-1$
比特模式$[0\dots0]$，其无符号表示的值和补码表示的值都为$0$

C标准并未要求有符号数需要用补码表示法表示，不过几乎所有机器都采用补码表示法表示有符号数，因此以采用补码表示法表示有符号数为前提的代码也是在大多数机器和编译器上具有移植性的
C标准库中的文件 `<limits.h>` 为不同的整数型数据类型宏定义了一些边界量/定界常数，包括了 `INT_MAX` , `INT_MIN` , `UINT_MAX`  等，这些量的具体数值依据编译器运行于的机器而定
例如，在一个 `int` 类型用$w$位存储，并使用二进制补码表示法表示有符号数，使用无符号表示法表示无符号数的机器上，`INT_MAX` 对应$TMax_w$，`INT_MIN` 对应$TMin_w$，`UINT_MAX` 对应$UMax_w$

Java标准对整数型数据类型和表示形式非常具体，它要求使用补码表示法表示有符号数，并精确规定了各数据类型的范围(参照 [[Computer Systems A Programmer's Perspective#^525095|64位C程序中整数型数据类型的表示范围]])
Java中，单字节数据类型称为 `byte` 而不是 `char` 
这些详细要求使得Java程序具有良好的可移植性，其程序行为与具体的机器或操作系统无关

考虑以下代码
```c
short x = 12345;
short mx = -x;

show_bytes((byte_pointer) &x, sizeof(short));
show_bytes((byte_pointer) &mx, sizeof(short));
```
当在大端序的机器上运行该代码，输出为 `30 39` 和 `cf c7` ，说明了机器中 `x` 的十六进制表示是 `0x3039` ，而 `mx` 的十六进制表示是 `0xCFC7`
将其转化为二进制表示，我们得到 `x` 的比特模式是 `[0011000000111001]` ，`mx` 的比特模式是 `[1100111111000111]` 

参照图2.15，容易知道该机器使用了补码表示法表示有符号数
![[CSAPP-Fig2.15.png|图2.15 12345和-12345的补码表示以及53191的无符号表示]]

> ***Aside*** _More on fixed-size integer types_
> 对于某些程序，使用固定大小的数据类型是至关重要的，例如要编写使机器进行网络通讯的程序，程序中的数据类型就需要和标准协议指定的数据类型相兼容
   一些C数据类型，比如 `long` ，在不同的机器上具有不同的范围，而C标准只规定了任何数据类型的最小范围而非确切范围，因此使用这些数据类型的程序就没有可移植性方面的保障
   ISO C99标准在文件 `stdint.h` 引入了一类固定大小的整数数据类型，文件中定义了一系列名称形式为 `intN_t` , `uintN_t` 的数据类型，表示$N$位的有符号/无符号整型
   大多数编译器支持$N=8, 16, 32, 64$
   文件中还定义了一系列相关的定界量宏，名称的形式为 `INTN_MIN` , `INTN_MAX` , `UINTN_MAX` 
   要格式化输出固定大小的类型，也需要使用宏，这些宏会根据系统展开为相应的格式字符串，例如，要打印类型为 `int32_t` 的 `x` 和类型为 `uint64_t` 的 `y` ，则要使用 `printf("x = %" PRId32 ", y = %" PRIu64 "\n", x, y);`
   若程序作为64位程序编译，则宏 `PRId32` 会展开为字符串 `"d"` ，宏 `PRIu64` 会展开为字符串 `"l"` 和 `"u"` 
   而C的预处理程序在遇到只以空格分离的字符串常量时，会将其连接到一起，因此，实际运行的语句等价于 `printf("x = %d, y = %lu\n", x, y);`
   使用宏可以保证根据实际环境生成正确的格式字符串，提高程序的可移植性

> ***Aside*** _Alternative representations of signed numbers_
> 有符号数的表示还有两种方法：
> 1. 反码(ones' complemet)
> 反码表示法中，最高有效位的权重是$-(2^{w-1}-1)$(补码表示法中则是$-2^{w-1}$)$$B2O_w(\vec x)\doteq-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i$$2. 原码/符号值(sign magnitude)
> 原码表示法中，最高有效位只作为符号位(sign bit)，1代表负，0代表正$$B2S_w(\vec x)  \doteq (-1)^{x_{w-1}}\cdot\left(\sum_{i=0}^{w-2}x_i2_i\right)$$这两个表示法的共性是0有两种编码
> 反码表示法中，$[11\dots1]$表示$-0$，$[00\dots0]$表示$+0$
> 原码表示法中，$[10\dots0]$表示$-0$，$[00\dots0]$表示$+0$
> 过去存在用反码表示法表示有符号数的机器，但现代机器几乎都是用补码表示法表示有符号数
> 原码表示法主要用于表示浮点数
> 注意反码表示法和补码表示法名称中撇号 _'_ 的位置，一个是 _two's_ complement，一个是 ones' complement
> “_two's_ complement” 来源于对于一个补码表示的非负数 `x` ，`-x` 的$w$位补码表示是$2^w -x=[100\dots0]-x$(仅一个$2$)
> “_ones_' complement” 来源于对于一个反码表示的非负数 `x` ，`-x` 的$w$位反码表示是$[111\dots 1] - x$(多个$1$)

#### 2.2.4 Conversions between Signed and Unsigned
C允许不同数据类型转换
例如 `int` 类型的 `x` 的值可以通过表达式 `(unsigned) x` 转化为 `unsigned` 类型的值，`unsigned` 类型的 `u` 的值可以通过表达式 `(int) u` 转化为 `int`类型的值

代码
```c
short int v = -12345
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```
的运行结果是 `v = -123456, uv = 53191` ，而补码表示法中值 `-123456` 对应的比特模式和无符号表示法中值 `53191` 对应的比特模式确实是相同的，因此C在从 `short` 转化到 `unsigned short` 改变了数值，但未改变位表示(bit representation)

又例如代码
```c
unsigned u = 4294967295u; /* UMax */
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
```
的运行结果是 `u = 4292967295, tu = -1` ，$UMax_{32}$位表示是$[11\dots 1]$而在补码表示法下，$[11\dots 1]$的值则是$-1$，因此C在从 `unsigned int` 转化到 `int` 时同样未改变位表示

大多数C的实现在处理同字长的无符号类型的值和有符号类型的值之间的转换时都遵循这一通则：保持原来的位表示不变，只是改变对它的解释方式，以此改变数值

我们知道
函数$U2B_w$将$[0,UMax_w]$范围内的整数$x$转化为其对应的$w$位位向量，
函数$T2B_w$将$[TMin_w,TMax_w]$范围内的整数$x$转化为其对应的$w$位位向量
由此我们可以定义：
- 函数$T2U_w(x)\doteq B2U_w(T2B_w(x))$
	定义域$[TMin_x,TMax_w]$，值域$[0,UMax_w]$
	将一个在定义域内的有符号值转换为值域内的无符号值，这两个值有共同的位表示
- 函数$U2T_w(x)\doteq T2B_w(B2U_w(x))$
	定义域$[0,UMax_w]$，值域$[TMin_w,TMax_w]$
	将一个在定义域内的无符号值转换为值域内的有符号值，这两个值有共同的位表示
这两个函数的作用就是C中类型转化的效果

无符号值和有符号值拥有共同的位表示，它们之间显然存在关系，我们以函数$T2U$和函数$U2T$的性质表述

函数$T2U_w$的性质：
**Principle**: Conversion from two's complement to unsigned
对于在$[TMin_w,TMax_w]$内的$x$
$$T2U_w(x)=
\begin{cases}x + 2^w,&x<0\\
x,&x\ge0\end{cases}$$
该性质说明，在将有符号值转换为无符号值时，若它非负，则转换后保持不变，若它为负，则转换后的值比原来大$2^w$
例如
$T2U_{16}(-12345)=-12345 + 2^{16} = 54191$
$T2U_w(-1)=-1+2^w = 2^w-1=UMax_w$

该性质也可以用下图表示
![[CSAPP-Fig2.17.png|图2.17 有符号值向无符号值的转换]]

**Derivation**: Conversion from two's-complement to unsigned
对于一个$w$位位向量$\vec x$，
根据无符号表示法，它的无符号值$B2U_w(\vec x)$由
$\sum_{i=0}^{w-1} x_i2^i=x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$计算得到
根据补码表示法，它的有符号值$B2T_w(\vec x)$由
$-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$计算得到

而$B2U_w(\vec x)-B2T_w(\vec x)=x_{w-1}(2^{w-1} + 2^{w-1}) = x_{w-1}2^w$
即$B2U_w(\vec x)=B2T_w(\vec x) + x_{w-1}2^w$

令$B2T_w(\vec x) = x$，则$T2B_w(x)=\vec x$
故$T2U_w(x) = B2U_w(T2B_w(x))=B2U_w(\vec x) = B2T_w(\vec x) + x_{w-1}2^w = x + x_{w-1}2^w$
当$x_{w-1}=0$，$x= -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\ge0$，可知此时满足
$x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i = -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i = \sum_{i=0}^{w-2}x_i2^i$
无符号值和有符号值相同，即$T2U_w(x)=x$
当$x_{w-1}=1,x= -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i<0$，可知此时满足
$x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i - \left(-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\right)=2^{w-1}+2^{w-1}=2^w$
无符号值-有符号值=$2^w$，故无符号值=有符号值+$2^w$
即$T2U_w(x)=x+2^w$

$\vec x$的无符号值$B2U_w(\vec x)$和有符号值$B2T_w(\vec x)$中，$\sum_{i=0}^{w-1}x_i2^i$部分是相同的，差异在于补码表示法最高有效位的权重为$-2^{w-1}$，而无符号表示法最高有效位的权重为$2^{w-1}$

函数$U2T_w(u)$的性质：
**Principle**: Unsigned to two's-complement conversion
对于在$[0,UMax_w]$内的$x$
$$U2T_w(u)= \begin{cases}
u,&u\le TMax_w\\
u-2^w,&u\gt TMax_w \\
\end{cases}$$
其中$TMax_w=2^{w-1}-1$
该性质说明，在将有符号值转换为无符号值时，若它较小($\le TMax_w$)，则转换后保持不变，若它较大($>TMax_w$)，则转换后的值比原来小$2^w$
例如
$U2T_w(2^{w-1}) = 2^{w-1}-2^w=-2^{w-1}$
$U2T_w(2^{w-1}-1) = 2^{w-1}-1$

该性质也可以用下图表示
![[CSAPP-Fig2.18.png|图2.18 无符号值向有符号值的转换]]

**Derivation**: Unsigned to two's-complement conversion
对于一个$w$位位向量$\vec u$，
根据无符号表示法，它的无符号值$B2U_w(\vec u)$由
$\sum_{i=0}^{w-1} u_i2^i=u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i$计算得到
根据补码表示法，它的有符号值$B2T_w(\vec u)$由
$-u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i$计算得到

而$B2U_w(\vec u)-B2T_w(\vec u)=u_{w-1}(2^{w-1} + 2^{w-1}) = u_{w-1}2^w$
即$B2T_w(\vec u)= B2U_w(\vec u)- u_{w-1}2^w$

令$B2U_w(\vec u) = u$，则$U2B_w(u)=\vec u$
故$U2T_w(x) = B2T_w(U2B_w(u))=B2T_w(\vec u) = B2U_w(\vec u)-u_{w-1}2^w= u-u_{w-1}2^w$

当$u_{w-1}=0$，$u= -u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i\le TMax_w$，可知此时满足
$u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i = -u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i = \sum_{i=0}^{w-2}u_i2^i$
无符号值和有符号值相同，即$U2T_w(u)=u$
当$u_{w-1}=1,u= u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i>TMax_w$，可知此时满足
$u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i - \left(-u_{w-1}2^{w-1}+\sum_{i=0}^{w-2}u_i2^i\right)=2^{w-1}+2^{w-1}=2^w$
无符号值-有符号值=$2^w$，故有符号值=无符号值-$2^w$
即$U2T_w(u)=u-2^w$

#### 2.2.5 Signed Versus Unsigned in C
C支持无符号数和有符号数的算数运算

C中默认声明的数都为有符号数，例如当声明一个常数为 `12345` 或 `0x1A2B`默认认为它们是有符号数，因此它们的位表示都采用的是补码表示
在数字后添加 `U` 或 `u` 的后缀表示声明的是无符号数，如 `12345u` 或 `0x1A2B` ，则它们的位表示采用的是无符号表示

C允许有符号数和无符号数之间的显式转换(explict casting)，例如
```c
int tx, ty;
unsigned ux, uy

tx = (int) ux;
uy = (unsigned) ty;
```
它保持位表示不变而改变值，我们在之前已经讨论过

C也允许有符号数和无符号数之间的隐式转换(implicit casting)，例如
```c
int tx, ty;
unsigned ux, uy

tx = ux; /* Cast to signed*/
uy = ty; /* Cast to unsigned*/
```
在对不同类型的变量进行赋值时，发生了隐式类型转换，它依然保持位表示不变而仅改变值

又例如
```c
int x = -1;
unsigned u = 2147483648; /* 2^31 */

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```
`printf` 函数根据对应的格式化字符解释变量的值，`%d` 表示十进制有符号数，`%u` 表示十进制无符号数，`%x` 表示十六进制形式
该程序输出
```text
x = 4294967295 = -1
u = 2147483648 = -2147483648
```
说明 `printf` 对于相同的位表示，根据格式字符串进行了不同的解释，发生了隐式的类型转换

又例如C在遇到一个运算符的两个操作数的类型分别为有符号数和无符号数时，也会隐式地将有符号值转化为无符号值，之后再执行操作
这会导致一些看上去反常的结果
![[CSAPP-Fig2.19.png|图2.19 表达式中的隐式类型转换]]
`0 == 0u` 中， `0` 被隐式转换为 `0u` ，表达式返回 `1`
`-1 < 0` 中，没有类型转换发生，表达式返回 `1`
`-1 < 0u` 中，`-1` 被隐式转换为$UMax_{32}$，表达式返回 `0`
`2147483647 > -2147483647-1` 中，没有类型转换发生，表达式返回 `1`
`2147483647U > -2147483647-1` 中，`-2147483647-1` 被转换为 `-2147483648U` ，表达式返回 `0`
`2147483647 > (int)2147483648U` 中，`2147483647U` 被显式转换为 `-2147483648` ，表达式返回 `1`
`-1 > -2` 中，没有类型转换发生，表达式返回 `1`
`(unsigned) -1 > -2` 中，`-1` 被显式转换为$UMax_{32}$，然后 `-2` 被隐式转换为$UMax_{32}-1$，表达式返回 `1`

#### 2.2.6 Expanding the Bit Representation of a Number
类型转换除了发生在无符号类型和有符号类型之间，也可能发生在同为无符号/有符号但宽度不同的类型之间

在C中，从宽度小的类型向宽度大的类型转换，会保持数值不变

对于无符号数，在宽度增大时，只需要添加前导零，就可以保持数值不变，该操作称为零延伸(zero extension)
**Principle**: Expansion of an unsigned number by zero extension
对于宽度为$w$的位向量$\vec u=[u_{w-1},u_{w-2},\dots,u_0]$和宽度为$w'$的位向量$\vec u'=[0,\dots,0,u_{w-1},u_{w-2},\dots,u_0]$，其中$w'>w$，有$$B2U_w(\vec u) = B2U_{w'}(\vec u')$$
对于有符号数，在宽度增大时，为了保持数值不变，需要添加和原最高有效位$x_{w-1}$相同的值，该操作称为符号延伸(sign extension)
**Principle**: Expansion of a two's-complement number by sign extension
对于宽度为$w$的位向量$\vec x=[x_{w-1},x_{w-2},\dots,x_0]$和宽度为$w'$的位向量$\vec x'=[x_{w-1},\dots,x_{w-1},x_{w-1},x_{w-2},\dots,x_0]$，其中$w'>w$，有$$B2T_w(\vec x) = B2T_{w'}(\vec x')$$

**Derivation**: Expansion of a two's-complement number by sign extension
当$x_{w-1}=0$，添加$k$个前导零显然对值没有影响
当$x_{w-1} = 1$，添加$k$个前导一，
位表示从$[1,x_{w-2},x_{w-3},\dots,x_0]$变为$[1,\dots,1,1,x_{w-2},x_{w-3},dots,x_0]$，
对于原来的位表示，它的值通过$-2^{w-1} + \sum_{i=0}^{w-2} x_i 2^i$计算得到
对于新的位表示，它的值通过$-2^{w'-1} + \sum_{i=w}^{w'-2}2^i + 2^{w-1}+\sum_{i=0}^{w-2}x_i2_i$
而$$\begin{aligned}
&-2^{w'-1} + \sum_{i=w}^{w'-2}2^i + 2^{w-1}\\
=& -2^{w'-1} + \sum_{i=w-1}^{w'-2}2^i\\
=& -2^{w'-1} + \frac {2^{w'-1}-2^{w-1}}{2-1}\\
=&-2^{w-1}
\end{aligned}$$因此旧的位表示和新的位表示的值是相同的

也可以用归纳法来推导：
令$w' = w + k$
我们需要证明的是
$B2T_{w+k}([x_{w-1},\dots,x_{w-1},x_{w-1},x_{w-2},\dots x_0])=B2T_w([x_{w-1},x_{w-2},\dots,x_0])$
我们可以令$k=1$，先证明
$B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\dots,x_0])=B2T_w([x_{w-1},x_{w-2},\dots,0])$
我们将等式左边展开
$$\begin{aligned}B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\dots,x_0])&=-x_{w-1}2^w+\sum_{i=0}^{w-1}x_i2^i\\
&=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\
&=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\
&=B2T_w([x_{w-1},x_{w-2},\dots,0])
\end{aligned}$$
由此归纳得到$B2T_{w+k} = B2T_{w+k-1}=\cdots=B2T_{w+1}=B2T_{w}$

代码
```c
short sx = -12345; /* -12345 */
unsigned short usx = sx; /* 53191 */
int x = sx; /* -12345 */
unsigned ux = usx; /* 53191 */

printf("sx = %d:\t", sx);
show_bytes((byte_pointer) &sx, sizeof(short));
printf("usx = %u:\t", usx);
show_bytes((byte_pointer) &usx, sizeof(unsigned short));
printf("x = %d:\t", x);
show_bytes((byte_pointer) &x, sizeof(int));
printf("ux = %u:\t", ux);
show_bytes((byte_pointer) &ux, sizeof(unsigned));
```
在大端序机器上的运行结果是
```text
sx  = -12345:   cf c7
usx = 53191:    cf c7
x   = -12345:   ff ff cf c7
ux  = 53191:    00 00 cf c7
```
可以看到C语言在同宽度的有符号数和无符号数之间的转化时保持了位模式不变，在对有符号数进行拓宽时，采用了符号延伸，添加了16位1，即`0xFFFF` ，而在对无符号数进行拓宽时，采用了零延伸，添加了16位0，即 `0x0000`

值得注意的是，在执行类型转换时，如果既要执行有符号数和无符号数之间的转换，又要执行数据宽度的拓宽时，转换执行的顺序是先执行数据宽度的拓宽，然后执行有符号数和无符号数之间的转换
例如
```c
short sx = -12345; /* -12345 */
unsigned uy = sx;

printf("uy = %u:\t", uy);
show_bytes((byte_pointer) &uy, sizeof(unsigned));
```
在大端序的机器上运行时，程序的结果是
```text
uy = 4294954951:    ff ff cf c7
```
说明程序在运行时先通过符号延伸，将位模式从 `0xcfc7` 转化为 `0xffcfc7` ，然后将有符号数转换为无符号数，保持位模式不变，即对于 `short` 类型的 `sx` ，表达式`(unsigned) sx` 的执行等价于 `(unsigned) (int) sx` ，因此最后的值是$-12345 + 2^{32}=4294954951$而不是 `(unsigned) (unsinged short) sx` (值为$-12345 + 2^{16}=53191$)

先拓宽宽度，改变位模式，然后保持位模式，进行有符号数和无符号数之间的转换，这个转换顺序是由C标准规定的

#### 2.2.7 Truncating Numbers
在将数据的类型从宽度更宽的类型向宽度更窄的数据类型转换时，需要减小位表示的宽度，例如
```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx; /* -12345 */
```
`x` 被声明为32位的 `int` 类型，它被赋值为 `53191` ，采用补码表示法，`x` 的位模式为 `00 00 cf c7` ，
表达式 `(short) x` 将 `x` 强制转化为16位的 `short` 的类型，因此会直接对位模式进行截断，丢弃前16位，留下后16位，则变量 `sx` 的位模式为 `cf c7` ，采用补码表示法，它的值为 `-12345`
语句 `int y = sx` 创建一个32位的 `int` 类型变量 `y` ， `sx` 在赋值给 `y` 之前，隐式地将类型转化为了 `int` ，宽度增大，为了保持数值不变，有符号数采用了符号延伸，在前16位填充原来的最高位有效位1，因此 `y` 的位模式是 `ff ff cf c7` ，采用补码表示法，它的值为 `-12345`

将一个$w$位的位模式$\vec x = [x_{w-1}, x_{w-2},\dots, x_0]$截断为$k$位时，我们直接丢弃最高的$w-k$位，保留最低的$k$位，得到$\vec x' = [x_{k-1}, x_{k-2},\dots, x_0]$
很显然，对位模式进行截断有可能会改变它相对应的值，
对于有符号值和无符号值，相同的截断操作可能会有不同的影响

**Principle**: Tuncation of an unsigned number
$\vec x = [x_{w-1}, x_{w-2},\dots, x_0]$，令$\vec x' = [x_{k-1},x_{k-2},\dots, x_0]$为将$\vec x$截断为$k$位得到的结果，令$x = B2U_w(\vec x),\ x' = B2U_k(\vec x')$，则$$x' = x\ mod\ 2^k$$
**Derivation**: Truncation of an unsigned number
$$\begin{aligned}
&x\ mod\ 2^k \\
=&B2U_w(\vec x)\ mod\ 2^k\\
=&B2U_w([x_{w-1},x_{w-2},\dots,x_0])\ mod\ 2^k\\
=&\left[\sum_{i=0}^{w-1}x_i2^i\right]\ mod\ 2^k\\
=&\left(\left[\sum_{i=k}^{w-1}x_i2^i\right]+\left[\sum_{i=0}^{k-1}x_i2^i\right]\right)\ mod\ 2^k\\
=&\left[\sum_{i=0}^{k-1}x_i2^i\right]\ mod\ 2^k\\
=&\sum_{i=0}^{k-1}x_i2^i\\
=&B2U_k([x_{k-1},x_{k-2},\dots,x_0])
\end{aligned}$$
推导中，我们利用了对于任意$i\ge k$，$2^i\ mod\ 2^k=0$这一性质，
因此，在截断时，我们丢弃了第$k$位到第$w-1$位，保留了第0位到第$k-1$位，也就是丢弃了权重大于等于$2^k$的位，保留了权重小于$2^k$的位，在数值上相当于把前$w-k$位都设为0，取模运算就可以表示将权重为$2^i,i\ge k$的位都设为0的操作
因此，截断操作在数值上的影响可以用取模运算表示

**Principle**: Truncation of a two's-complement number
$\vec x = [x_{w-1}, x_{w-2},\dots, x_0]$，令$\vec x' = [x_{k-1},x_{k-2},\dots, x_0]$为将$\vec x$截断为$k$位得到的结果，令$x = B2T_w(\vec x),\ x' = B2T_k(\vec x')$，则$$x' =U2T_k(x\ mod\ 2^k)$$
**Derivation**: Truncation of a two's-complement number
$$\begin{aligned}
&x\ mod\ 2^k \\
=&B2T_w(\vec x)\ mod\ 2^k\\
=&B2T_w([x_{w-1},x_{w-2},\dots,x_0])\ mod\ 2^k\\
=&\left[-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\right]\ mod\ 2^k\\
=&\left[\sum_{i=0}^{k-1}x_i2^i\right]\ mod\ 2^k\\
=&\sum_{i=0}^{k-1}x_i2^i\\
=&B2U_k([x_{k-1},x_{k-2},\dots,x_0])
\end{aligned}$$
因此$$\begin{aligned}
&U2T_k(x\ mod\ 2^k)\\
=&U2T_k\left(B2U_k([x_{k-1},x_{k-2},\dots,x_0])\right)\\
=&B2T_k([x_{k-1},x_{k-2},\dots,x_0])\\
=&B2T_k(\vec x')\\
=&x'
\end{aligned}$$
注意无论是有符号数还是无符号数，截断操作在位层面都是直接丢弃前$w-k$位，因此，余下的$k$位的位模式一定是$\vec x'=[x_{k-1},x_{k-2},\dots,x_0]$，
如果用无符号表示法，$\vec x'$对应的无符号值为$B2U_k(\vec x')=B2U_w(\vec x) = B2T_w(\vec x)$，即$x\ mod\ 2^k$，我们用函数$U2T_k(x\ mod\ 2^k)$将它转换为有符号值，即$\vec x'$对应的有符号值
函数$U2T_k$的作用实际上就是把最高有效位的权重从$2^{k-1}$变为$-2^{k-1}$

因此，对无符号数进行截断的效果为
$$B2U_k(\vec x') = B2U_w(\vec x)\ mod\ 2^k$$
对有符号数进行截断的效果为
$$B2U_k(\vec x')=U2T_k\left(B2T_w(\vec x)\ mod\ 2^k\right)=U2T_k\left(B2U_w(\vec x)\ mod\ 2^k\right)$$


#### 2.2.8 Advice on Signed versus Unsigned
有符号值和无符号值之间的隐式转换常常会在代码中引发不易察觉的问题，例如代码
```c
/* WARNING: This is a buggy code*/
float sum_elements(float a[], unsigned length){
	int i;
	float result = 0;

	for(i = 0; i <= length-1; i++)
		result += a[i];
	return result;
}
```
如果我们传入参数 `length = 0` ，我们预期的结果是返回 `0` ，然而实际上会发生内存错误，因为 `length` 的类型是32位无符号数 `unsigned` ，因此在计算 `length - 1` 时，实际返回的值是无符号值$UMax$，而任意的32位有符号数都小于$UMax$，因此循环没有停止条件，程序会访问无效的内存区域

将 `length` 声明为 `int` 或将 `i<=length-1` 改为 `i<length` 可以修复该bug

无符号数字类型和无符号运算(unsigned arithmetic)常常引发这类bug，因此一种可以避免这类bug的方法就是永远不使用无符号数字类型，事实上，除了C以外只有很少的语言支持无符号整数类型
Java仅支持有符号整数类型，并且要求它实行补码运算(two's-complement arithmetic)，并且右移运算符 `>>` 要求必须执行算数右移(arithmetic shift)，额外定义运算符 `>>>` 表示逻辑右移

但如果我们需要将变量仅仅视为比特模式而不对它进行数值解释(numeric interpretation)，无符号类型就起到了作用
例如我们用一个字的各个位作为标志位(flags)，表示布尔值，计算机内存地址也是无符号数

> ***Aside*** Security vunlerability in `getpeername`
> 2002年，FreeBSD开源OS项目的程序员发现了库函数 `getpeername` 的实现存在安全漏洞
> 简化的代码如下
```c
/*
 * Illustration of code vunlerability similar to that found in
 * FreeBSD's implementation of getpeername()
*/

/* Declaration of library function memcpy */
void *memcpy(void *dest, void *src, size_t n);

/* Kernel memeory region holding user-accessible data */
#define KSIZE 1024
char kbuf[KSIZE];

/* Copy at modt maxlen bytes from kernel region to ueser buffer */
int copy_from_kernel(void *user_dest, int maxlen){
	/* Byte count len is minimum of buffer size and maxlen */
	int len = KSIZE < maxlen ? KSIZE : maxlen;
	memcpy(user_dest, kbuf, len);
	reutnr len;
}
```
> `memcpy` 的作用是从 `src` 指定的地址拷贝 `n` 个字节的数据至 `dest` 指定的地址
> `copy_from_kernel` 的作用将部分由OS内核维护的、用户可访问的数据从内核区域拷贝至用户指定的区域
> 内核中的大部分信息包含了其他用户的信息以及系统中运行进程的信息，应该不是用户可访问的，但 `kbuf` 区域的信息则指定为用户可访问
> `len` 的值应为 `KSIZE` 和 `maxlen` 其中较小的值，即拷贝的字节数量不应超过 `user_dest` 指定的缓存的大小，也不应超过 `kbuf` 的大小
> 参数 `n` 的类型声明为 `size_t` ，在库文件 `stdio.h` 中，对于32位程序，`size_t` 被 `typedef` 为 `unsigned` ，对于64位程序，`size_t` 被 `typedef` 为 `unsigned long` 
> 因此参数 `n` 实际视为无符号数，而 `maxlen` 的类型则为 `int` ，因此如果我们传入 `maxlen` 为负整型如 `-1` ，则显然 `maxlen` 会赋值给 `len` ，而 `len` 会传给 `n` ，因此 `n` 实际会被视为$UMax$，因此 `memcpy` 函数会将大量的信息从内核拷贝至 `user_dest` (至少$2^{31}$字节)，拷贝这种数量的字节的操作实际上不会执行，因为很可能超过了进程可访问的虚拟内存空间范围，但存在风险
> FreeBSD发布了一条安全建议"FreeBSD-SA-02:38.signed-error"，建议系统管理员应用补丁修复该漏洞
> 可以通过将 `maxlen` 的类型声明为 `size_t` 修复该漏洞

### 2.3 Integer Arithmetic
#### 2.3.1 Unsigned Addition
考虑两个非负整数$x,y$，都用$w$位存储，
用无符号表示法表示其值，值域为$[0,2^w-1]$

因此$x+y$的值域为$[0,2^{w+1} -2]$
显然，要存储值域为$[0,2^{w+1}-2]$的无符号数，至少需要$w+1$位($w+1$位位向量的无符号表示值域为$[0, 2^{w+1}-1]$)

同理，如果我们用$w+1$位存储结果，那么两个$w+1$位的非负整数相加，其结果需要$w+2$位才能保证准确存储，这意味着如果想要完全表示算数操作(arithmetic operations)的所有结果，存储字长不能有限制
一些编程语言如Lisp支持任意长度算数(arbitrary size arithmetic)，允许用任意长的字长存储整数
但一般的编程语言仅支持固定长度算数(fixed size arithmetic)

定义运算符$+_w^u$
运算元为$w$位存储的无符号整数类型变量$x,y$(值域$[0,2^w-1]$)
$x +_w^uy=$将$x+y$的位模式截断至$w$位后，该位模式表示的无符号整数值(采用无符号表示法表示的值)

运算$x +_w^uy$实际等价于对$x+y$取$2^w$的模的模运算(modular arithmetic)
即$x +_w^uy = (x+y)\ mod\ 2^w$
因为对$2^w$取模等价于丢弃权重大于$2^{w-1}$的所有位，也即将$x+y$的位模式截断至$w$位

**Principle**: Unsigned addition
对于满足$0\le x, y\lt 2^w$的整数$x,y$
$$x+_w^uy=\begin{cases}
x + y,&0\le x+y<2^w\quad Normal\\
x + y - 2^w,&2^w\le x+y\lt 2^{w+1}\quad Overflow
\end{cases}$$
即未溢出时(结果在$w$位的无符号数表示范围内)，
无符号整数相加得到的值即为$x+y$
而溢出时(结果超出了$w$位的无符号数表示范围)，
无符号整数相加得到的值则为$x+y-2^w$

**Derivation**: Unsigned addition
- $0\le x+y<2^w$时，$x+y$在$w$位的无符号数表示范围$[0,2^{w-1}]$内，未溢出
	$x+y$的位模式在$[00\dots0]$到$[11\dots1]$的范围内($w$位)，第$w+1$位可以视为0，即权重为$2^w$的位值为0，丢弃这一位不会对值产生影响，
	因此$x +_w^uy = (x+y)\ mod\ 2^w = x+y$
- $2^w\le x+y<2^{w+1}$时，$x+y$超过了$w$位的无符号数表示范围，发生溢出
	$x+y$的位模式在$[100\dots0]$到$[111\dots0]$的范围内($w+1$位)，因此第$w+1$位值为1，丢弃这一位使得值减少了该位的权重值$2^w$，
	因此$x +_w^uy = (x+y)\ mod\ 2^w = x+y-2^w$

溢出(overflow)即指算数运算的结果超过了当前数据类型的字长的值表示范围
例如，对于$w$位的无符号整数类型加法运算，当结果$\ge 2^w$时就发生了溢出

C程序中，溢出不会被报告为错误，程序员需要自己判断溢出是否发生
**Principle**: Detecting overflow of unsigned addition
对于满足$0\le x, y \le UMax_w$的整数$x,y$，令$s\doteq x+_w^u y$，则
当且仅当$s < x$(或$s<y$，这两个判断条件是等价的)，计算发生溢出

**Derivation**: Detecting overflow of unsigned addition
显然$x+y \ge x,x+y\ge y$，因此如果未发生溢出，一定有
$s=x+y \ge x$和$s=x+y\ge y$
如果发生溢出，则$s = x+y-2^w$，而$x,y<2^w$，即$x-2^w<0,y-2^w<0$，故有$s = x + (y-2^w) < x$和$s = y+(x-2^w) < y$

我们知道运算$+_w^u$实际上等价于模$2^w$的模加法运算(modular addition)，而模加法运算实际上形成了一个阿贝尔群(abelian group)，阿贝尔群的性质是运算是可交换的(commutative)和可结合的(associative)，存在单位元素0(identitiy element)，以及每个元素都有其逆元
因此考虑运算$+_w^u$，对于每个满足$0\le x \le UMax_w$的元素$x$，都存在其逆元，记为$-_w^u x$，即$-_w^u x +_w^u x = 0$
**Principle**: Unsigned negation
对于满足$0\le x < 2^w$的整数$x$，记$x$关于$+_w^u$的逆元为$-_w^u x$，则
$$-_w^ux=\begin{cases}
x,&x=0\\
2^w-x,&x>0
\end{cases}$$

**Derivation**: Unsigned negation
当$x=0$，显然$0 +_w^u 0 = 0$，即$-_w^u x=0$
当$x>0$，首先确定$0<2^w-x < 2^w$，我们有
$x +_w^u (2^w-x)=(x + 2^w -x)\ mod\ 2^w=2^w\ mod\ 2^w = 0$，即$-_w^u x=2^w-x$

#### 2.3.2 Two's-Complement Addition
考虑两个有符号整数$x,y$，用$w$位存储
用补码表示法表示其值，值域为$[-2^{w-1},2^{w-1}-1]$

因此$x+y$的值域为$[-2^w,2^{w} -2]$
显然，要存储值域为$[-2^w,2^w-2]$的有符号数，至少需要$w+1$位($w+1$位位向量的补码表示值域为$[-2^w, 2^{w+1}-1]$)

可以发现相较于无符号数加法运算，有符号数加法运算除了可能向上溢出(结果太大)，也可能向下溢出(结果太小)

定义运算符$+_w^t$
运算元为$w$位存储的有符号整数类型变量$x,y$(值域$[-2^{w-1},2^{w-1}-1]$)
$x +_w^ty=$将$x+y$的位模式截断至$w$位后，该位模式表示的有符号整数值(采用补码表示法表示的值)

**Principle**: Two's-complement addition
对于满足$-2^{w-1}\le x, y\le 2^{w-1}-1$的整数$x,y$
$$x+_w^ty=\begin{cases}
x + y -2^w,&2^{w-1}\le x+y\quad Positive\ overflow\\
x + y,&-2^{w-1}\le x+ y< 2^{w-1}\quad Normal\\
x + y + 2^w,& x+y\lt -2^{w-1}\quad Negative\ overflow
\end{cases}$$
即未溢出时(结果在$w$位的无符号数表示范围内)，
无符号整数相加得到的值即为$x+y$
而溢出时(结果超出了$w$位的无符号数表示范围)，
无符号整数相加得到的值则为$x+y-2^w$

**Derivation**: Two's-complement addition
- $-2^{w-1}\le x+y<2^{w-1}$时，$x+y$在$w$位的有符号数表示范围$[-2^{w-1},2^{w-1}-1]$内，未溢出
	若$x+y$为负数，$x+y$的位模式在$[11\dots1]$($w$位)到$[110\dots0]$($w+1$位)范围内，截断后值不变
	若$x+y$为非负数，$x+y$的位模式在$[100\dots0]$($w+1$位)到$[01\dots1]$范围内($w$位)，截断后值不变
	因此$x +_w^ty = x+y$
- $2^{w-1}\le x+y$时，$x+y$超过了$w$位的有符号数表示范围，发生上溢
	要发生上溢，一定满足$x,y>0$，即$x,y$的位模式都在$[00\dots1]$到$[01\dots1]$的范围内($w$位)
	因此$x+y$的位模式在$[010\dots0]$到$[011\dots0]$的范围内($w+1$位)，第$w+1$位值为0，丢弃这一位使得第$w$位的权重值从$2^{w-1}$变为$-2^{w-1}$，值减少了$2^w$
	因此$x +_w^uy = x+y-2^w$
	观察位模式可以发现，上溢时，第$w$位的值一定是1，因此截断后，其表示的有符号数一定是负数，范围是$[-2^{w-1},-2]$
- $x+y<-2^{w-1}$时，$x+y$超过了$w$位的有符号数表示范围，发生下溢
	要发生下溢，一定满足$x,y<0$，即$x,y$的位模式都在$[11\dots1]$到$[10\dots0]$范围内($w$位)
	因此$x+y$的位模式在$[101\dots1]$到$[100\dots0]$范围内($w+1$位)，第$w+1$位值为1，丢弃这一位使得值增加了第$w+1$位的权重值，即增加了$2^w$
	因此$x +_w^uy = x+y+2^w$
	观察位模式可以发现，下溢时，第$w$位的值一定是0，因此截断后，其表示的有符号数一定是非负数，范围是$[0,2^{w-1}-1]$

当数据用无符号表示法表示，执行加法运算时采用无符号加法(unsigned addition)规则，当数据用补码表示法表示时，执行加法运算时采用补码加法(two's-complement addition)规则，但无论时无符号加法还是补码加法，处理器实际执行的都是二进制加法，即对数据的二进制表示逐位对齐，逐位相加，逢2进1，并丢弃第$w+1$位，实际上，大多数计算机系统中无符号加法和补码加法执行的是同一机器指令

因此，我们可以通过将运算符$+_w^t$的运算元先转化为无符号值(这不会改变位模式)，执行无符号加法(运算元的位模式相同时，无符号加法得到的位模式和补码加法得到的位模式是相同的)，再将结果值转化回有符号值，即$$x+_w^ty=U2T_w(T2U_w(x)+_w^uT2U_w(y))$$
其中，$T2U_w(x)=x_{w-1}2^w+x,T2U_w(y)=y_{w-1}2^w+y$，因此有
$$\begin{aligned}x+_w^ty&=U2T_w(T2U_w(x)+T2U_w(y))\\
&=U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y)\ mod\ 2^w]\\
&=U2T_w[(x+y)\ mod\ 2^w]
\end{aligned}$$
我们令$z\doteq x+y,z'\doteq z\ mod\ 2^w,z''\doteq U2T_w(z')$
因此$x+_w^t y = U2T_w(z\ mod\ 2^w)= U2T_w(z') = z''$
根据$z = x+y$的取值，我们分四种情况分析
1. $-2^w\le z < -2^{w-1}$时，发生下溢
	$z' = z\ mod\ 2^w = z + 2^w$
	(令$z\ mod\ 2^w = t$，则$z = -1\times 2^w + t$，即$t = z + 2^w$)
	故$0\le z' < 2^{w-1}$
	故$z''= U2T_w(z') = z'$($0\le z''<2^{w-1}$)
	即$x+_w^t y=z''=z'=z+2^w=x+y+2^w$
	在下溢时，我们对两个负数进行加法(只有$x,y$都为负数，$x+y$才能小于$-2^{w-1}$)，得到的结果是非负值$x+y+2^w$
2. $-2^{w-1}\le z < 0$时，没有溢出
	$z' = z\ mod\ 2^w = z + 2^w$
	(令$z\ mod\ 2^w = t$，则$z = -1\times 2^w + t$，即$t = z + 2^w$)
	故$2^{w-1}\le z' < 2^{w}$
	故$z''=U2T_w(z') = z'-2^w$
	即$x+_w^t y=z''=z'-2^w=z+2^w-2^w=x+y$
- $0\le z <2^{w-1}$时，没有溢出
	$z' = z\ mod\ 2^w = z$
	故$0\le z' < 2^{w-1}$
	故$z''=U2T_w(z') = z'$
	即$x+_w^t y=z''=z'=z=x+y$
- $2^{w-1}\le z < 2^w$时，发生上溢
	$z' = z\ mod\ 2^w = z$
	故$2^{w-1}\le z' < 2^{w}$
	故$z''=U2T_w(z') = z'-2^w$($-2^{w-1}<z''<0$)
	即$x+_w^t y=z''=z'-2^w=z-2^w=x+y-2^w$
	在下溢时，我们对两个正数进行加法(只有$x,y$都为正数，$x+y$才能大于$2^{w-1}$)，得到的结果是负值$x+y-2^w$
	

**Principle**: Detecting overflow in two's-complement addition
对于满足$TMin_w\le x, y \le TMax_w$的整数$x,y$，令$s\doteq x+_w^t y$，则
当且仅当$x>0,y>0$且$s < 0$时，计算发生上溢
当且仅当$x<0,y<0$且$s\ge 0$时，计算发生下溢

**Derivation**: Detecting overflow in two's-complement addition
发生上溢时，$x + y \ge 2^{w-1}$，因为$TMax_w = 2^{w-1}-1$，故显然$x,y>0$
而$z'' = x+y-2^w\in[-2^{w-1},-2]$为负数
发生下溢时，$x+y < -2^{w-1}$，因为$TMin_w = -2^{w-1}$，故显然$x,y<0$
而$z'' = x+y+2^w\in[0,2^{w-1}-1]$为非负数



我们知道运算$+_w^u$实际上等价于模$2^w$的模加法运算(modular addition)，而模加法运算实际上形成了一个阿贝尔群(abelian group)，阿贝尔群的性质是运算是可交换的(commutative)和可结合的(associative)，存在单位元素0(identitiy element)，以及每个元素都有其逆元
因此考虑运算$+_w^u$，对于每个元素$x$，都存在其逆元，记为$-_w^u x$，即
$-_w^u x +_w^u x = 0$
**Principle**: Unsigned negation
对于满足$0\le x < 2^w$的整数$x$，记$x$关于$+_w^u$的逆元为$-_w^u x$，则
$$-_w^ux=\begin{cases}
x,&x=0\\
2^w-x,&x>0
\end{cases}$$

**Derivation**: Unsigned addition
当$x=0$，显然$0 +_w^u 0 = 0$，即$-_w^u x=0$
当$x>0$，首先确定$0<2^w-x < 2^w$，我们有
$x +_w^u (2^w-x)=(x + 2^w -x)\ mod\ 2^w=2^w\ mod\ 2^w = 0$，即$-_w^u x=2^w-x$

#### 2.3.3 Two's-Complement Negation
考虑运算$+_w^t$，对于每个满足$TMin_w\le x \le TMax_w$的元素$x$，都存在其逆元，记为$-_w^t x$，即$-_w^t x +_w^t x = 0$
**Principle**: Two's-complement negation
对于满足$TMin_w\le x \le TMax_w$的整数$x$，记$x$关于$+_w^t$的逆元为$-_w^t x$，则
$$-_w^tx=\begin{cases}TMin_w,&x=TMin_w\\
-x,&x>TMin_w\end{cases}$$
对于运算$+_w^t$，$TMin_w$的逆元是它自己，而其余元素的逆元是其相反数

**Derivation**: Two's-complement negation
直接根据补码运算的规则进行推导，
当$x = TMin_w = -2^{w-1}$，$x + x = -2^w$向下溢出，因此$x +_w^t x = (x + x) + 2^w = 0$
故$x$是$x$的逆元
当$x > TMin_w$，因为$x$满足$TMin_w < x \le TMax_w$，可知$-TMax_w\le x\lt TMin_w$，即$-x$也在$w$位补码表示法的表示范围内($-x$也是群内的元素)，将$x$与$-x$两个元素进行补码加法运算，因为$x + (-x) = 0$，未溢出，故$x +_w^t (-x) = x + (-x) = 0$，故$-x$是$x$的逆元

无符号加法运算和补码加法运算中，每个元素都有自己相对应的逆元，因此
$x -_w^u y$的运算可以直接定义成$x +_w^u (-_w^uy)$
$x -_w^t y$的运算可以直接定义成$x +_w^t (-_w^ty)$
即减去一个元素等价于加上该元素的逆元，由此利用已经定义了的加法运算的规则定义了减法运算

用运算$+_w^u$定义运算$-_w^u$：
对于满足$0\le x, y\lt 2^w$的整数$x,y$
当$y=0$，$x -_w^u y = x+_w^u(-_w^uy)= x +_w^u 0=x$
当$y>0$，$$\begin{aligned}x -_w^u y = x+_w^u(-_w^uy)&= x +_w^u (2^w-y)\\&=(x-y+2^w)\ mod\ 2^w\\
&=\begin{cases}x-y,&x-y\ge0\\
x-y+2^w,&x-y<0
\end{cases}\end{aligned}$$因为$y=0$时满足$x-_w^u y = x-y$且$x-y\ge0$
故综合两种情况可得
$$x-_w^uy=\begin{cases}x-y,&x-y\ge0\\
x-y+2^w,&x-y<0
\end{cases}$$
运算$-_w^u$不会向上溢出($x-y$的值不可能超过$2^w-1$)，但可能产生向下溢出($x<y$时)
向下溢出时，$x-_u^wy = x-y+2^w=x+(2^w-y) > x$，
因此若我们得到的差大于被减数时，可以判断无符号减法发生了溢出，
或者说$x-y<0$但得到的值大于0时，可以判断发生了溢出
或者说$x<y$时，可以判断发生了溢出

用运算$+_w^t$定义运算$-_w^t$：
对于满足$-2^{w-1}\le x, y\lt 2^{w-1}$的整数$x,y$
当$y=TMin_w$，$$\begin{aligned}x -_w^t y = x+_w^t(-_w^ty)&= x +_w^t y\\
&=\begin{cases}
x+y=x-2^{w-1},&x\ge0\quad 未溢出\\
x+y+2^w=x+2^{w-1},&x\lt0\quad 下溢
\end{cases}
\end{aligned}$$
因此，也可以视为
$$x-_w^ty=\begin{cases}
x+y=x-y-2^w,&x\ge0\quad上溢\\
x-y,&x\lt0\quad未溢出
\end{cases}$$
当$y>TMin_w$，$$\begin{aligned}
x -_w^t y = x+_w^t(-_w^ty)&= x +_w^t(-y)\\
&=\begin{cases}
x - y -2^w,&2^{w-1}\le x-y\quad上溢\\
x - y,&-2^{w-1}\le x- y< 2^{w-1}\quad未溢出\\
x - y + 2^w,& x-y\lt -2^{w-1}\quad下溢
\end{cases}
\end{aligned}$$
故综合两种情况可得：
$$x-_w^ty=\begin{cases}
x - y -2^w,&2^{w-1}\le x-y\quad上溢\\
x - y,&-2^{w-1}\le x- y< 2^{w-1}\quad未溢出\\
x - y + 2^w,& x-y\lt -2^{w-1}\quad下溢
\end{cases}$$
运算$-_w^t$可能向上溢出($x-y\ge2^{w-1}$时)，可能向下溢出($x-y<-2^{w-1}$时)，也可能不发生溢出($-2^{w-1}\le x- y< 2^{w-1}$时)
向上溢出时，$x-y\ge2^{w-1}$，则要求$x\ge0,y<0$，而$x-_w^ty = x-y-2^w=x-(2^w+y)<0$
因此当$x\ge0,y<0$($x-y>0$)，但我们得到的值小于0时，可以判断发生了上溢
向下溢出时，$x-y<-2^{w-1}$，则要求$x<0,y>0$，而
$x-_w^ty = x-y+2^w=x+(2^w-y)>0$
因此当$x<0,y>0$($x-y<0$)，但我们得到的值大于0时，可以判断发生了下溢

在位操作层面，无论变量 `x` 是无符号类型的整数还是有符号类型的整数，无论它的值是多少，获取它的逆的位模式的操作都是一样的：将原来位模式的各位取反再加1

> ***Web Aside DATA: TNEG*** _Bit-level representation of two's-complement negation_
> 对于一个位模式，要得到它相对于补码加法的逆，有两种常用的方法
> 其中一种方式是将各位取反/求补然后加一(complement the bits and then increment the result)
> 例如，对于 `0xfffffffa` ，我们知道 `0xf` ( `1111`)的补(各位取反)是 `0x0` (`0000`)，而 `0xa` 的补是 `0x5` ，因此 `0xfffffffa` 取反再加一得到 `0x00000006` ，该位模式是$6$的补码表示，因此 `0xfffffffa` 是$-6$的补码表示
> 在C中，我们可以验证对于任意的整型值 `x` ，表达式 `-x` 和表达式 `~x+1` 的值是相同的
> 另一种方式是以位模式最右端的$1$的位置为界(设为$k$)，先将位模式分为两部分，因此，我们将 `x` 的位模式写为$[x_{w-1},x_{w-2},\dots,x_{k+1},1,0,\dots,0]$的形式(该形式对所有的 `x!=0` 都成立)，则 `-x` 的位模式是$[\textasciitilde x_{w-1},\textasciitilde x_{w-2},\dots,\textasciitilde x_{k+1},1,0,\dots,0]$即对位置$k$左边的所有位取反/求补即可，位置$k$及其右边的位保持不变

#### 2.3.4 Unsigned Multiplication
对于$0\le x, y \le 2^{w}-1$的$w$位无符号整数$x,y$，它们的乘积$x\cdot y$的范围是$[0, (2^w -1)^2]$，即$[0,2^{2w}-2^{w+1}+1]$，这个范围的无符号整数需要$2w$位以表示
($2w$位的位模式的无符号数表示范围是$[0,2^{2w}-1]$，
显然$2^{2w}-1 > 2^{2w} - 2^{w+1} + 1$，故$2w$位的位模式足以表示这个范围的无符号整数
$2w-1$位的位模式的无符号数表示范围是$[0,2^{2w-1}-1]$，$2^{2w} - 2^{w+1 } + 1 = (2^{2w-1} - 1) + (2^{2w-1} - 2^{w+1} + 2) \ge 2^{2w-1}-1$，
因此$2w-1$位不足以表示这个范围的无符号整数)

而在C中，无符号数乘法的得到的$2w$位位模式同样会经过截断，只留下低$w$位，因此结果值也就是低$w$位所表示的无符号整数值，我们定义运算$x*_w^u y$表示这一过程

对于一个无符号表示的数，将它的位模式截断至只留下低$w$位等价于将位权重高于$2^{w}$的位全部丢弃/置零，因此结果值等于对原值采取模$2^w$运算
**Principle**: Unsigned multiplication
对于满足$0\le x, y \le UMax_w$的整数$x,y$
$$x *_w^uy = (x\cdot y)\ mod\ 2^w$$

#### 2.3.5 Two's-Complement Multiplication
对于$-2^{w-1}\le x, y \le 2^{w-1}-1$的$w$位有符号整数$x,y$，它们的乘积$x\cdot y$的范围是$[-2^{w-1}\cdot(2^{w-1}-1), (-2^{w-1})\cdot(-2^{w-1})]$，即$[-2^{2w-2}+2^{w-1},2^{2w-2}]$，这个范围的有符号整数需要$2w$位以表示
($2w$位的位模式的有符号数表示范围是$[-2^{2w-1},2^{2w-1}-1]$，
显然$2^{2w-1}-1 \ge 2^{2w-2}$且$-2^{2w-1}< -2^{2w-2} + 2^{w-1}$，
故$2w$位的位模式足以表示这个范围的无符号整数
$2w-1$位的位模式的有符号数表示范围是$[-2^{2w-2},2^{2w-2}-1]$，
显然$2^{2w-2}-1 < 2^{2w-2}$，
因此$2w-1$位不足以表示这个范围的无符号整数)

在C中，有符号数乘法的得到的$2w$位位模式同样会经过截断，只留下低$w$位，因此结果值也就是低$w$位所表示的有符号整数值，我们定义运算$x*_w^t y$表示这一过程

**Principle**: Bit-level equivalence of unsigned and two's-complement multiplication
$\vec x, \vec y$为长度为$w$的位向量，
令$x = B2T_w(\vec x), y = B2T_2(\vec y)$，令$x' = B2U_w(\vec x), y' = B2U_w(\vec y)$，则
$$T2B_w(x*_w^ty)=U2B_w(x'*_w^uy')$$
该性质说明$x*_w^ty$的位表示和$x'*_w^u$的位表示是相同的
对于两个$w$位的位模式$\vec x, \vec y$，执行无符号乘法(unsigned multiplication)和执行有符号乘法(two's-complement multiplication)，得到乘积的$2w$位的位模式的高$w$位可能会不同，但其低$w$位是相同的，因此执行截断操作后的位模式是相同的
因此，我们可以利用无符号乘法运算$*_w^u$，借助其乘积的低$w$位表示相同的性质，表示有符号乘法运算$*_w^t$

**Derivation**: Bit-level equivalence of unsigned and two's-complement multiplication
$\vec x, \vec y$为长度为$w$的位向量，
令$x = B2T_w(\vec x), y = B2T_2(\vec y)$，令$x' = B2U_w(\vec x), y' = B2U_w(\vec y)$
则$x' = x_{w-1}2^w + x, y' = y_{w-1}2^w + y$，而
$$\begin{aligned}
(x'\cdot y')\ mod\ 2^w &=\left[(x_{w-1}2^w+x)\cdot(y_{w-1}2^w+y)\right]\ mod\ 2^w\\
&=\left[x\cdot y + (x_{w-1}y + y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}\right]\ mod\ 2^w\\
&=(x\cdot y)\ mod\ 2^w
\end{aligned}$$
即$(x'\cdot y')\ mod\ 2^w =(x\cdot y)\ mod\ 2^w$，因此无论是执行有符号乘法还是无符号乘法，其乘积在丢弃了位权重大于$2^w$的位后(截断至低$w$位)，其值是相同的，而无符号表示和有符号表示的低$w$位的各位权重也是相同的，因此位表示是相同的
因此$(x\cdot y)\ mod\ 2^w=T2B_w(x*_w^ty)=U2B_w(x'*_w^uy')=(x'\cdot y')\ mod\ 2^w$

**Principle**: Two's-complement multiplication
对于满足$TMin_w\le x,y\le TMax_w$的整数$x,y$
$$x *_w^ty = U2T_w((x\cdot y)\ mod\ 2^w)$$
利用之间的结论，我们知道
$$\begin{aligned}(x\cdot y)\ mod\ 2^w = \left(T2U_w(x)\cdot T2U_w(y)\right)\ mod\ 2^w &= (x'\cdot y')\ mod\ 2^w
=x'*_w^uy'\\
\end{aligned}$$
故
$$\begin{aligned}
U2T_w((x\cdot y)\ mod\ 2^w) &= U2T_w(x'*_w^uy')\\
&=B2T_w(U2B_w(x'*_w^uy'))\\
&=B2T_w(T2B_w(x*_w^ty))\\
&=x*_w^ty
\end{aligned}$$
即要得到有符号乘法的结果值，可以先将有符号值转化为无符号值，然后执行无符号乘法，再将得到的无符号乘法结果值转化为有符号值，即得到有符号乘法结果值

整数乘法运算并没有像加减法运算一样形成一个阿贝尔群(在群内 `(x + y) - x == y` 是恒成立的)，因此可以直接使用 `(x * y) / x == y` 的逻辑判断是否发生溢出
```c
/* Determine whether arguments can be multiplied without overflow */
int tmult_ok(int x, int y) {
	int p = x*y;
	/* Either x is zero, or dividing p by x gives y */
	return !x || p/x == y;
}
```

如果不使用除法，也可以利用类型转换判断溢出(截断前后值是否相同)
```c
/* Determine whether the arguments can be multiplied without overflow */
int tmul_ok(int x, int y){
	/* Compute product without overflow */
	int64_t pll = (int64_t) x*y;
	/* See if casting to int perserve value */
	return pll == (int) pll;
/* 注意 int64_t pll = (int64_t) x*y 不能写为 int64_t pll = x*y，否则执行顺序是先乘法运算，然后截断，然后做符号拓展，因此有溢出时pll存储的也是溢出后的值，判断条件 pll == (int) pll 永真 */
}
```

> ***Aside*** _Security vunlerability in the XDR library_
> 2002年，由Sun Microsystems实现的XDR库中的一个广泛用于在程序之间共享数据结构的函数被发现了安全漏洞
```c
/* Illustration of code vunlerability similar to that found in
 *  Sun's XDR library.
 */
void* copy_element(void *ele_src[], int ele_cnt, size_t ele_size){
	/*
	 * Allocate buffer for ele_cnt objects, each of ele_size bytes
	 * and copy from locations designated by ele_src
	 */
	 void *result = malloc(ele_cnt * ele_size);
	 if (result == NULL)
		 /* malloc failed */
		 return NULL;
	 void *next = result;
	 int i;
	 for (i = 0; i < ele_cnt; i++){
		/* Copy object i to destination */
		memecpy(next, ele_src[i], ele_size);
		/* Move pointer to next memeory region */
		next += ele_size;
	 }
	 return result;
}
```
> 安全漏洞源于乘法运算 `ele_cnt * ele_size` 可能会溢出
> 例如当 `ele_cnt = 1046577(2^20+1)` ，而 `ele_size = 4096(2^12)` ，且该程序被编译为32位程序时，则乘法 `ele_cnt * ele_size` 会发生溢出，导致 `result = 4096` 而非 `1046577 * 4096 = 4294971392`
> 因此 `malloc` 分配的内存大小远远小于需要的内存大小，在之后 `for` 循环中程序会访问未定义的内存区域，污染其他的数据结构，可能导致程序崩溃等问题
> Sun's的代码应用范围非常广泛，包括了Internet Explorer和Kerberos安全认证系统，因此在发现这个bug后，The Computer Emergency Response Team(CERT)发布了建议“CA-2002-25”
> `calloc` 函数的许多实现也有类似的bug
> 如果要用运算表达式作为 `malloc` 函数的参数，就需要检查运算是否溢出
> 而对于当前的bug，一个可行的修改方案如下
```c
uint64_t required_size = ele_cnt * (uint64_t) ele_size;
size_t request_size = (size_t) required_size;
if (required_size != request_size)
/* Overflow must have occurred. Abort operation */
	return NULL;
void *result = malloc(request_size);
if (result == NULL)
/* malloc failed */
	return NULL;
```
>  `malloc` 函数的参数类型是 `size_t` ，即对于32位程序 `malloc` 最多只能分配$2^{32}$的字节数量的内存，因此如果需要的字节数量发生溢出，程序需要直接中断

#### 2.3.6 Multiplying by Constants
历史上，大多数机器上的整数乘法指令(integer multiply instruction)的执行都相当缓慢，大约需要10个或更多的时钟周期
而其他的整数运算如加法、减法、位级运算和移位(addition, substraction, bit-level operations, shifting)的执行只需要1个时钟周期

即使在Intel Core i7 Haswell上，整数乘法也需要3个时钟周期
因此，编译器对源码的一个重要优化就是试图用常数个移位和加法运算的组合以替代乘法运算(replace multiplications by constant factors with combinations of shift and addition operations)

**Principle**: Multiplication by a power of 2
$x$为有/无符号整数，其位模式($w$位)是$[x_{w-1},x_{w-2},\dots,x_0]$，
则对任意$k\ge 0$，$x2^k$的位模式($w+k$位)表示为$[x_{w-1},x_{w-2},\dots,x_0,0,\dots,0]$，
即在原来的位模式后添加$k$个$0$，或者说将原来的位模式左移$k$位且不做截断

**Derivation**: Multiplication by a power of 2
若$x$为无符号整数
$$\begin{aligned}
B2U_w([x_{w-1},x_{w-2},\dots,x_0,0\dots,0]) &=\sum_{i=0}^{w-1}x_i2^{i+k}\\
&=2^k\left[\sum_{i=0}^{w-1}x_i2^i\right]\\
&=x2^k
\end{aligned}$$
若$x$为有符号整数
$$\begin{aligned}
B2T_w([x_{w-1},x_{w-2},\dots,x_0,0\dots,0]) &=-x_{w-1}2^{w+k-1}+\sum_{i=0}^{w-2}x_i2^{i+k}\\
&=\left[-x_{w-1}2^{w-1}\sum_{i=0}^{w-1}x_i2^i\right]2^k\\
&=x2^k
\end{aligned}$$

**Principle**: Unsigned Multiplication by a power of 2
对于C变量 `x` , `k` (变量 `x` 的值为无符号整数$x$，变量 `k` 的值为无符号整数$k$，且$0\le k \lt w$)，C表达式 `x<<k` 的值是$x*_w^u 2^k$

推导：
设$x$对应的位模式($w$位)是$[x_{w-1},x_{w-2},\dots,x_0]$，即$B2U_w([x_{w-1},x_{w-2},\dots,x_0]) = x$

表达式 `x<<k` 执行的操作是将$x$的位模式左移$k$位(固定字长)
因此得到的结果位模式($w$位)是$[x_{w-k-1},x_{w-k-2},\dots,x_0,0\dots,0]$，
它来源于将原位模式左移$k$位后得到的$w+k$位的位模式$[x_{w-1},x_{w-2},\dots,x_0,0,\dots,0]$
(根据之前的推导，可知这是$x2^k$的位模式)截断至$w$位

运算$x*_w^u 2^k$执行的操作是先计算得到$x2^k$的位模式，然后截断至$w$位
因此得到的结果位模式($w$位)仍是$[x_{w-k-1},x_{w-k-2},\dots,x_0,0\dots,0]$，
它来源于将计算结果$x2^k$的$w+k$位的位模式$[x_{w-1},x_{w-2},\dots,x_0,0,\dots,0]$截断至$w$位

因此无论是移位还是乘法，在二进制层面，其执行的操作结果都是等价的，即先得到$x2^k$的$w+k$位的位模式，然后将其截断至$w$位
因此对于无符号整数，和常数$2^k$做无符号乘法等价于将其位模式左移$k$位(固定字长)

**Principle**: Two's-complement Multipllication by a power of 2
对于C变量 `x` , `k` (变量 `x` 的值为有符号整数$x$，变量 `k` 的值为无符号整数$k$，且$0\le k \lt w$)，C表达式 `x<<k` 的值是$x*_w^t 2^k$

推导：
设$x$对应的位模式($w$位)是$[x_{w-1},x_{w-2},\dots,x_0]$，即$B2T_w([x_{w-1},x_{w-2},\dots,x_0]) = x$

表达式 `x<<k` 执行的操作是将$x$的位模式左移$k$位(固定字长)
因此得到的结果位模式($w$位)是$[x_{w-k-1},x_{w-k-2},\dots,x_0,0\dots,0]$，
它来源于将原位模式左移$k$位后得到的$w+k$位的位模式$[x_{w-1},x_{w-2},\dots,x_0,0,\dots,0]$
(根据之前的推导，可知这是$x2^k$的位模式)截断至$w$位

运算$x*_w^t 2^k$执行的操作是先计算得到$x2^k$的位模式，然后截断至$w$位
因此得到的结果位模式($w$位)仍是$[x_{w-k-1},x_{w-k-2},\dots,x_0,0\dots,0]$，
它来源于将计算结果$x2^k$的$w+k$位的位模式$[x_{w-1},x_{w-2},\dots,x_0,0,\dots,0]$截断至$w$位

因此无论是移位还是乘法，在二进制层面，其执行的操作结果都是等价的，即先得到$x2^k$的$w+k$位的位模式，然后将其截断至$w$位
因此对于有符号整数，和常数$2^k$做有符号乘法等价于将其位模式左移$k$位(固定字长)

因为乘法运算比移位运算和加法运算更加昂贵，许多C编译器都会尝试将整数与常数之间乘法操作(integer multiplied by a constant)以移位操作、加法操作、减法操作的组合代替
例如
表达式 `x * 14` 就可以重写为 `(x<<3) + (x<<2) + (x<<1)` (因为$14 = 2^3 + 2^2 + 2^1$)，用三次移位操作、两次加法操作替代了一次乘法操作，这两个表达式的结果是一样的，无论 `x` 有无符号，无论运算是否溢出，因为在位操作层面这两个表达式是完全等价的
表达式 `x * 14` 也可以重写为 `(x<<4) - (x<<1)` (因为$14 = 2^4 - 2^1$)，用两次移位操作、一次减法操作替代了一次乘法操作

考虑任意的常数$K$，将$K$的二进制表示写为由连续的$0$和$1$的序列交替组成的形式$[(0\dots,0)(1\dots1)(0\dots0)\dots(1\dots1)]$
考虑其中的一串从下标$m$到下标$n$($n\ge m$)的一串连续的$1$序列，这一串$1$序列对$K$的值的贡献可以写为$(2^n + \dots + 2^m)$
考虑表达式 `x * K` ，则这一串序列对乘积 `x * K` 的值的贡献可以写为
`(x<<n) + (x<<(n-1)) + ... + (x<<m)`
或
`(x<<(n+1)) - (x<<m)`
对于$K$的二进制表示中每一个连续$1$的序列，其对于最终乘积的贡献都可以写成移位操作和加法/减法操作的组合形式，而将所有的连续$1$的序列的所对应的仅包含移位操作和加法/减法操作的等价表达式相加，即得到 `x *K` 的仅包含移位操作和加法/减法操作的等价表达式
因此，一个变量和任意常数的乘法操作都可以表示成若干个移位操作和加法/减法操作的组合形式

当然，要使用移位、加法和减法的组合还是使用单个乘法指令取决于这些指令的相对速度，而这则高度依赖于机器
大多数编译器仅在替代后移位、加法和减法的操作数量为少数时才会进行替代

#### 2.3.7 Dividing by Powers of 2
在大多数机器上，整数除法指令比整数乘法指令还慢，大约需要30个时钟周期执行
除以二的幂次的除法操作可以用移位(右移)操作代替

在数学上，整数除法总是向零取整(rounds toward zero)
对于任意实数$a$，$\lfloor a \rfloor$为满足$\lfloor a \rfloor \le a \lt \lfloor a \rfloor + 1$的唯一整数，即向下取整
例如$\lfloor 3.14 \rfloor= 3,\lfloor -3.14 \rfloor =-4$
对于任意实数$a$，$\lceil a \rceil$为满足$\lceil a \rceil - 1 < a \le \lceil a \rceil$的唯一整数，即向上取整
例如$\lceil 3.14 \rceil= 4,\lceil -3.14 \rceil =-3$
对于整数$x\ge 0, y > 0$，$x$为被除数，$y$为除数，整数除法的结果应是$\lfloor x/y \rfloor$，向零取整
对于整数$x\lt 0, y > 0$，$x$为被除数，$y$为除数，整数除法的结果应是$\lceil x/y \rceil$，向零取整
即商为正是向下取整，商为负是向上取整，满足总是向零取整

**Principle**: Unsigned division by a power of 2
对于C变量 `x` , `k` (变量 `x` 的值为无符号整数$x$，变量 `k` 的值为无符号整数$k$，且$0\le k \lt w$)，C表达式 `x>>k` 的值是$\lfloor x/2^k \rfloor$

**Derivation**: Unsigned division by a power of 2
设$x$对应的位模式($w$位)是$[x_{w-1},x_{w-2},\dots,x_0]$，即$B2U_w([x_{w-1},x_{w-2},\dots,x_0]) = x$

表达式 `x>>k` 执行的操作是将$x$的位模式逻辑右移$k$位(固定字长)
因此得到的结果位模式($w$位)是$[0,\cdots,0,x_{w-1},x_{w-2},\dots,x_k]$
令$B2U_{w-k}([x_{w-1},x_{w-2},\dots,x_k]) = x',B2U_k([x_{k-1},\dots,x_0]) = x''$
则$x = 2^kx' + x''$，其中$0\le x'' < 2^k$
则$\lfloor x/ 2^k \rfloor = \lfloor (2^kx' + x'')/2^k \rfloor = \lfloor x'\rfloor + \lfloor x''/2^k\rfloor=x'$
而$B2U_w([0,\cdots,0,x_{w-1},x_{w-2},\dots,x_k]) = B2U_{w-k}([x_{w-1},x_{w-2},\dots,x_k]) = x'$
因此表达式 `x>>k` 的值即为$x' = \lfloor x/2^k \rfloor$

即对于无符号整数，和常数$2^k$做整数除法等价于将其位模式逻辑右移$k$位

**Principle**: Two's-complement division by a power of 2, rounding down
对于C变量 `x` , `k` (变量 `x` 的值为有符号整数$x$，变量 `k` 的值为无符号整数$k$，且$0\le k \lt w$)，C表达式 `x>>k` 的值是$\lfloor x/2^k \rfloor$

**Derivation**: Two's-complement division by a power of 2, rounding down
设$x$对应的位模式($w$位)是$[x_{w-1},x_{w-2},\dots,x_0]$，即$B2T_w([x_{w-1},x_{w-2},\dots,x_0]) = x$

表达式 `x>>k` 执行的操作是将$x$的位模式算数右移$k$位(固定字长)
因此得到的结果位模式($w$位)是$[x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\dots,x_k]$
令$B2T_{w-k}([x_{w-1},x_{w-2},\dots,x_k]) = x',B2U_k([x_{k-1},\dots,x_0]) = x''$
则$x = 2^kx' + x''$，其中$0\le x'' < 2^k$
则$\lfloor x/ 2^k \rfloor = \lfloor (2^kx' + x'')/2^k \rfloor = \lfloor x'\rfloor + \lfloor x''/2^k\rfloor=x'$
而$B2T_w([x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\dots,x_k]) = B2T_{w-k}([x_{w-1},x_{w-2},\dots,x_k]) = x'$
因此表达式 `x>>k` 的值即为$x' = \lfloor x/2^k \rfloor$

因此对于有符号整数$x$，
当$x$为非负数，和常数$2^k$做整数除法等价于将其位模式逻辑右移$k$位
(结果都是$\lfloor x/2^k \rfloor$)
当$x$为负数，和常数$2^k$做整数除法不等价于将其位模式逻辑右移$k$位
(一个结果是$\lceil x/2^k \rceil$，一个结果是$\lfloor x/2^k \rfloor$)

适当为移位操作加上偏置，可以得到为有符号整数和常数$2^k$做整数除法等价的操作

**Principle**: Two's-complement division by a power of 2, rounding up
对于C变量 `x` , `k` (变量 `x` 的值为有符号整数$x$，变量 `k` 的值为无符号整数$k$，且$0\le k \lt w$)，C表达式 `(x + (1<<k) - 1)>>k` 的值是$\lceil x/2^k \rceil$

**Derivation**: Two's-complement division by a power of 2, rounding up
对于整数$x,y$，其中$y > 0$，有
$$\lceil x/y \rceil = \lfloor (x + y-1)/y \rfloor$$
设$x = qy + r$，其中$0\le r < y$
则$\lceil x / y \rceil =\lceil (qy + r) / y \rceil = \lceil q + r/y \rceil = q + \lceil r/y \rceil$
因此$\lceil x / y \rceil=\begin{cases} q,&r = 0\\q+1,&r>0\end{cases}$

而$(x + y -1) / y = (qy + r + y -1)/y = q + (r + y - 1)/y$
故$\lfloor (x + y -1)/y \rfloor = \lfloor q + (r + y -1)/y \rfloor = q + \lfloor (r + y -1) / y \rfloor$
因此$\lfloor (x + y -1)/y \rfloor=\begin{cases} q,&r = 0\\q+1,&r>0\end{cases}$

即对$x$加上偏置$y-1$后再除以$y$，将结果向下取整，则结果等价于$\lceil x/y \rceil$

因此$y = 2^k$时，表达式 `(x + (1<<k) - 1)` 的值即为$x + 2^k -1$
因此表达式 `(x + (1<<k) - 1)>>k` 的值即为$\lfloor (x + 2^k-1)/2^k \rfloor=\lceil x/2^k \rceil$

因此对于有符号整数，和常数$2^k$做整数除法等价于表达式
`(x<0 ? x+(1<<k)-1 : x) >> k`
即$x$非负时，直接移位即可向下取整，$x$为负时，则加上偏置再移位以向上取整

#### 2.3.8 Final Thoughts on Integer Arithmetic

### 2.4 Floating Point
浮点表示用于编码(encode)形式为$V = x \times 2^y$的有理数(rational number)，浮点表示在表示非常大的数($|V|\gg0$)和非常接近0的数($|V|\ll 0$)时有很大的作用

1985年，IEEE 754标准被提出(IEEE Standard 754)，该标准定义了浮点数表示的标准方式以及相应的运算
该标准由Intel和IEEE赞助，主要由William Kahan制定，最初的目的是为Intel 8087芯片提供浮点数支持，如今几乎所有计算机表示浮点数的方法都遵循该标准，称其为IEEE浮点数格式(IEEE floating point format)

> ***Aside*** _The IEEE_
> 电气和电子工程师协会(The Institute  of Electrical and Electronics Engineers)是一个涵盖所有电子和计算机技术的专业协会
> 它出版期刊(journals)，赞助会议(conferences)，并成立委员会(committees)来定义标准，涵盖的主题从电力传输(power transmission)到软件工程
> IEEE标准的另一个例子是为无线网络(wireless networking)定义的802.11标准

#### 2.4.1 Fractional Binary Numbers
考虑实数的十进制表示(decimal notation)
$$d_md_{m-1},\cdots d_1d_0.d_{-1}d_{-2}\cdots d_{-n}$$
其中每个十进制位$d_i$满足$0\le d_i \le 9$，其表示的值为
$$d = \sum_{i=-n}^m10^i\times d_i$$
其中小数点(decimal point)左边的位权重都为10的非负数次幂(nonnegative powers of 10)，而小数点右边的位权重都为10的负数次幂(negative powers of 10)

例如，$12.34_{10}$表示的值可以由$1\times 10^1 + 2\times 10^0 + 3\times 10^{-1} + 4 \times 10^{-2} = 12\frac {34}{100}$计算

以此类推，考虑同样形式的二进制表示
$$b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}$$
其中每个二进制位$b_i$满足$0\le b_i \le 1$，其表示的值为
$$b = \sum_{i=-n}^m2^i\times b_i$$
表示中的点现在称为二进制小数点(binary point)，类似地，点左边的位权重都为2的非负数次幂(nonnegative powers of 2)，而点右边的位权重都为2的负数次幂(negative powers of 2)

例如，$101.11_{2}$表示的值可以由
$1\times 2^2 + 0\times 2^1 + 1\times 2^0+ 1\times 2^{-1} + 1 \times 2^{-2} = 5\frac {3}4$计算

将表示中的二进制小数点向右移动一位，表示的值乘以2
将表示中的二进制小数点向左移动一位，表示的值除以2

表示形式为$0.11\cdots 1_2$的表示的是一个略小于1的数，
因为$b = \sum_{i=-n}^{-1}2^i\times 1=2^{-1}+\cdots + 2^{-n}=1-2^{-n}=1-\frac 1 {2^n}$，
可以将其写为$1.0-\epsilon$

如果只考虑有限长度的编码(finite-length encodings)，则十进制表示形式无法表示如$\frac 1 3,\frac 5 7$这类的无限小数，只能近似
同理，二进制表示形式也只能表示形式为$V = x\times 2^y$这样的数，无法精确表示的实数只能近似，例如$\frac 1 5,\frac 1 10$

#### 2.4.2 IEEE Floating-Point Representation
上一节中所考虑的位置表示法(positional notation)不便于表示非常大的数字，例如$5×2^{100}$的二进制表示模式为$1010\cdots 0$，即$101$后跟着一百个$0$

考虑直接给出$x$和$y$的值来表示形式为$V = x\times 2^y$这样的数会更加效率

IEEE浮点数标准用于表示形式为$V = (-1)^s \times M \times 2^E$的数，其中：
- 符号位(sign)$s$决定了表示的数是正数($s=0$)还是负数($s=1$)
- 有效数(significand)$M$是一个分数二进制数(fractional binary number)，其范围为$[0,1-\epsilon]$或$[1,2-\epsilon]$
- 指数(exponenet)$E$为整数，为原数乘上二的幂次项$2^E$

因此，一个浮点数的位表示也被划分为三个对应的域：
- 符号域(s)：$1$位符号位$s$
- 指数域(exp)：$k$位指数位$e_{k-1}\cdots e_1e_0$表示指数$E$
- 分数域(frac)：$n$位分数位$f_{n-1}\cdots f_1f_0$表示有效数$M$

对于32位单精度浮点数，一般$k = 8,n=23$
对于64位双精度浮点数，一般$k=11,n=52$
![[CSAPP-Fig2.32.png]]

根据指数域的位表示，一个浮点表示有三种解释方式：
**Case 1: Normalized Values**
最常见的情况，当指数域的位模式既不是全$0$(值为$0$)也不是全$1$(单精度时值为$255$，双精度时值为$2047$)，则此时该浮点表示的是标准化值

此时，规定指数域实际表示的值$E$是一个有偏形式的带符号整数(signed integer in biased form)，
即$E = e -Bias$，其中$e$为位模式$e_{k-1}\cdots e_1e_0$表示的无符号整数，$Bias$为$2^{k-1}-1$(单精度时值为$127$，双精度时值为$1023$)
此时$E$的范围为$[-2^{k-1}+2,2^{k-1}-1]$(单精度时为$[-126,127]$，双精度时为$[-1022, 1023]$)

此时，规定分数域实际表示的值$M = 1+f$，其中$f$为二进制模式$0.f_{n-1}\cdots f_1f_0$表示的分数值($0\le f < 1$)，称其为隐式前导$1$表示(implied leading $1$ representation)
因此，分数域实际表示的值$M$即二进制模式$1.f_{n-1}\cdots f_1f_0$表示的值，$M$的范围是$1\le M < 2$

当符号位$s=0$，指数域位模式为$[00\dots1]$，分数域位模式为$[00\dots0]$， 此时$E = 1-Bias= -2^{k-1}+2, M = 1 + f = 1$，则
$V = 1 \times 2^{-2^{k-1}+2}= 2^{-2^{k-1}+2}$，此即符号为$+$的最小标准化浮点数

当符号位$s=0$，指数域位模式为$[01\dots1]$，分数域位模式为$[00\dots0]$，此时$E = (2^{k-1}-1)-Bias= 0, M = 1 + f = 1$
则$V =  1\times 2^0=1.0$

当符号位$s=0$，指数域位模式为$[11\dots0]$，分数域位模式为$[11\dots1]$， 此时$E = (2^k-2)-Bias= 2^{k-1}-1, M = 1 + f = 1 + (1-2^{-n}) = 2 - 2^{-n}$，则$V = (2-2^{-n}) \times 2^{2^{k-1}-1}= (1-2^{-n-1})\times2^{2^{k-1}}$，此即符号为$+$的最大标准化浮点数

**Case 2: Denormalized Values**
当指数域的位模式为全零$[00\cdots0]$，此时该浮点表示是非标准化形式(denormalized form)

此时，规定指数域实际表示的值$E = 1 -Bias$，其中$Bias=2^{k-1}-1$
则此时$E = 1 - Bias = -2^{k-1}+2$(单精度时$-126$，双精度时$-1022$)

此时，规定分数域实际表示的值$M = f$，其中$f$为二进制模式$0.f_{n-1}\cdots f_1f_0$表示的分数值($0\le f < 1$)，即此时没有隐含的前导一

非标准化形式的目的有两个
其中一个目的是为了表示0，
在标准化形式中，有效数满足$1\le M < 2$，因此标准化形式无法表示0
在非标准化形式中，当分数域的位模式为全零$[00\cdots0]$，符号位为$0$时，表示$+0.0$
当分数域的位模式为全零$[00\cdots0]$，符号位为$1$时，表示$-0.0$

另一个目的是为了表示值非常接近于$0.0$的数，
非标准化形式表示具有渐变下溢(gradual underflow)的特性，即其所表示的数值满足在$0.0$附近均匀分布(spaced evenly near $0.0$)

当符号位$s=0$，指数域位模式为全零，分数域位模式为全零，则$V =  +0.0$
当符号位$s=1$，指数域位模式为全零，分数域位模式为全零，则$V =  -0.0$

当符号位$s=0$，指数域位模式为全零，分数域位模式为$[00\dots1]$， 此时$E = 1-Bias= -2^{k-1}+2, M = f = 2^{-n}$，则
$V =  2^{-n}\times 2^{-2^{k-1}+2}=2^{-n-2^{k-1}+2}$，此即符号为$+$的最小非标准化浮点数

当符号位$s=0$，指数域位模式为全零，分数域位模式为$[11\dots1]$， 此时$E = 1-Bias= -2^{k-1}+2, M = f = 1-2^{-n}$，则
$V = (1-2^{-n}) \times 2^{2^{k-1}+2}$，此即符号为$+$的最大非标准化浮点数
注意最小的标准化浮点数为$1\times 2^{2^{k-1} + 2}$，仅仅略大于最大的非标准化浮点数

**Case 3: Special Values**
当指数域的位模式为全一$[11\cdots1]$，此时该浮点表示是特殊值

此时，当分数域的位模式为全零$[00\cdots 0]$，规定此时表示的值为无穷$\infty$，
当符号位$s$为$1$时，表示负无穷$-\infty$
当符号位$s$为$0$时，表示正无穷$+\infty$
无穷值实际用于溢出(overflow)值的表示，例如当对两个很大的数做乘法或除以零时，结果将会是无穷值

此时，当分数域的位模式不为全零时，规定此时表示的值为$NaN$(not a number)
$NaN$值实际用于当运算的结果无法由无穷值和实数值表示的时候，例如$\sqrt {-1}$或$\infty - \infty$，$NaN$值在一些应用中也用于表示未初始化的值(uninitialized data)

#### 2.4.3 Example Numbers
一些特殊值的浮点表示
![[CSAPP-Fig2.36.png]]

在单独处理符号位的情况下，IEEE浮点数可以直接用整数排序算法进行排序，这是该格式的设计意图之一
当符号位为$0$，将IEEE浮点数的位模式解释为无符号整数后利用整数排序算法进行排序，得到的是正确的升序序列
当符号位为$1$，将IEEE浮点数的位模式解释为无符号整数后利用整数排序算法进行排序，得到的是正确的降序序列

#### 2.4.4 Rounding
受到表示范围和表示精度的限制，浮点运算(floating-point arithmetic)只能对实数运算(real arithmetic)进行近似
因此，对于一个任意的实数值$x$，若无法用浮点表示法精确表示，就需要用可以用浮点表示法表示的值$x'$近似表示$x$

从实际值$x$到近似值$x'$的过程即舍入(rounding)

IEEE浮点格式定义了四个不同的舍入模式(rounding modes)
- 四舍五入(Round-to-even)
- 向零舍入(Round-toward-zero)
- 向下舍入(Round-down)
- 向上舍入(Round-up)

对于一个任意的实数值$x$，定义两个离$x$最近的且可以由浮点表示法精确表示的值$x^-,x^+$，满足$x^-\le x \le x^+$，舍入模式即规定了对应情况下是选择舍入到$x^-$还是$x^+$

四舍五入(Round-to-even/Round-to-nearest)是默认的舍入模式，
四舍五入模式规定向离$x$最近的值舍入，如果$x^-$和$x^+$离$x$一样近，则向最低有效位为偶数的值舍入(the least significant digit of the result is even)
例如：$1.4$舍入到$1$，$1.6$舍入到$2$，$1.5$和$2.5$都舍入到$2$，$1.235$和$1.245$都舍入到$1.24$

向零舍入模式规定在$x$为正数是向下舍入，在$x$为负数时向上舍入，满足$|x'| \le |x|$
向下舍入模式规定舍入为$x^-$
向上舍入模式规定舍入为$x^+$

四舍五入模式在$x^-$和$x^+$离$x$一样近，规定向最低有效位为偶数的值舍入，而不是规定此时固定为向上舍入或是向下舍入的理由在于避免统计偏置(statistical bias)
例如，需要对一系列的值做舍入后再计算其平均值，如果规定在$x^-$和$x^+$离$x$一样近时向上舍入，则会导致最后的平均值比实际的平均值偏高，同样如果规定在$x^-$和$x^+$离$x$一样近时向下舍入，则会导致最后的平均值比实际的平均值偏低，这两种规定都引入了一定的统计偏置
而规定向最低有效位为偶数的值舍入则有效避免了统计偏置，实际中，向下舍入和向上舍入的情况约各占$50$%

对于二进制小数值，由于$0$为偶数而$1$为奇数，因此最低有效位为偶数即最低有效位为$0$，因此要将模式为$XX\cdots X.YY\cdots Y100\cdots$的值(向下舍入和向上舍入距离相同)进行四舍五入到最右边的$Y$的那一位时，即向$Y$这一位为$0$的近似值舍入
例如要舍入到小数点右边两位：
$10.00011_2$舍入为$10.00_2$(向最近舍入)
$10.00110_2$舍入为$10.01_2$(向最近舍入)
$10.11100_2$舍入为$11.00_2$(向上舍入使得最低有效位为$0$)
$10.10100_2$舍入为$10.10_2$(向下舍入使得最低有效位为$0$)

#### 2.4.5 Floating-Point Operations
对于实数值$x,y$，以及定义于实数的运算$\odot$，IEEE标准规定，运算$x\odot y$的浮点结果值应为$Round(x\odot y)$，即浮点结果值应该为实际结果值的舍入

对于特殊值如$-0,\infty,NaN$参与的运算，可以不必计算，直接根据标准规定给出结果，如$1/-0$的结果为$-\infty$，$1/+0$的结果为$+\infty$

实数加法和整数加法类似，也形成了一个阿贝尔群
对于浮点值$x,y$，定义浮点加法运算$+^f$：
$$x +^f y = Round(x+y)$$
该运算是可交换的(commutative)，满足$x+^f y = y+^f x$
该运算不是可结合的(not associative)，因为运算可能发生溢出，也可能由于舍入丢失值，例如 `3.14+(1e10-1e10)` 结果值为 `3.14` ，而`(3.14+1e10)-1e10` 结果值为 `0.0` ，因为值 `3.14` 在舍入时被丢弃
该运算下，大部分浮点值$x$存在对应的逆$-x$，满足$x+^f -x = 0$(对符号位取反即可得到浮点类型的相反数)
而$\pm\infty,NaN$值则不存在对应的逆
($+\infty +^f -\infty = NaN$，$NaN +^f x = NaN\ for \ any\ x$)
因此浮点加法有部分实数加法的性质，但没有形成一个阿贝尔群

浮点加法满足单调性质(monotonicity)，即
对于任意浮点值$a,b,x$($a,b,x\ne NaN$)，有：
$$a\ge b \Rightarrow x +^f a\ge x+^f b$$
而无符号整数加法和补码加法则不满足该单调性质

对于浮点值$x,y$，定义浮点乘法运算$*^f$：
$$x *^f y = Round(x\times y)$$
该运算是封闭的($\pm\infty,NaN$也属于浮点值)
该运算有幺元$1.0$(mulpicative identity)
该运算是可交换的
该运算不是可结合的，因为运算可能发生溢出，也可能由于舍入丢失值，
例如  `1e20*(1e20*1e-20)` 结果值为 `1e20` ，而 `(1e20*1e20)*1e-20` 结果值为$+\infty$ ，因为 `(1e20*1e20)` 发生了溢出

浮点乘法对于浮点加法不满足分配律(floating-point multiplication does not distribute over addition)，因为运算可能发生溢出，也可能由于舍入丢失值
例如 `1e20*(1e20-1e20)` 结果值为 `0.0` ，而 `1e20*1e20-1e20*1e20` 结果值为$NaN$ ，因为 `(1e20*1e20)` 发生了溢出

浮点乘法满足单调性质(monotonicity)，即
对任意浮点值$a,b,x$($a,b,x\ne NaN$)有：
$$\begin{aligned}
a\ge b\ and\ c\ge 0 \Rightarrow a*^fc\ge b*^fc\\
a\ge b\ and\ c\le 0 \Rightarrow a*^fc \le b*^fc
\end{aligned}$$
而无符号整数乘法和补码乘法则不满足该单调性质

另外，对任意浮点值$a$($a\ne NaN$)有$a *^f a \ge 0$

#### 2.4.6 Floating Point in C
C提供两种浮点数据类型：`float` 和 `double` 以分别表示单精度和双精度浮点数

C标准并未要求C中的浮点表示遵循IEEE浮点数标准，因此在C中，不能保证浮点数的默认舍入模式为四舍五入，同时也不能保证存在$-0,\pm \infty, NaN$这些特殊浮点值
大多数系统提供头文件和过程库(procedure libraries)的组合以提供对这些特性的访问，但细节因系统而异
例如GNU编译器 `gcc` 预定义了常量 `INFINITY` 表示$+\infty$ 、`NaN` 表示$NaN$ ，在程序中包括下列代码即可使用
```c
#define _GNU_SOURCE 1
#include <math.h>
```

在类型 `int` 、 `float` 、`double` 之间转换时，变量的位表示(bit representations)和数值(numeric values)都会发生变化，细节如下：
- 从 `int` 到 `float` ，不会发生溢出，但可能发生舍入，数值可能细微改变
- 从 `int` 或 `float` 到 `double` ，数值会被精确保留，因为 `double` 类型的表示范围(the range of representable values)和精度(the number of significant bits)都更高
- 从 `double` 到 `float` ，因为 `float` 的表示范围更小，可能发生溢出导致数值变为$\pm \infty$，因为 `float` 的表示精度更小，可能发生舍入
- 从 `float`  或 `double` 到 `int` ，数值可能发生溢出，未溢出时，数值将向零舍入取整(be rounded toward zero)，例如 `1.999` 会变为 `1` ，`-1.999` 会变为 `-1`  C标准没有对溢出值的形式作规定，Intel兼容的处理器会将不确定整数值(integer indefinite value)设为$[10\cdots 00]$($TMin_w$)，即任意不能得到合理整数值的浮点数向整型的转化的结果值都将是$TMin_w$，例如 `(int) +1e10` 的值就会是 `-21483648`

### 2.5 Summary

## CH3 Machine-Level Representation of Programs
计算机执行机器码，即编码了操作数据、管理内存、读写数据、通过网络通信等低层操作的字节序列
编译器基于编程语言的规则、目标机器的指令集、操作系统遵循的协定生成机器码

GCC通过编译器生成汇编码，然后通过汇编器和链接器从汇编码生成可执行机器码

x86-64是如今大多数主机使用的机器语言，该语言源于Intel在1978年的首个16位处理器，然后拓展至32bit，最后拓展至64bit

> ***Web Aside ASM:IA32*** IA32 programming
> IA32是x86-64的32位前身，由Intel在1985年引入
> 如今的大多数的x86微处理器在向后兼容模式仍能运行IA32程序

32位机只能利用大约4GB($2^{32}$字节)的RAM，而64位机可以利用大约256TB($2^{48}$字节)到16EB($2^{64}$字节)的RAM
### 3.1 A Historical Perspective
列出一些Intel的处理器，使用该处理器包含的晶体管(transisitors)数量表征处理器的复杂性，$K$表示$10^3$，$M$表示$10^6$，$G$表示$10^9$
- 8086(1978，29K个晶体管)
	第一个单片(single-chip)十六位微处理器
	8088是8086的变体，多了一个8位的外部总线(external bus)
	1980年，Intel推出了8087浮点协处理器(copercessor)，45K个晶体管，8087和8086或8088同时工作，处理浮点数据
	8087建立了x86生产线(line)的浮点模型(model)，常称为x87
- 80286(1982，134K)
	加入了更多的寻址模式(addressing modes)(现在已淘汰)
- i386(1985，275K)
	将架构延伸至32位，加入了平面编址模型(flat addressing model)，这是系列中第一个可以完全支持Unix系统的处理器
- i486(1989，1.2M)
	性能提升，处理器芯片中集成了浮点单元，但指令集架构未显著改变
- Pentium(1993，3.1M)
	性能提升，但仅对指令集添加了少量延伸
- PentiumPro(1995，5.5M)
	推出了完全新的处理器设计，称为P6微架构，为指令集加入了一类“条件移动(conditional move)"指令
- Pentium/MMX(1997，4.5M)
	加入了一类新指令以处理整数向量(vectors of integers)，每个数据元(dataum)的大小可以是1，2或4字节，每个向量全长64位
- PentiumII(1997，7M)
	仍使用P6微架构
- PentiumIII(1999，8.2M)
	推出了SSE，一类用于处理整数向量或浮点数向量的指令
	每个数据元的大小可以是1，2或4字节
	每个向量全长128位
	该芯片后续加入了二级cache，晶体管数量升至24M
- Pentium 4(2000，42M)
	SSE拓展至SSE2，加入了新的数据类型(包括双精度浮点数)，以及144个新指令
	这些延伸的加入使得编译器可以使用SSE指令而不是x87指令来编译浮点数代码
- Pentium 4E(2004，125M)
	加入超线程，
	加入EM64T，一个Intel对AMD开发的IA32的64位拓展的执行(implementation)，我们后续称其为x86-64
- Core 2(2006，291M)
	回归至类似P6的微架构
	第一个多核Intel微处理器，即单片上有多个处理器
	不支持超线程
- Core i7，Nehalem(2008，781M)
	包含了多核和超线程，因此是第一个支持一个核心执行两个程序，一个片上执行四个程序的处理器
- Core i7，Sandy Bridge(2011，1.17G)
	推出了AVX，一个对SSE的拓展，支持256bit长的向量
- Core i7，Haswell(2013，1.4G)
	AVX拓展至AVX2，加入了更多指令和指令格式(instruction formats)


每一代的处理器都设计成是可向后兼容的，Intel的处理器生产线有过几个名字，例如IA32(Intel Architecture 32-bit)，Intel64(IA32的64位拓展)，我们常称其为x86-64，
我们通常指整个生产线为x86，来源于从8086到i486的命名习惯

一些公司，例如AMD也生产了与Intel处理器相兼容的处理器，即可以和Intel处理器运行完全一致的机器级程序(machine-level program)的处理器

AMD在2002年第一次突破了商用处理器的1GHz时钟频率，并推出了x86-64，即目前广泛使用的对Intel IA32的64位拓展

> ***Moore's Law***
> x86微处理器在数十年保持了大约每26个月晶体管数量就翻倍的速率
> 大约50年，半导体行业保持了平均每18个月翻倍晶体管数量的速率
> 半导体存储器和磁盘的存储容量也保持了类似的增长速率

### 3.2 Program Encodings
有两个C程序 `p1.c` ，`p2.c` 
在命令行将其编译 `linux> gcc -Og -o p p1.c p2.c`
优化选项 `-Og` 使得编译器尽力使得机器码遵循原C代码的结构，高层次的优化会使得机器码的结构与源代码的结构差异较大

gcc首先调用C预处理器，在源文件中插入 `#include` 头文件的代码，展开 `#define` 宏，然后生成名为 `p1.s` `p2.s` 的汇编码文件，然后汇编器将汇编码转变成二进制目标码(object-code)文件 `p1.o` `p2.o`，目标码是机器码的一种形式，它包含了所有指令的二进制表示，但是全局值(global value)的地址(address)尚未填入，最后链接器将目标码文件和实现了库函数的文件链接，生成可执行码(executable code)文件 `p`
可执行码文件是我们考虑的第二种形式的机器码，可执行码就是处理器所执行的机器码的形式
#### 3.2.1 Machine-Level Code
计算机系统采用多种不同形式的抽象，隐藏实现细节，为上层提供一个更简单的抽象模型
对于机器级别编程，有两层重要的抽象
首先，机器级别程序的格式和行为(format and behaviour)是由指令集架构定义的(instruction set architecture/ISA)，指令集架构定义了处理器状态(processor state)，指令的格式，以及各种不同的指令在该状态下产生的效果

大多数指令集架构，包括x86-64，在指令是顺序执行(一个指令结束，下一个指令才能开始)的抽象下描述一个程序的行为
实际上，硬件行为十分复杂，一般并发(concurrent)执行许多指令，但也采用了保护措施(safeguards)以确保整体的行为匹配ISA描述的顺序操作

其次，机器级别程序使用的内存地址是虚拟地址(virtual address)，虚拟地址提供了一个表现为一个极大的字节数组(byte array)的内存模型
而实际的内存系统的执行包括了多个硬件存储器和操作系统软件的结合

汇编码表示非常接近机器码，其主要特性就是相较于机器码的二进制格式，汇编码是更易读的文本格式

x86-64中，处理器状态的某些部分是可见的，但这些部分通常对C程序员是隐藏的，包括
- 程序计数器(program counter/PC)
	在x86-64中称为 `%rip`
	内容是下一次要执行的指令的内存地址
- 整型(integer)寄存器堆(register file)
	包含了16个存储了64位值的有名字的位置(即16个寄存器)
	一些寄存器用于追踪程序状态(program state)的关键部分
	其他的用于存取暂时的数据，例如函数的参数、局部变量、返回值
- 状态码寄存器(condition code register)
	保存了最近执行的算数或逻辑指令的状态信息(status)，用于执行数据流或控制流的条件性改变(conditional changes)，例如是否需要执行 `if` 或 `while` 下的语句
- 一系列向量寄存器(vector registers)
	每个向量寄存器都可以保存一个或多个整数或浮点数

C向程序员提供的模型中，不同数据类型的对象可以被声明和分配内存，而在机器码中，内存仅仅被视作一个巨大的字节寻址的数组(byte-addressable array)
C中的集合数据类型例如数组或结构体在机器码看来都是连续的字节(contiguous collections of bytes)
对于标量数据类型，汇编码也不区分有符号或无符号整数，不区分不同类型的指针，甚至不区分指针和整数

程序内存(program memory)包括了该程序的可执行机器码，一些OS所要求的信息，一个用于管理过程调用和返回的运行时栈(run-time stack)，以及由用户分配的内存块(例如通过 `malloc` 库函数)
程序内存是由虚拟地址寻址的，且在任意给定时刻，仅有限范围(limited subranges)的虚拟地址是被认为有效的(valid)，例如，x86-64的虚拟地址由64位的字表示，在当下机器的实现中，最高的16位必须为0，因此一般最高的潜在寻址范围有$2^{48}$字节，即64TB，许多典型的程序仅有几MB到几GB的寻址范围

OS管理虚拟地址空间，将虚拟地址翻译为物理地址

单个机器指令一般仅执行非常初级的操作(elementary operation)，例如，将存在寄存器中的两个数相加，在内存和一个寄存器之间传输数据，条件性地分支到一个新的指令地址(conditionally branch to a new instruction address)
编译器为了实现常用的程序构造(construct)例如算数表达式估值，循环，过程调用和返回，一般要生成一系列(sequences of)这样的指令
#### 3.2.2 Code Examples
有C文件`mstore.c`
```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
	long t = mult2(x, y);
	*dest = t;
}
```
将其编译
`linux> gcc -Og -S mstore.c`
其中 `-S` 选项使得GCC生成汇编码文件 `mstore.s` ，然后停止，不在调用汇编器，链接器等

汇编码文件 `mstore.s` 中许多声明，例如
```x86
multstore:
	pushq %rbx
	movq %rdq, %rbx
	call mult2
	movq $rax, (%rbx)
	popq %rbx
	ret
```
每个缩进行都对应了单个机器指令，例如 `pushq` 指令表明了寄存器 `%rbx` 的内容必须要被推入程序栈中

如果使用 `-c` 选项，GCC会编译且汇编程序
`linux> gcc -Og -c mstore.c`
我们得到目标码文件 `mstore.o` ，为二进制格式，文件共1368字节大小，其中有一个14字节的十六进制表示的序列
`53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`
此即之前展示的汇编指令所对应的机器码

机器码文件难以阅读，需要借助一类称为反汇编器(disassembler)的程序，这类程序从机器码生成类似汇编码格式的代码
Linux系统中，OBJDUMP程序(object dump)在给定 `-d` 选项时可以执行这类功能
`linux> objdump -d mstore.o`
得到结果
![[CSAPP-Fig-objdump.png]]
一些值得注意的机器码及其反汇编表示的特征
- x86-64指令的机器码长度在1到15字节，其中常用的指令以及需要较少操作数的指令长度相较于不常用的指令以及需要较多操作数的指令长度要短
- 指令格式(format)的设计遵循从一个给定的起点开始，存在一个独一无二的从字节序列到机器指令的编码(there is a unique decoding of the bytes into machine instructions)，例如只有指令 `pushq %rbx` 以字节 `53` 开头
- 反汇编器仅根据机器码文件中的字节序列决定汇编码，不需要其他信息
- 反汇编器生成的汇编码的命名惯例和GCC生成的汇编码的命名管理略有不同，例如本例中，反汇编器生成的汇编码忽略了许多指令的后缀 `q` ，这些后缀实际上是大小指示器(size designator)，在大多数情况下可以忽略，并且，反汇编器为 `call` 和 `ret` 指令添加了后缀 `q` ，当然这在大多数情况下也可以忽略

要生成实际可执行的代码，还需要对一系列相关的目标码文件运行链接器，并且其中一个目标码文件必须包含 `main` 函数

例如有C文件 `main.c`
```c
#include <stdio.h>

void multstore(long, long, long *);

int main(){
	long d;
	multstore(2, 3, &d);
	printf("2 * 3 --> %ld\n", d);
	return 0;
}

long mult2(long a, long b){
	long s = a * b;
	return s;
}
```

用以下指令生成可执行程序 `prog` 
`linux> gcc -Og -o prog main.c mstore.c`
文件 `prog` 的大小是8655字节，它不仅包含了我们提供的过程的机器码，也包含了用于起始和结束程序的机器码，以及和OS交互的机器码

可以反汇编 `prog` 
`linux> objdump -d prog`
结果文件中包含了以下部分
![[CSAPP-Fig-objdump1.png]]
这与 `mstore.o` 反汇编生成的汇编码几乎完全一致，但一个重要的差别在于左边的地址是不同的，因为链接器将代码的位置移动到了一个不同的地址范围，另一个差别在于链接器将 `callq` 要调用 `mult2` 函数时需要的地址填入了，链接器的一个任务就是将函数调用和该函数本体在可执行码文件中的位置匹配，最后一个差别在于多了两个额外的行，多出的指令对程序没有影响，因为函数已经返回，它们的意义在于将该函数的大小增长至16字节，进行地址对齐，这对存储系统的性能有意义，下一个代码块的位置会更方便索引
#### 3.2.3 Notes on Formatting
GCC生成的汇编码不便于人类阅读，一方面它包括了一些我们不需要关心的信息，另一方面它不包含任何注释，例如
`linux> gcc -Og -S mstore.c`
生成了 `mstore.s` 文件如下
```x86
	.file "010-mstore.c"
	.text 
	.globl multstore
	.type multstore, @function
multstore: 
	pushq %rbx
	movq %rdx, %rbx
	call mult2
	movq %rax, (%rbx)
	popq %rbx
	ret 
	.size multstore, .-multstore
	.ident "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1" 
	.section .note.GNU-stack,"",@progbits
```
所有以 `.` 开头的行都是用于指导汇编器和链接器的指令(directives)，我们一般可以忽略

在C程序中包含汇编语言有两种方式，一种方式是用汇编语言书写整个函数，然后在链接阶段和C函数结合，另一种方式是使用GCC对在C程序中直接嵌入汇编码的支持

> ***Aside*** _ATT versus Intel assembly-code formats_
> 本书中，汇编码采用ATT格式(命名来自于AT&T公司，该公司运营了贝尔实验室许多年)，这也是GCC, OBJDUMP等工具默认采用的格式
> 其他的一些编程工具，包括来自Microsoft的工具以及Intel的文档，汇编码采用Intel格式
> 这两个格式有许多地方不同
> GCC也可以指定生成Intel格式的汇编码，如
> `linux> gcc -Og -S -masm=intel mstore.c`
> Intel和ATT格式在以下方面有所区别
> 1. Intel格式忽略了大小标识后缀(size designation suffix)，我们可以看到指令名称是 `push` 和 `mov` 而不是 `pushq` 和 `movq`
> 2. Intel格式忽略了寄存器名称前的 `%` ，我们可以看到 `rbx` 而不是 `%rbx`
> 3. Intel格式采用不同的方式描述内存中的地址，例如 `QWROD PTR [rbx]` 而不是 `(%rbx)`
> 4. 拥有多个操作数的指令会以逆序展示操作数(reverse order)
### 3.3 Data Formats
由于Intel最初的架构是16位，后续拓展到了32位，Intel使用”字(word)”指16位的数据类型，而指32位的数据类型为”双字(double words)“，指64位数据类型为“四倍长字(quad words)”

下图展示了C的基础类型在x86-64语言中的表示
![[CSAPP-Fig3.1.png]]
x86-64指令集包含操作字节、单字、双字、四倍长字类型的数据大量指令

浮点数有两种主要的格式：单精度(4字节)值，对应C中的 `float` 类型，双精度(8字节)值，对应C中的 `double` 类型
x86一族的处理器在历史上曾用一个特殊的80bit(10字节)的浮点格式实现所有的浮点操作，该格式可以在C中用 `long double` 声明，不推荐使用该格式，因为不具备可移植性

就如图3.1所示，大多数GCC生成的汇编码都会有一个单字符的后缀，用以表明操作数的大小，例如，数据移动指令有四个变体：`movb` (move byte), `movw` (move word), `movl` (move double word), `movq` (move quad word)
汇编码使用 `l` 后缀以表明4字节大小的整数或8字节大小的双精度浮点数，这实际上不会产生混乱，因为浮点数涉及的是完全不同的一组指令和寄存器

> ***Web Aside ASM:EASM*** _Combining assembly code with C programs_
> C程序难以涉及一些机器上的特征，例如，x86-64处理器每次执行一个算数或逻辑运算时，会设定一个1bit的条件码标志(condition code flag)，名为PF(parity flag/奇偶标志)，当计算结果的低八位有偶数个1时，PF被设为1，否则被设为0
> 在C中计算PF值需要至少七次移位、掩码以及异或操作，而硬件则会将它视作每次的算数操作或逻辑操作的一部分，自动执行，因此，要在C中更好地计算PF值，需要在C程序中包含一部分的汇编码
> 要在C程序中包含汇编码有两种方式，
> 其一是在一个单独的汇编码文件中写好整个函数，然后让汇编器和链接器将它与我们的C程序结合
> 其二是使用GCC的内联汇编(inline assembly)特征，使用 `asm` 指令，可以在C中包含一段汇编码
> 当然，在C程序中包含汇编码会使得该程序仅针对于一类的机器(例如x86-64)，可移植性大大降低
### 3.4 Accessing Information
一个x86-64中央处理单元(CPU)包含一组共16个通用寄存器(general-purpose registers)，存储64bit的值
这些寄存器主要用于存储整数数据和指针

这些寄存器的名称都以 `%r` 开头，但由于指令集发展的历史原因，它们没有全部遵守一个共同的命名规范
最初的8086处理器有八个16位寄存器，从 `%ax` 到 `%bp` ，每一个都有自己特定的用途，因此它们的名称与其用途有关，当拓展至IA32后，这些寄存器也被拓展为32位寄存器，名称改为从 `%eax` 到 `%ebp` ，拓展至x86-64后，这八个寄存器也拓展到64位，名称改为从 `%rax` 到 `%rbp` ，此外还加入了8个新的寄存器，名称从 `%r8` 到 `%r15` ，遵循新的命名规范
![[CSAPP-Fig3.2.png]]

如图中的嵌套框所示，指令可以对这16个寄存器中的不同大小的数据进行操作(即寄存器内容的低位字节/low-order bytes)，字节级的操作(operations)可以访问最低有效字节，16位操作可以访问最后的两位有效字节，32位操作可以访问最后四位有效字节，64位操作可以访问整个寄存器

之后，我们会接触许多拷贝和生成1/2/4/8字节值的指令，当这些指令以寄存器作为目的地时，对于生成少于8字节的指令，寄存器中剩余的字节会发生什么，有两种约定：如果生成的是1或2个字节，则寄存器中剩余的字节保持不变，如果生成的是4个字节，则将寄存器中剩余的字节(高位的四个字节)设为0，其中后一种约定其实是IA32到x86-64拓展的一部分

栈指针寄存器 `%rsp` 用于指示运行时栈的结束位置(the end position of the run-time stack)，一些指令会专门对栈指针寄存器进行读写，其余的十五个寄存器的使用则更灵活，少量的指令会对一些寄存器作具体的使用
存在一组标准的编程规定(a set of standard programming conventions)管理如何使用寄存器管理栈、传递函数参数、从函数中返回值、存储局部和暂时数据
#### 3.4.1 Operand Specifiers
多数指令有一个或多个操作数(operands)，用以指明操作时要使用的源值(source value)以及结果要存储到的目标地址
x86-64支持一系列操作数形式
![[CSAPP-Fig3.3.png]]
源值可以直接以常数给定，也可以从寄存器或内存中读取，结果也可以存储到寄存器或内存中，因此操作数的形式可以分为三种类型：
第一种类型是立即数(immediate)，即给定常数值，在ATT格式的汇编码中，立即数以 `$` 开头，后跟随使用标准C格式的整数，例如 `$-577` , `$0x1F` ，不同的指令允许不同范围的立即数值，在汇编成机器码时，对于立即数值，汇编器将自动选择对值进行编码的最紧凑的方式(the most compact way of encoding a value)
第二种类型是寄存器(register)，即数值来自于寄存器的内容，当然，来自于这16个寄存器的低8/4/2/1个字节内容的操作数大小就分别是64/32/16/8位，图3.3中，我们用$r_a$以指示寄存器 `a` (可以把$r_a$当作寄存器 `a` 的索引)，而寄存器 `a` 中存储的值用$R[r_a]$表示(可以认为$R$是一个寄存器数组，以$r_a$索引到寄存器 `a` )
第三种类型是内存引用(memory reference)，数值需要我们根据计算得到的地址，访问特定内存位置取得，所需要的操作数所在的地址常称为有效地址(effective address)，我们将内存视为一个大的字节数组，我们用$M_b[Addr]$以表明对于内存中以地址$Addr$为起始地址，长度为$b$个字节的值的引用，我们经常会忽略下标$b$以简化记号

图3.3展示了许多不同的寻址模式(addressing modes)以进行内存引用，
其中最为一般化的形式即$Imm(r_b, r_i, s)$，该内存引用由四个部分组成：一个立即数偏移(offset)$Imm$，一个基寄存器(base register)$r_b$，一个索引/变址寄存器(index register)$r_i$，一个缩放因子(scale factor)$s$，其中$s$必须是$1,2,4,8$之一，基寄存器和变址寄存器都必须是64位寄存器，有效地址通过$Imm + R[r_b] + R[r_i]\cdot s$计算得到
该形式常常在引用数组中的元素中看到，其余的形式都可以认为是一般形式的特例，实际上，复杂的寻址模型在引用数组和结构体元素(referencing array and structure elements)时十分有效
#### 3.4.2 Data Movement Instructions
最常用的指令即将数据从一个位置拷贝到另一个位置的指令，我们会将许多不同的指令归为一个指令类(instruction class)，同一个指令类中的指令执行相同的操作，但有不同的操作数大小

![[CSAPP-Fig3.4.png]]
图3.4展示了数据移动指令的最简单的形式—— `MOV` 类的指令，这类指令将数据从源地址拷贝到目标地址，不经过任何变换
该类共包含四个指令 `movb` , `movw` , `movl` , `movq` 它们的区别仅在于操作数的大小不同，分别是1/2/4/8个字节

`MOV` 类指令的源操作数(source operand) `S` 可以是立即数、寄存器数或内存引用，即要拷贝的数据可以是立即数，也可以从寄存器或内存中取得，目标操作数(destination operand) `D` 则应该是寄存器或内存地址
x86-64限制了 `move` 指令不能两个操作数都是内存引用/都指向内存地址，将一个值从一个内存地址拷贝到另一个内存地址需要两个指令——第一条指令将源值加载到一个寄存器，第二条指令将寄存器值写入目标地址

参照图3.2，`MOV` 类指令的寄存器操作数可以是这16个寄存器任意的有标签的部分(label portion)，且该部分的大小必须和指令的大小标识后缀匹配(`b` , `w` , `l` , `q` )
大多数情况下，`MOV` 指令只会更新由目标操作数所指示的特定的寄存器字节或内存地址(register bytes or memory locations)，唯一的例外就是当 `movl`的目标地址是寄存器时，会将寄存器的高4位字节(high-order 4 bytes)置零，这是x86-64所采用的约定，即任意为寄存器生成32位值的指令会将寄存器的高位部分置零

下例展示了五种可能的源操作数和目标操作数类型的组合
```
1 movl $0x4050, %eax    Immediate--Register, 4bytes
2 movw %bp, %sp         Register--Register, 2bytes
3 movb (%rdi, %rcx), %al Memory--Register, 1bytes
4 movb $-17, (%esp)     Immediate--Memory, 1bytes
4 movq %rax, -12(%rbp)  Register--Memory, 4bytes
```

图3.4中的最后一个指令适用于处理64位的立即数，常规的 `movq` 指令的源操作数是立即数时，仅支持可以用32位补码表示的数，将其进行符号延伸至64位以为目标地址生成64位的值，而 `movabsq` 指令可以有任意的64位立即数作为源操作数，但目的操作数只能是寄存器

![[CSAPP-Fig3.5.png]]
![[CSAPP-Fig3.6.png]]
图3.5和图3.6展示了两类用于将较小的源值拷贝到较大的目的地址所用的数据移动指令，这些指令的源操作数只能是寄存器或内存地址，目的操作数只能是寄存器，`MOVZ` 指令会将目的地址的剩余字节用0填充，`MOVS` 则采用符号延伸填充
每个指令都有大小指示符(size designator)作为最后两个字符，第一个字符表明源大小，第二个字符表明目标大小

注意图3.5中缺少了将4字节的源值零延伸到8字节的目标地址的指令(逻辑上应该命名为 `movzlq` )，因为该操作实际上可以直接用 `movl` 完成，因为生成四字节值的指令在以寄存器为目标地址时，会填充高位4字节为0

图3.6中的 `cltq` 指令没有操作数，它默认使用寄存器 `%eax` 作为源操作数，以寄存器 `%rax` 作为目的地址，执行符号延伸，该指令的效果和 
`movslq %eax, %rax` 相同，但 `cltq` 的编码更紧凑
#### 3.4.3 Data Movement Examples
考虑图3.7的数据交换例程
![[CSAPP-Fig3.7.png]]
函数 `exchange` 由三条指令实现，两条数据移动指令 `movq` ，以及一条用于返回函数调用点的指令 `ret` ，可以发现参数通过寄存器传递给函数，函数通过将返回值储存在寄存器 `%rax` 中(或者在该寄存器的低位字节中)以返回值

函数开始执行时，参数分别存在了寄存器 `%rdi` 和 `%rsi` 中，函数执行时使用了 `MOV` 指令完成了从内存到寄存器和从寄存器到内存的读写
可以看到C中的指针即地址，对一个指针解引用包括了将指针拷贝入寄存器，然后用该寄存器进行内存引用两步，同时注意到局部变量例如 `x` 时常存在寄存器中而不是内存中，方便快速访问
#### 3.4.4 Pushing and Popping Stack Data
最后要介绍的两个数据移动指令用于将数据推入(push)程序栈(program stack)或从程序栈中弹出(pop)数据，如图3.8所示
![[CSAPP-Fig3.8.png]]
`pushq` 指令用于向栈推入元素，`popq` 指令用于从栈中弹出元素，这两个指令都只接受一个操作数，用于指示要推入的数据源和要弹出的数据目标地址
程序栈在处理过程调用时扮演了关键的角色，我们之后会看到

栈可以视为一个数组，我们总是在这个数组的一端插入或删除数据，我们称这一端是栈的顶端(the top of the stack)
x86-64中，程序栈存储于内存的某个区域，如图3.9所示
![[CSAPP-Fig3.9.png]]
x86-64中，栈向低地址(lower address)增长，因此栈顶端的元素的地址是所有栈中元素最低的地址，栈指针寄存器 `%rsp` 存储了栈顶端元素(top stack element)的地址

向栈内推入一个四倍长字包括两步：首先将栈指针减去8，然后在新的栈顶地址上写入值，因此，指令 `pushq %rbq` 的行为等价于：
```
subq $8,%rsp // Decrement the stack pointer
movq %rbp,(%rsp) // Store %rbp on stack
```
指令 `pushq` 的机器码表示仅有1个字节，而与之等效的这两个指令则总共需要8个字节

从栈中弹出一个四倍长字包括两步：从栈顶端读取数据，然后将栈指针加上8，因此，指令 `popq %rax` 的行为等价于：
```
movq (%rsp),%rax // Read %rax from stack
addq $8,%rsp // Increment stack pointer
```
之前在栈顶端的值仍留在内存中，直到它被覆盖写(例如被其他的入栈操作覆盖写)

由于栈实际上和程序代码以及其他形式的程序数据处于内存中的同一区域，因此程序实际上可以使用标准的内存寻址方法(standard memory addressing method)访问栈内的任意位置
例如，假设栈顶端的元素是一个四倍长字，指令 `movq 8(%rsp),%rdx` 会将栈的第二个四倍长字拷贝到寄存器 `%rdx` 中
### 3.5 Arithmetic and Logical Operations
