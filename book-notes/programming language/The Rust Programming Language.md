# 1 Getting Started
## 1.1 Installation
rustupï¼šç”¨äºç®¡ç†Rustç‰ˆæœ¬å’Œç›¸å…³å·¥å…·çš„å‘½ä»¤è¡Œå·¥å…·

æŸ¥çœ‹rust compilerç‰ˆæœ¬ï¼š`rustc --version`
å‡çº§rustupï¼š`rustup update`
å¸è½½rustupï¼š`rustup self uninstall`
é˜…è¯»æ–‡æ¡£ï¼š`rustup doc`

## 1.2 Hello, World!
rustæ–‡ä»¶åç¼€ä¸º*.rs*
rustæ–‡ä»¶çš„å‘½åä¹ æƒ¯æ˜¯ç”¨ä¸‹åˆ’çº¿åˆ’åˆ†å•è¯ï¼Œå¦‚ï¼š*hello_world.rs*

ç¼–è¯‘æ–‡ä»¶ï¼š`rustc main.rs`
è¿è¡Œï¼š`.\main.exe`

rustç¨‹åºä»mainå‡½æ•°å¼€å§‹æ‰§è¡Œ(rustfmtå¯ä»¥ç”¨äºæ ‡å‡†æ ¼å¼åŒ–rustä»£ç )
rusté£æ ¼ä»¥å››ä¸ªç©ºæ ¼ä¸ºç¼©è¿›
println!è°ƒç”¨äº†rustå®ï¼Œrustå®ä¸å‡½æ•°æ˜¯ä¸åŒçš„
"Hello, World!"å­—ç¬¦ä¸²ä½œä¸ºäº†println!çš„å‚æ•°
rustä»£ç ä»¥ ; ä½œä¸ºä¸€è¡Œä»£ç è¡Œçš„ç»“å°¾

main.pdbåŒ…å«äº†debugä¿¡æ¯

## 1.3 Hello, Cargo!
Cargoæ˜¯rustçš„çš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å·¥å…·ï¼Œå¸¸ç”¨äºç®¡ç†rusté¡¹ç›®
Cargoå¯ä»¥å¸®åŠ©æ„å»ºä»£ç ï¼Œä¸‹è½½ä¾èµ–åº“

æŸ¥çœ‹Cargoç‰ˆæœ¬ï¼š`cargo --version`

ç”¨Cargoæ¥åˆ›å»ºé¡¹ç›®ï¼š
`cargo new hello_cargo`
`cd hello_cargo`
Cargoä¸ºæˆ‘ä»¬åˆ›é€ äº†ä¸€ä¸ª*Cargo.toml*æ–‡ä»¶å’Œä¸€ä¸ªsrcç›®å½•ï¼Œsrcä¸­åŒ…å«äº†*main.rs*
CargoåŒæ—¶åˆå§‹åŒ–äº†ä¸€ä¸ªgitä»“åº“ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°*.gitignore*æ–‡ä»¶

*Cargo.toml*æ˜¯Cargoçš„é…ç½®æ–‡ä»¶ï¼Œåç¼€åå…¨ç§°Tom's Obvious, Minimal Language
Cargoå¸Œæœ›æˆ‘ä»¬æŠŠæºæ–‡ä»¶éƒ½æ”¾åœ¨srcç›®å½•é‡Œï¼Œè€ŒREADMEï¼ŒLisenseï¼Œé…ç½®æ–‡ä»¶ç­‰ä¸ä»£ç æ— å…³çš„æ–‡ä»¶åˆ™æ”¾åœ¨é¡¹ç›®ç›®å½•é‡Œ

ç”¨Cargoæ¥æ„å»ºé¡¹ç›®ï¼š
åœ¨hello_cargoç›®å½•ä¸­è¾“å…¥`cargo build`
*hello_cargo.exe*å°†è¢«åˆ›å»ºåœ¨.\\target\\debug\\hello_cargo.exeï¼Œå› ä¸ºé»˜è®¤æ„å»ºæ˜¯debugæ„å»ºï¼ŒCargoå°†å¯æ‰§è¡Œæ–‡ä»¶æ”¾åœ¨äº†debugç›®å½•
CargoåŒæ—¶åˆ›å»ºäº†*Cargo.lock*åœ¨hello_cargoç›®å½•ï¼Œè¯¥æ–‡ä»¶å¯¹é¡¹ç›®ä¾èµ–çš„ç‰ˆæœ¬è¿›è¡Œè¿½è¸ªï¼Œè¯¥æ–‡ä»¶ç”±Cargoè‡ªåŠ¨ç®¡ç†

ç”¨Cargoæ¥æ„å»ºå¹¶è¿è¡Œé¡¹ç›®ï¼š
åœ¨hello_cargoç›®å½•ä¸­è¾“å…¥`cargo run`å¯ä»¥è®©Cargoå¸®åŠ©æˆ‘ä»¬ç¼–è¯‘ä»£ç å¹¶è¿è¡Œï¼Œ`cargo run`æ›¿ä»£äº†`cargo build`+`.\target\debug\hello_cargo.exe`ï¼Œå½“ç„¶Cargoåœ¨è¯†åˆ«è¯¥é¡¹ç›®å·²ç»æˆåŠŸæ„å»ºä¸”æ²¡æœ‰æ”¹åŠ¨åä¸ä¼šé‡å¤æ„å»ºï¼Œä¼šç›´æ¥è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶
å¦‚æœå¯¹æºä»£ç è¿›è¡Œäº†ä¿®æ”¹ï¼Œ`cargo run`ä¼šé‡æ–°æ„å»ºé¡¹ç›®å¹¶è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶

å¦‚æœæˆ‘ä»¬éœ€è¦ç¼–è¯‘ï¼Œè€Œä¸éœ€è¦äº§ç”Ÿå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨`cargo check`
å› ä¸ºä¸äº§ç”Ÿå¯æ‰§è¡Œæ–‡ä»¶ï¼Œ`cargo check`çš„æ•ˆç‡è¦é«˜äº`cargo build`
åœ¨ç¼–å†™é¡¹ç›®æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥å®šæœŸæ£€æŸ¥ä¹‹å‰çš„ä»£ç å¯ä»¥æ­£ç¡®ç¼–è¯‘ï¼Œè¿™æ—¶å¯ä»¥ä½¿ç”¨`cargo check`ï¼Œæ–¹ä¾¿æˆ‘ä»¬å¿«é€Ÿç¡®è®¤ä¹‹å‰ä»£ç çš„æ­£ç¡®æ€§ï¼Œä»¥åŠå¿«é€Ÿå‘ç°bugï¼Œåœ¨å®Œæˆäº†é¡¹ç›®çš„å…¨éƒ¨å·¥ä½œåï¼Œæˆ‘ä»¬å†ä½¿ç”¨`cargo build`å¾—åˆ°å¯æ‰§è¡Œæ–‡ä»¶

ç”¨Cargoæ¥æ„å»ºç”¨äºå‘å¸ƒçš„é¡¹ç›®ï¼š
å½“é¡¹ç›®å·²ç»å¯ä»¥ç”¨äºå‘å¸ƒæ—¶ï¼Œ`cargo build --release`å¯ä»¥å¯¹é¡¹ç›®è¿›è¡Œæ„å»ºçš„åŒæ—¶å¯¹å…¶ä¼˜åŒ–ï¼Œè¯¥å‘½ä»¤å°†åˆ›å»ºtarget/releaseç›®å½•è€Œä¸æ˜¯target/debugç›®å½•ï¼Œä¼˜åŒ–ä¼šè®©ç¼–è¯‘çš„æ—¶é—´æ›´é•¿

# 2 Programming a Guessing Game
ç”¨Cargoæ„é€ é¡¹ç›®å¹¶è¯•è¿è¡Œï¼š
```
> cargo new guessing_game
> cargo run
Hello, world!
```

## 2.1 Reading Inputs
çŒœæ•°æ¸¸æˆçš„ç¬¬ä¸€éƒ¨åˆ†éœ€è¦è¯·æ±‚ç”¨æˆ·è¾“å…¥ä¸€ä¸ªæ•°å­—ï¼Œå¹¶æ£€æŸ¥æ•°å€¼çš„å€¼æ˜¯å¦ä¸ºæ‰€æƒ³è¦çš„ï¼š
```rust
use std::io;  

fn main() { 
	println!("Guess the number!"); 
	
	println!("Please input your guess."); 
	
	let mut guess = String::new(); 
	
	io::stdin() 
		.read_line(&mut guess) 
		.expect("Failed to read line"); 
		
	println!("You guessed: {guess}"); }
```
è§£é‡Šï¼š
`use std:: io`ï¼šå°†æ ‡å‡†åº“ä¸­çš„ioåº“å¼•å…¥ä½œç”¨åŸŸï¼Œrustä¼šé¢„å¯¼å…¥stdä¸­çš„ä¸€äº›åº“ï¼Œä½†æœ‰äº›åº“åœ¨éœ€è¦æ—¶è¦æ‰‹åŠ¨å¯¼å…¥ï¼Œå¦‚ioåº“
`fn main(){`ï¼šmainå‡½æ•°æ˜¯ç¨‹åºçš„å…¥å£ï¼Œç”±fnå…³é”®å­—å£°æ˜å‡½æ•°
`println!("")`ï¼šprintlnæ˜¯å°†å­—ç¬¦ä¸²æ‰“å°åˆ°å±å¹•çš„å®

`let mut guess = String::new()`ï¼šåˆ›é€ ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ç”¨æˆ·è¾“å…¥

letè¯­å¥å¸¸ç”¨äºåˆ›é€ å˜é‡ï¼Œå¦‚ï¼š`let apple = 5`
åœ¨rustä¸­ï¼Œå˜é‡å®é™…ä¸Šæ˜¯é»˜è®¤ä¸å¯å˜çš„ï¼Œå¦‚æœéœ€è¦å€¼å¯å˜çš„å˜é‡ï¼Œå°±éœ€è¦åŠ ä¸Šmutå…³é”®å­—ï¼Œå¦‚ï¼š`let mut banana = 5`

`String::new()`æ˜¯è¿”å›äº†Stringå®ä¾‹çš„ä¸€ä¸ªå‡½æ•°ï¼ŒStringæ˜¯ç”±æ ‡å‡†åº“æä¾›çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œç”±utf-8ç¼–ç ï¼Œå¯å˜é•¿åº¦
`::`è¡¨æ˜äº†`new()`å‡½æ•°æ˜¯å’ŒStringç±»å‹ç›¸å…³è”çš„å‡½æ•°ï¼Œå…³è”å‡½æ•°æ˜¯é’ˆå¯¹ç±»å‹å®ç°çš„ï¼Œè€Œä¸æ˜¯å®ä¾‹ï¼Œå¯ä»¥ç†è§£ä¸ºé™æ€æ–¹æ³•
`new()`å‡½æ•°åœ¨å¾ˆå¤šç±»å‹ä¸­éƒ½æœ‰å®ç°ï¼Œåœ¨è¿™é‡Œå®ƒè¿”å›äº†ä¸€ä¸ªæ–°çš„ç©ºå­—ç¬¦ä¸²

å› æ­¤æ€»åœ°æ¥è¯´ï¼Œ`let mut guess = String::new()`åˆ›é€ äº†ä¸€ä¸ªå¯å˜å˜é‡guessï¼Œå°†å®ƒç»‘å®šåˆ°äº†Stringç±»å‹çš„ä¸€ä¸ªæ–°çš„ç©ºå®ä¾‹ä¸Š

`io.stdin().read_line(&mut guess)`ï¼šè°ƒç”¨äº†ioæ¨¡å—ä¸­çš„stdinå‡½æ•°ï¼Œstdinå‡½æ•°ä¼šè¿”å›ä¸€ä¸ª`std::io::Stdin`çš„å®ä¾‹ï¼Œè¿™ä¸ªç±»å‹ä»£è¡¨äº†ç»ˆç«¯çš„æ ‡å‡†è¾“å…¥å¥æŸ„
`read_line(&mut guess)`è°ƒç”¨äº†è¯¥ç±»å‹çš„read_lineæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†ç”¨æˆ·è¾“å…¥è¿½åŠ åˆ°å‚æ•°å­—ç¬¦ä¸²ä¸­ï¼Œå‚æ•°å­—ç¬¦ä¸²åº”è¯¥æ˜¯å¯å˜çš„
`&`è¯´æ˜äº†å‚æ•°æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œé¿å…äº†å†…å­˜ä¸­çš„æ•°æ®æ‹·è´ï¼Œåœ¨rustä¸­ï¼Œå¼•ç”¨é»˜è®¤ä¸ºå¸¸å¼•ç”¨ï¼Œå› æ­¤å¦‚æœè¦å¯¹å˜é‡è¿›è¡Œæ”¹å˜ï¼Œéœ€è¦åŠ ä¸Šmutå…³é”®å­—

`.expect("Falied to read line")`ï¼šread_lineæ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªResultå€¼ï¼ŒResultæ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œæšä¸¾ç±»å‹å˜é‡çš„å€¼å¯èƒ½æ˜¯å¤šç§å¯èƒ½çŠ¶æ€ä¸­çš„ä¸€ä¸ªï¼Œæ¯ç§å¯èƒ½çš„çŠ¶æ€ç§°ä¸ºä¸€ä¸ªæšä¸¾æˆå‘˜
Resultç±»å‹çš„æšä¸¾æˆå‘˜æœ‰Okå’ŒErrï¼ŒOkæˆå‘˜è¡¨ç¤ºæ“ä½œæˆåŠŸï¼ŒOkå†…åŒ…å«æˆåŠŸäº§ç”Ÿçš„å€¼ï¼ŒErræˆå‘˜è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼ŒErrå†…åŒ…å«å¤±è´¥ä¿¡æ¯
Resultç±»å‹çš„å®ä¾‹æœ‰expectæ–¹æ³•ï¼Œå¦‚æœç±»å‹çš„å€¼æ˜¯Errï¼Œè°ƒç”¨expectæ–¹æ³•æ—¶ï¼Œç¨‹åºç»ˆæ­¢å¹¶æ‰“å°æˆ‘ä»¬ä¼ å…¥çš„å‚æ•°ï¼Œå¦‚æœç±»å‹çš„å€¼æ—¶Okï¼Œexpectä¼šè·å–Okçš„å€¼å¹¶ç›´æ¥è¿”å›ï¼Œåœ¨æœ¬ä¾‹ä¸­è¿”å›çš„æ˜¯ç”¨æˆ·è¾“å…¥çš„å­—èŠ‚æ•°

å¦‚æœä¸ä½¿ç”¨expectæ–¹æ³•ï¼Œç¼–è¯‘æ—¶ä¼šäº§ç”Ÿè­¦å‘Šï¼Œrustä¼šè­¦å‘Šæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ç”±read_lineè¿”å›çš„Resultå€¼ï¼Œè¯´æ˜è¯¥ç¨‹åºæ— æ³•è§£å†³å¯èƒ½å‡ºç°çš„é”™è¯¯

ç”¨`cargo run`ç¼–è¯‘å¹¶è¿è¡Œï¼Œå‘ç°ç¨‹åºå¯ä»¥æ­£ç¡®ç¼–è¯‘ï¼Œè¯»å–ç”¨æˆ·è¾“å…¥å¹¶æ‰“å°ï¼Œè‡³æ­¤æˆ‘ä»¬å®Œæˆäº†ç¬¬ä¸€éƒ¨åˆ†

## 2.2 Adding Dependencies
rustç”Ÿæˆéšæœºæ•°çš„åŠŸèƒ½å¹¶ä¸åœ¨stdåº“å†…ï¼Œrustæä¾›äº†rand crateæ‰§è¡Œè¿™ä¸ªåŠŸèƒ½
crateæ˜¯ä¸€ä¸ªrustä»£ç åŒ…ï¼Œæ˜¯rustæºä»£ç æ–‡ä»¶çš„é›†åˆï¼Œæˆ‘ä»¬æ­£åœ¨æ„å»ºçš„é¡¹ç›®æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶crateï¼Œå®ƒç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œè€Œrand carteæ˜¯ä¸€ä¸ªåº“crateï¼Œåº“crateåŒ…å«äº†èƒ½è¢«ä»»æ„å…¶ä»–ç¨‹åºä½¿ç”¨çš„ä»£ç ï¼Œä½†æ˜¯ä¸èƒ½è‡ªå·±æ‰§è¡Œ

åœ¨æˆ‘ä»¬ä½¿ç”¨rand crateç¼–å†™ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹`Cargo.toml`æ–‡ä»¶ï¼Œå¼•å…¥ä¸€ä¸ªrandä¾èµ–ï¼š
```
[dependcies]
rand = "0.8.5"
```
*Cargo.toml*æ–‡ä»¶ä¸­çš„`[dependencies]`éƒ¨åˆ†ç”¨äºæŒ‡å®šæœ¬é¡¹ç›®ä¾èµ–çš„cratesåŠå…¶ç‰ˆæœ¬ï¼Œæœ¬ä¾‹ä¸­æˆ‘ä»¬ç”¨â€œ0.8.5â€æŒ‡å®šäº†randçš„è¯­ä¹‰åŒ–ç‰ˆæœ¬ï¼Œâ€œ0.8.5â€å®é™…ä¸Šæ˜¯â€œ^0.8.5"çš„ç¼©å†™ï¼Œè¡¨ç¤ºä»»ä½•è‡³å°‘æ˜¯0.8.5ä½†å°‘äº0.9.0çš„ç‰ˆæœ¬ï¼ŒCargoè®¤ä¸ºè¿™äº›ç‰ˆæœ¬çš„å…¬æœ‰apiå’Œ0.8.5ç‰ˆæœ¬çš„æ˜¯å…¼å®¹çš„ï¼Œè¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥ç¡®å®šå¾—åˆ°èƒ½ä½¿æœ¬ç« ä»£ç æ­£å¸¸ç¼–è¯‘çš„ï¼Œå«æœ‰æœ€æ–°è¡¥ä¸çš„ç‰ˆæœ¬ï¼Œä»»ä½•å¤§äºç­‰äº0.9.0çš„ç‰ˆæœ¬çš„apiåˆ™å¯èƒ½ä¼šæ”¹å˜

`cargo build`è¿›è¡Œç¼–è¯‘

Cargoä¼šä»registryä¸Šè·å–æ‰€æœ‰åŒ…çš„æœ€æ–°ç‰ˆæœ¬ä¿¡æ¯ï¼Œè¿™æ˜¯ä¸€ä»½å¯¹Crates.ioä¸Šçš„æ•°æ®çš„æ‹·è´ï¼ŒCrates.ioæ˜¯rustç”Ÿæ€ç¯å¢ƒä¸­çš„å¼€å‘è€…è´¡çŒ®å¼€æºé¡¹ç›®çš„åœ°æ–¹
Cargoä¼šåœ¨æ›´æ–°å®Œregistryåæ£€æŸ¥`[dependencies]`ç‰‡æ®µï¼Œå¹¶ä¸‹è½½åˆ—è¡¨ä¸­åŒ…å«ä½†è¿˜æœªä¸‹è½½çš„cratesï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼ŒCargoä¼šå°†randä¾èµ–çš„å…¶ä»–cratesä¸€å¹¶ä¸‹è½½ï¼Œä¸‹è½½å®Œä¾èµ–åï¼ŒCargoå…ˆç¼–è¯‘ä¾èµ–ï¼Œç„¶åç¼–è¯‘é¡¹ç›®

ä¹‹åè‹¥ä¿®æ”¹äº†æºä»£ç ï¼Œæ²¡æœ‰æ·»åŠ æ–°çš„ä¾èµ–ï¼Œ`cargo build`åªä¼šé‡æ–°ç¼–è¯‘æºä»£ç ï¼Œä¸ä¼šé‡å¤ç¼–è¯‘ä¾èµ–

åœ¨ç¬¬ä¸€æ¬¡æ„å»ºé¡¹ç›®æ—¶ï¼ŒCargoæ‰€æœ‰ä¾èµ–çš„ç¬¦åˆè¦æ±‚çš„ç‰ˆæœ¬å¹¶å°†å…¶å†™å…¥*Cargo.lock*æ–‡ä»¶ï¼Œåœ¨ä¹‹åé‡æ–°æ„å»ºé¡¹ç›®æ—¶ï¼ŒCargoä¼šå‘ç°*Cargo.lock*å·²å­˜åœ¨å¹¶ä½¿ç”¨å…¶ä¸­æŒ‡å®šçš„ç‰ˆæœ¬ï¼ŒCargoä»¥æ­¤ä¿è¯é¡¹ç›®çš„å¯é‡å¤æ„å»ºï¼Œå› æ­¤*Cargo.lock*ä¹Ÿä¼šè¢«çº³å…¥ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿ

å½“æˆ‘ä»¬ç¡®å®éœ€è¦å‡çº§crateæ—¶ï¼Œä½¿ç”¨`cargo update`ï¼ŒCargoä¼šå¿½ç•¥*Cargo.lock*æ–‡ä»¶ï¼Œå¹¶è®¡ç®—ç¬¦åˆ*Cargo.toml*å£°æ˜çš„æœ€æ–°ç‰ˆæœ¬ï¼Œç„¶åæ›´æ–°*Cargo.lock*ï¼Œå¦‚åœ¨æœ¬ä¾‹ä¸­ï¼Œrandå‘å¸ƒäº†0.8.6ç‰ˆæœ¬ï¼Œ`cargo update`ä¼šå¯¹å…¶è¿›è¡Œå‡çº§ï¼Œå¦‚æœæƒ³è¦ä½¿ç”¨0.9.0ä»¥ä¸Šçš„ç‰ˆæœ¬ï¼Œåˆ™éœ€è¦æ˜¾å¼åœ°ä¿®æ”¹*Cargo.toml*ï¼Œåœ¨ä¸‹ä¸€æ¬¡çš„`cargo build`æ—¶ï¼ŒCargoå°±ä¼šä»registryä¸Šè·å–ç¬¦åˆè¦æ±‚çš„æœ€æ–°çš„crate

## 2.3 Generating Random Numbers
ä¿®æ”¹*main.rs*ï¼š
```rust
use std::io;
use rand::Rng;
fn main() {
	println!("Guess the number!"); 
	
	let secret_number = rand::thread_rng().gen_range(1..=100);
	
	 println!("The secret number is: {secret_number}"); 
	 
	 println!("Please input your guess."); 
	 
	 let mut guess = String::new(); 
	 
	 io::stdin() 
		 .read_line(&mut guess) 
		 .expect("Failed to read line"); 
	 
	 println!("You guessed: {guess}"); 
}
```
è§£é‡Šï¼š
`rand::Rng`æ˜¯ä¸€ä¸ªtraitï¼Œå®šä¹‰äº†éšæœºæ•°ç”Ÿæˆåº”è¯¥å®ç°çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å°†è¿™ä¸ªtraitåŠ å…¥ä½œç”¨åŸŸï¼Œ`rand::thread_rng()`å‡½æ•°æä¾›äº†éšæœºæ•°ç”Ÿæˆå™¨ï¼Œå®ƒä½äºå½“å‰æ‰§è¡Œçº¿ç¨‹çš„æœ¬åœ°ç¯å¢ƒä¸­ï¼Œä»æ“ä½œç³»ç»Ÿè·å–seedï¼Œ`gen_range()`æ˜¯ç”Ÿæˆå™¨çš„ä¸€ä¸ªæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç”±`rand::Rng`è¿™ä¸ªtraitå®šä¹‰ï¼ŒèŒƒå›´è¡¨è¾¾å¼`1..=100`ä½œä¸ºå…¶å‚æ•°ï¼Œæ³¨æ„è¿™ä¸ªèŒƒå›´è¡¨è¾¾å¼åŒ…å«äº†ä¸Šä¸‹ç•Œ

æ³¨ï¼šæ¯ä¸ªcrateéƒ½æœ‰æ–‡æ¡£ï¼Œ`cargo doc --open`ä¼šæ„å»ºæ‰€æœ‰æœ¬åœ°ä¾èµ–æä¾›çš„æ–‡æ¡£ï¼Œåœ¨æµè§ˆå™¨æ‰“å¼€ï¼Œæˆ‘ä»¬å¯ä»¥å€Ÿæ­¤æŸ¥çœ‹randçš„æ–‡æ¡£

`cargo run`è¿è¡Œç¨‹åº

## 2.4 Comparing Guessing Number And Random Number
ä¿®æ”¹*main.rs*ï¼š
```rust
use rand::Rng; 
use std::cmp::Ordering; 
use std::io; 

fn main() { 
// --snip-- 
	println!("You guessed: {guess}"); 
	
	match guess.cmp(&secret_number) { 
		Ordering::Less => println!("Too small!"), 
		Ordering::Greater => println!("Too big!"), 
		Ordering::Equal => println!("You win!"), 
	} 
}
```
è§£é‡Šï¼š
`use std::cmp::Ordering`å°†æ ‡å‡†åº“çš„Orderingç±»å‹ä»£å…¥ä½œç”¨åŸŸï¼ŒOrderingä¹Ÿæ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œæœ‰ä¸‰ä¸ªæˆå‘˜Lessï¼ŒGreaterï¼ŒEqual
Stringå®ä¾‹çš„cmpæ–¹æ³•ç”¨äºæ¯”è¾ƒä¸¤ä¸ªå€¼ï¼Œå®ƒçš„å‚æ•°æ˜¯ä¸€ä¸ªè¢«æ¯”è¾ƒå€¼çš„å¼•ç”¨ï¼Œå³secret_numberï¼Œå¹¶è¿”å›ä¸€ä¸ªOrderingç±»å‹çš„æˆå‘˜ï¼Œæˆ‘ä»¬ä½¿ç”¨matchè¡¨è¾¾å¼ï¼Œæ ¹æ®è¿”å›çš„æ˜¯å“ªä¸€ä¸ªæˆå‘˜ï¼Œä½œå‡ºç›¸åº”çš„åŠ¨ä½œ

ä¸€ä¸ªmatchè¡¨è¾¾å¼ç”±å¤šä¸ªåˆ†æ”¯æ„æˆï¼Œæ¯ä¸ªåˆ†æ”¯éƒ½åŒ…å«è¦åŒ¹é…çš„æ¨¡å¼ä»¥åŠæ¨¡å¼åŒ¹é…æ—¶çš„ä»£ç ï¼Œmatchä¼šé¡ºåºè¿›è¡ŒåŒ¹é…ï¼Œå¹¶åœ¨å¾—åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…åæ‰§è¡ŒåŠ¨ä½œå¹¶é€€å‡º

ä½†ä»£ç ç°åœ¨è¿˜ä¸èƒ½ç¼–è¯‘é€šè¿‡ï¼Œé”™è¯¯çŠ¶æ€ä¸ºmismatched typesï¼Œå³ä¸åŒ¹é…çš„ç±»å‹ï¼Œrustæœ‰é™æ€å¼ºç±»å‹ç³»ç»Ÿï¼Œä¹Ÿæœ‰ç±»å‹æ¨æ–­ï¼Œåœ¨`let mut guess = String::new()`ä¸­ï¼Œrustæ¨æ–­guessä¸ºStringç±»å‹ï¼Œè€Œsecret_numberä¸ºæ•°å­—ç±»å‹ï¼Œé»˜è®¤æ˜¯i32ï¼Œè¯¥é”™è¯¯çš„åŸå› æ˜¯Stringç±»å‹å’Œi32ç±»å‹ä¸èƒ½æ¯”è¾ƒ

æˆ‘ä»¬éœ€è¦å°†Stringç±»å‹è½¬æ¢ä¸ºæ•°å­—ç±»å‹ï¼š`let guess: u32 = guess.trim().parse().expect("Please type a number!")`ï¼Œæˆ‘ä»¬åˆ›é€ äº†ä¸€ä¸ªæ–°çš„å˜é‡guessï¼Œå®ƒå…¶å®æ˜¯ç”¨ä¸€ä¸ªæ–°å€¼éšè—äº†guessæ—§çš„å€¼ï¼Œè¿™ä¸ªç‰¹æ€§å¸¸ç”¨äºç±»å‹è½¬æ¢

Stringå®ä¾‹çš„`trim()`æ–¹æ³•ä¼šå»é™¤å­—ç¬¦ä¸²å¼€å¤´å’Œç»“å°¾çš„ä»»æ„ç©ºç™½å­—ç¬¦ï¼Œå› ä¸ºåœ¨è¾“å…¥çš„æ—¶å€™ç”¨æˆ·å¿…é¡»è¾“å…¥Enteré”®æ‰å¯ä»¥è®©`read_line()`è¿”å›ï¼Œè€Œ`read_line()`ä¼šå¯¹å…¶è¿›è¡Œè¯»å–ï¼Œåœ¨Windowsä¸­ï¼Œå­—ç¬¦ä¸²åä¼šè¢«æ·»åŠ ä¸Š\\r\\nï¼Œå› æ­¤éœ€è¦å°†å…¶å»é™¤

Stringå®ä¾‹çš„`pares()`æ–¹æ³•ç”¨äºå°†Stringè½¬åŒ–ä¸ºå…¶ä»–ç±»å‹ï¼Œæˆ‘ä»¬é€šè¿‡`let guess: u32`æŒ‡å®šäº†ç±»å‹ï¼Œä¹‹årustä¼šå°†secret_numbertä¹Ÿæ¨æ–­ä¸ºu32ç±»å‹ï¼Œå°±å¯ä»¥è¿›è¡Œæ¯”è¾ƒäº†

`parse()`æ–¹æ³•ä¹Ÿä¼šè¿”å›ä¸€ä¸ªResultç±»å‹ä»¥è¿›è¡Œé”™è¯¯å¤„ç†ï¼Œå¦‚æœæˆåŠŸè½¬æ¢ï¼Œè¿”å›Okç±»å‹ï¼Œ`expect()`æ–¹æ³•ä¼šè¿”å›Okç±»å‹å†…å«çš„å€¼ï¼Œå³è½¬æ¢åçš„æ•°å­—ï¼Œå¦åˆ™æ‰“å°é”™è¯¯ä¿¡æ¯å¹¶è¿”å›

## 2.5 Using Loop to Allow Multiple Attempts
å¯ä»¥åˆ©ç”¨loopå…³é”®å­—åˆ›é€ æ— é™å¾ªç¯ï¼š
```rust
// --snip-- 
	println!("The secret number is: {secret_number}"); 
	loop { 
		println!("Please input your guess."); 
		// --snip-- 
		match guess.cmp(&secret_number) { 
			Ordering::Less => println!("Too small!"), 
			Ordering::Greater => println!("Too big!"), 
			Ordering::Equal => println!("You win!"), 
		} 
	} 
}
```
ç”¨æˆ·ç°åœ¨å¯ä»¥ctrl+cé€€å‡ºå¾ªç¯ï¼Œæˆ–å¯ä»¥åˆ©ç”¨å¯¹`parse()`çš„`expect()`å¤„ç†æ¥é€€å‡ºå¾ªç¯

æˆ‘ä»¬å¯ä»¥ç”¨breakå…³é”®å­—ï¼Œåœ¨çŒœæµ‹æˆåŠŸåé€€å‡ºå¾ªç¯ï¼š
```rust
// --snip-- 
		match guess.cmp(&secret_number) { 
			Ordering::Less => println!("Too small!"), 
			Ordering::Greater => println!("Too big!"), 
			Ordering::Equal => { 
				println!("You win!"); 
				break; 
			} 
		} 
	} 
}
```

å¯¹ç¨‹åºæ”¹è¿›ï¼Œåœ¨å¤„ç†æ— æ•ˆè¾“å…¥æ—¶ï¼Œå¿½ç•¥ç”¨æˆ·çš„æ— æ•ˆè¾“å…¥ï¼Œè®©ç”¨æˆ·ç»§ç»­çŒœæµ‹ï¼Œè€Œä¸æ˜¯ç»ˆæ­¢ç¨‹åºï¼š
```rust
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {guess}");

        // --snip--

```
æˆ‘ä»¬ä½¿ç”¨matchè¯­å¥è¿›è¡Œé”™è¯¯å¤„ç†ï¼Œå› ä¸º`parse()`è¿”å›çš„æ˜¯Resultç±»å‹ï¼Œå¦‚æœè¿”å›ä¸€ä¸ªåŒ…å«æ•°å­—ç»“æœçš„Okï¼Œè¿”å›æ•°å­—ï¼Œå¦‚æœè¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯ä¿¡æ¯çš„Errï¼Œ\_æ˜¯ä¸€ä¸ªé€šé…ç¬¦ï¼Œæœ¬ä¾‹ä¸­ç”¨äºåŒ¹é…æ‰€æœ‰çš„Errå€¼ï¼Œcontinueè¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯

æœ€ååˆ é™¤å°†sercret_numberæ‰“å°çš„è¯­å¥å³å¯å®Œæˆè¿™ä¸ªæ¸¸æˆ

# 3 Common Programming Concepts
## 3.1 Variables and Mutability
### 3.1.1 Variables
é»˜è®¤æƒ…å†µä¸‹ï¼Œå˜é‡æ˜¯ä¸å¯æ”¹å˜çš„

`cargo new variables`ç”Ÿæˆæ–°é¡¹ç›®
ä¿®æ”¹*main.rs*ï¼š
```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
`cargo run`å‘ç°ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºä¸èƒ½å¯¹ä¸å¯å˜å˜é‡xäºŒæ¬¡èµ‹å€¼

æ·»åŠ mutå…³é”®å­—å°±å¯ä»¥æ„é€ å¯å˜å˜é‡
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
æ­¤æ—¶å¯ä»¥æ­£å¸¸ç¼–è¯‘è¿è¡Œ

### 3.1.2 Constants
å¸¸é‡ä¹Ÿæ˜¯ç»‘å®šåˆ°ä¸€ä¸ªåç§°çš„ä¸å¯æ”¹å˜çš„å€¼ï¼Œä½†å®ƒå’Œå˜é‡æœ‰æ‰€åŒºåˆ«ï¼š
(1) ä¸å…è®¸å¯¹å¸¸é‡ä½¿ç”¨mutå…³é”®å­—ï¼Œå¸¸é‡åªèƒ½ç”¨constå…³é”®å­—å£°æ˜ï¼Œä¸”å¿…é¡»æ³¨æ˜å€¼çš„ç±»å‹
(2) å¸¸é‡å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
(3) å¸¸é‡çš„å€¼åªèƒ½ç”±å¸¸é‡è¡¨è¾¾å¼è®¾å®šï¼Œä¸èƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—

å£°æ˜ä¸€ä¸ªå¸¸é‡ï¼š
`const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`
rustå¯¹å¸¸é‡çš„å‘½åè§„èŒƒæ˜¯å…¨å¤§å†™ï¼Œå•è¯é—´ä¸‹åˆ’çº¿éš”å¼€ï¼Œç¼–è¯‘å™¨å¯ä»¥åœ¨ç¼–è¯‘æ—¶è®¡ç®—ä¸€ç»„æœ‰é™çš„æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨è®¡ç®—è¡¨è¾¾å¼çš„æ–¹å¼ç»™å¸¸é‡èµ‹å€¼

å¸¸é‡åœ¨å®ƒçš„è¢«å£°æ˜çš„ä½œç”¨åŸŸå†…åœ¨æ•´ä¸ªç¨‹åºå‘¨æœŸéƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œ


### 3.1.3 Shadowing
æˆ‘ä»¬å¯ä»¥å£°æ˜ä¸€ä¸ªå’Œä¹‹å‰å£°æ˜è¿‡çš„å˜é‡å®Œå…¨åŒåçš„å˜é‡ï¼Œåœ¨rustä¸­ï¼Œè¿™ç§°ä¸ºç¬¬ä¸€ä¸ªå˜é‡è¢«ç¬¬äºŒä¸ªå˜é‡éšè—äº†ï¼Œæ­¤æ—¶ä»»ä½•ä½¿ç”¨è¯¥å˜é‡çš„è¡Œä¸ºéƒ½ä¼šè¢«è®¤ä¸ºæ˜¯åœ¨ä½¿ç”¨ç¬¬äºŒä¸ªå˜é‡ï¼Œç›´åˆ°ç¬¬äºŒä¸ªå˜é‡è‡ªå·±ä¹Ÿè¢«éšè—æˆ–æ˜¯ä½œç”¨åŸŸç»“æŸ

æ¯”å¦‚ï¼š
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
æˆ‘ä»¬å…ˆå°†xçš„å€¼ç»‘å®šä¸º5ï¼Œç„¶ååˆ›å»ºäº†ä¸€ä¸ªæ–°çš„xå˜é‡ï¼Œå€¼ä¸º6ï¼Œç„¶ååœ¨èŠ±æ‹¬å·çš„å†…éƒ¨ä½œç”¨åŸŸä¸­ï¼Œç¬¬ä¸‰ä¸ªletè¯­å¥åˆ›å»ºäº†æ–°çš„xå˜é‡ï¼Œå€¼ä¸º12ï¼Œè¯¥ä½œç”¨åŸŸç»“æŸåï¼Œéšè—ç»“æŸï¼Œxçš„å€¼å˜ä¸º6

éšè—æ˜¯ç”¨letå…³é”®å­—å®Œæˆçš„ï¼Œå’Œå£°æ˜ä¸€ä¸ªmutableå˜é‡ä¸åŒï¼Œç”¨letå…³é”®å­—å®šä¹‰çš„å˜é‡ä»ç„¶æ˜¯ä¸å¯å˜çš„
åœ¨æˆ‘ä»¬å†æ¬¡ä½¿ç”¨letæ—¶ï¼Œå®é™…ä¸Šæ—¶åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå› æ­¤å˜é‡çš„ç±»å‹å¯ä»¥å®Œå…¨ä¸åŒï¼Œå¦‚ï¼š
```rust
let spaces = "    "; // string type
let spaces = spaces.len(); // number type
```
å¦‚æœä½¿ç”¨mutå…³é”®å­—ï¼Œåˆ™ä¸è¡Œï¼š
```rust
let mut spaces = "    ";
spaces = spaces.len();
```
ç¼–è¯‘å™¨ä¼šå‘Šè¯‰æˆ‘ä»¬ä¸èƒ½æ”¹å˜å˜é‡çš„ç±»å‹

## 3.2 Data Types
rustæœ‰ä¸¤ä¸ªæ•°æ®ç±»å‹å­é›†ï¼šæ ‡é‡(scalar)å’Œå¤åˆ(compound)

rustæ˜¯ä¸€ä¸ªé™æ€ç±»å‹è¯­è¨€ï¼Œå³åœ¨ç¼–è¯‘æ—¶å°±è¦çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œç¼–è¯‘å™¨é€šå¸¸å¯ä»¥é€šè¿‡å˜é‡çš„å€¼å’Œä½¿ç”¨æ–¹å¼æ¨æ–­å‡ºå˜é‡çš„ç±»å‹ï¼Œä½†å¦‚æœå¤šç§ç±»å‹éƒ½æœ‰å¯èƒ½æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ˜¾å¼æ³¨æ˜ç±»å‹ï¼Œå¦‚ç”¨`parse()`å°†Stringè½¬æ¢ä¸ºæ•°å­—æ—¶ï¼š
`let guess: u32 = "42".parse().expect("Not a Number!");`
å¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™

### 3.2.1 Scalar Types
æ ‡é‡ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ç‹¬çš„å€¼ï¼Œrustçš„å››ä¸ªåŸºæœ¬æ ‡é‡ç±»å‹ï¼šæ•´å‹ï¼Œæµ®ç‚¹æ•°ï¼Œå¸ƒå°”ç±»å‹ï¼Œå­—ç¬¦ç±»å‹

**Integer Typesï¼š**
rustçš„å†…ç½®æ•´å‹ç±»å‹ï¼š
i8ï¼Œi16ï¼Œi32ï¼Œi64ï¼Œi128ï¼Œisize
u8ï¼Œu16ï¼Œu32ï¼Œu64ï¼Œu128ï¼Œusize
æœ‰ç¬¦å·æ•°ä»¥è¡¥ç å½¢å¼å­˜å‚¨

æœ‰ç¬¦å·æ•°çš„å­˜å‚¨èŒƒå›´æ˜¯$[-2^{n-1}, 2^{n-1}-1]$
æ— ç¬¦å·æ˜¯çš„å­˜å‚¨èŒƒå›´æ˜¯$[0, 2^n-1]$

isizeï¼Œusizeçš„å­˜å‚¨ä½æ•°ä¾èµ–äºè®¡ç®—æœºæ¶æ„ï¼Œ32ä½æ¶æ„å°±æ˜¯32ä½ï¼Œ64ä½æ¶æ„å°±æ˜¯64ä½

rustä¸­çš„æ•´å‹å­—é¢å€¼ï¼š
åè¿›åˆ¶å¦‚ï¼š`98_222`
åå…­è¿›åˆ¶å¦‚ï¼š`0xff`
å…«è¿›åˆ¶å¦‚ï¼š`0o77`
äºŒè¿›åˆ¶å¦‚ï¼š`0b1111_0000`
å•å­—èŠ‚å­—ç¬¦(ä»…é™u8)å¦‚ï¼š`b'A'`

rusté»˜è®¤æ•´å‹ç±»å‹æ˜¯i32

rusté­é‡æ•´å‹æº¢å‡ºï¼š
1. åœ¨debugæ¨¡å¼ç¼–è¯‘æ—¶ï¼š
rustä¼šæ£€æŸ¥è¿™ç±»é—®é¢˜å¹¶ä½¿ç¨‹åºpanicï¼Œrustç”¨panicè¡¨ç¤ºç¨‹åºå› é”™è¯¯è€Œé€€å‡º
2. ä½¿ç”¨`--release`flagç¼–è¯‘æ—¶ï¼š
rustä¸ä¼šæ£€æŸ¥æ•´å‹æº¢å‡ºï¼Œæº¢å‡ºæ—¶ï¼Œå› ä¸ºè¡¥ç çš„ç¼˜æ•…ï¼Œæ•´å‹çš„å€¼ä¸ä¼šæ˜¯æœŸæœ›çš„å€¼

**Floating-Point Typesï¼š**
rustçš„æµ®ç‚¹æ•°ç±»å‹åŒ…æ‹¬f32å’Œf64ï¼Œé»˜è®¤ä¸ºf64ï¼Œæ‰€æœ‰æµ®ç‚¹å‹éƒ½æ˜¯æœ‰ç¬¦å·çš„
å¦‚ï¼š
```rust
fn main() {
    let x = 2.0; // é»˜è®¤f64ï¼ŒåŒç²¾åº¦

    let y: f32 = 3.0; // f32ï¼Œå•ç²¾åº¦
}
```

è¡¥å……rustçš„æ•°å€¼è¿ç®—ï¼š
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // ç»“æœä¸º -1ï¼Œæ•´æ•°é™¤æ³•ä¼šå‘é›¶å–æ•´

    // remainder
    let remainder = 43 % 5;
}

```

**Boolean Typeï¼š**
åªæœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼štrueå’Œfalse
å¦‚ï¼š
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

(4) Character Type
å¦‚ï¼š
```rust
fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // with explicit type annotation
    let heart_eyed_cat = 'ğŸ˜»';
}
```
rustçš„charç±»å‹å¤§å°ä¸º4ä¸ªå­—èŠ‚32ä½ï¼Œä»£è¡¨äº†ä¸€ä¸ªUnicodeæ ‡é‡å€¼ï¼Œrustä¸­ï¼Œå¸¦å˜éŸ³ç¬¦å·çš„å­—æ¯ï¼Œä¸­æ–‡ï¼Œæ—¥æ–‡ï¼ŒéŸ©æ–‡ï¼Œemojiå’Œ0é•¿åº¦çš„ç©ºç™½å­—ç¬¦éƒ½æ˜¯æœ‰æ•ˆçš„chartå€¼ï¼ŒUnicodeæ ‡é‡å€¼çš„èŒƒå›´ä»`U+0000`åˆ°`U+D7FF`å’Œä»`U+E000`åˆ°`U+10FFFF`

### 3.2.2 Compound Types
rustçš„å¤åˆç±»å‹åŒ…æ‹¬å…ƒç»„(tuple)å’Œæ•°ç»„(array)

**Tuple Typeï¼š**
å…ƒç»„çš„é•¿åº¦å›ºå®šï¼Œä¸€æ—¦å£°æ˜ï¼Œä¸ä¼šå˜åŒ–
å…ƒç»„ä¸­å¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„å€¼ï¼Œå¦‚ï¼š
`let tup: (i32, f64, u8) = (500, 6.4, 1);`

æˆ‘ä»¬å¯ä»¥ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„å…ƒç»„çš„å€¼ï¼Œå¦‚ï¼š
`let (x, y, z) = tup;`

å¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®å…ƒç»„çš„å€¼ï¼Œå¦‚ï¼š
`let five_hundred = x.0;`
`let six_point_four = x.1;`
`let one = x.2;`

ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„å«å•å…ƒç»„(unit)ï¼Œå®ƒçš„å€¼å’Œå¯¹åº”çš„ç±»å‹éƒ½å†™ä½œ`()`ï¼Œè¡¨ç¤ºç©ºçš„å€¼æˆ–ç©ºçš„è¿”å›ç±»å‹ï¼Œå¦‚æœè¡¨è¾¾å¼ä¸è¿”å›å…¶å®ƒä»»ä½•å€¼ï¼Œåˆ™ä¼šéšå¼åœ°è¿”å›å•å…ƒå€¼(unit value)

**Array Typeï¼š**
æ•°ç»„åªèƒ½åŒ…å«åŒç±»å‹çš„å€¼ï¼Œrustä¸­æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯å›ºå®šçš„
æ•°ç»„åœ¨æ ˆä¸Šä¸ºç¨‹åºåˆ†é…ç©ºé—´ï¼Œæ˜¯å·²çŸ¥å¤§å°çš„å•ä¸ªå†…å­˜å—

æ•°ç»„çš„å£°æ˜ï¼š
`let a = [1, 2, 3, 4, 5];`
`let a: [i32; 5] = [1, 2, 3, 4, 5];`i32æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹ï¼Œ5æ˜¯æ•°ç»„çš„é•¿åº¦
`let a = [3; 5];`ç­‰ä»·äº`let a = [3, 3, 3, 3, 3];`

è®¿é—®æ•°ç»„å…ƒç´ ï¼š
`let first = a[0]`
`let second = a[1]`

å¦‚æœåœ¨è¿è¡Œæ—¶å‘ç”Ÿäº†æ•°ç»„è¶Šç•Œï¼Œä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯(runtime error)ï¼Œç¨‹åºä¼šæºå¸¦é”™è¯¯ä¿¡æ¯é€€å‡ºï¼Œrustä¼šæ£€æŸ¥æŒ‡å®šçš„ç´¢å¼•æ˜¯å¦å°äºæ•°ç»„çš„é•¿åº¦ï¼Œå¦‚æœè¶…è¿‡äº†ï¼Œrustä¼španicï¼Œè¿™ç§æ£€æŸ¥å¿…é¡»åœ¨è¿è¡Œæ—¶è¿›è¡Œï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸å¯èƒ½çŸ¥é“ç”¨æˆ·åœ¨ä»¥åè¿è¡Œä»£ç æ—¶å°†è¾“å…¥ä»€ä¹ˆå€¼

## 3.3 Functions
rustä½¿ç”¨fnå…³é”®å­—å£°æ˜å‡½æ•°ï¼Œå‡½æ•°å‘½åéµå¾ªå…¨éƒ¨å°å†™å¹¶ä¸‹åˆ’çº¿éš”å¼€çš„è§„åˆ™
å‡½æ•°å®šä¹‰ç¤ºä¾‹ï¼š
```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```
rustä¸­å‡½æ•°å®šä¹‰çš„ä½ç½®æ²¡æœ‰å½±å“ï¼Œåªè¦å‡½æ•°è¢«å®šä¹‰åœ¨äº†è°ƒç”¨è¯¥å‡½æ•°è€…å¯è§çš„ä½œç”¨åŸŸå†…

**Parametersï¼š**
å‚æ•°ä¹Ÿæ˜¯å‡½æ•°ç­¾åçš„ä¸€éƒ¨åˆ†
å‚æ•°ä½¿ç”¨ç¤ºä¾‹ï¼š
```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
```

rustè§„å®šåœ¨å‡½æ•°ç­¾åä¸­æˆ‘ä»¬å¿…é¡»æ˜¾å¼å£°æ˜æ¯ä¸ªå‚æ•°çš„ç±»å‹

å¤šä¸ªå‚æ•°ç”¨é€—å·éš”å¼€

**Statements and Expressionsï¼š**
å‡½æ•°ä½“æ˜¯ç”±ä¸€ç³»åˆ—çš„è¯­å¥å’Œä¸€ä¸ªå¯é€‰çš„çš„ç»“å°¾è¡¨è¾¾å¼æ„æˆçš„

åœ¨rustä¸­ï¼Œè¯­å¥å’Œè¡¨è¾¾å¼æ˜¯ä¸åŒçš„ï¼š
è¯­å¥æ˜¯æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œä½†ä¸è¿”å›å€¼çš„æŒ‡ä»¤
è¡¨è¾¾å¼æ˜¯åˆ™ä¼šè®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªç»“æœå€¼

ä½¿ç”¨letå…³é”®å­—åˆ›é€ ä¸€ä¸ªå˜é‡å¹¶ç»‘å®šä¸€ä¸ªå€¼æ˜¯è¯­å¥ï¼Œå¦‚ï¼š`let y = 5;`
å‡½æ•°å®šä¹‰ä¹Ÿæ˜¯ä¸€ä¸ªè¯­å¥ï¼Œå¦‚ï¼š
```rust
fn main(){
	let y = 5; 
}
```

è¯­å¥ä¸ä¼šè¿”å›å€¼ï¼Œå› æ­¤ä¸èƒ½å°†letè¯­å¥èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œå¦‚ï¼š
`let x = (let y = 5);`
ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯

è¡¨è¾¾å¼ä¼šè®¡ç®—å‡ºä¸€ä¸ªå€¼ï¼Œå¦‚`5 + 6`ï¼Œè¿™æ˜¯ä¸€ä¸ªä¼šè®¡ç®—å‡ºå€¼11çš„è¡¨è¾¾å¼ï¼Œè¡¨è¾¾å¼å¯ä»¥æ˜¯è¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œå¦‚`let y = 5;`ä¸­çš„`5`å°±æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå€¼æ˜¯5
å‡½æ•°è°ƒç”¨ä¹Ÿæ˜¯è¡¨è¾¾å¼ ï¼Œå®è°ƒç”¨ä¹Ÿæ˜¯è¡¨è¾¾å¼
ç”¨å¤§æ‹¬å·åˆ›é€ ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼Œå¦‚ï¼š
```rust
fn main(){
	let y = {
		let x = 3;
		x + 1;
	}

	println!("The value of y is: {y}");
}
```
è¿™ä¸ªè¡¨è¾¾å¼ï¼š
```rust
{
    let x = 3;
    x + 1
}
```
æ˜¯ä¸€ä¸ªä»£ç å—ï¼Œå€¼æ˜¯4ï¼Œè¿™ä¸ªè¡¨è¾¾å¼æ˜¯letè¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œè¡¨è¾¾å¼çš„ç»“å°¾æ²¡æœ‰åˆ†å·ï¼Œå¦‚æœåŠ ä¸Šäº†åˆ†å·ï¼Œä¼šå°†å…¶å˜æˆè¯­å¥ï¼Œè€Œè¯­å¥ä¸ä¼šè¿”å›å€¼

**Functions with Return Valuesï¼š**
å¦‚æœå‡½æ•°æœ‰è¿”å›å€¼ï¼Œæˆ‘ä»¬éœ€è¦å£°æ˜å®ƒçš„ç±»å‹ï¼Œå¦‚ï¼š
```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
```
rustä¸­å‡½æ•°çš„è¿”å›å€¼ç­‰åŒäºå‡½æ•°ä½“æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼Œç”¨returnå…³é”®å­—ä¹Ÿå¯ä»¥æå‰è¿”å›

è¿è¡Œè¿™æ ·çš„ä»£ç ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼š
```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```
å‡½æ•°`plus_one()`åº”è¿”å›ä¸€ä¸ªi32çš„å€¼ï¼Œä½†è¯­å¥ä½¿ç”¨äº†å•ä½ç±»å‹`()`è¡¨ç¤ºä¸è¿”å›å€¼ï¼Œå’Œå‡½æ•°å®šä¹‰çŸ›ç›¾ï¼Œäº§ç”Ÿäº†mismatched typeé”™è¯¯

## 3.4 Comments
ç¤ºä¾‹ï¼š
```rust
fn main() {
    // Iâ€™m feeling lucky today
    let lucky_number = 7;
}

fn main() {
    let lucky_number = 7; // Iâ€™m feeling lucky today
}

// So weâ€™re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain whatâ€™s going on.
```
æ³¨é‡Šå¯ä»¥æ”¾åœ¨ä»£ç ä¸Šæˆ–ä»£ç å

## 3.5 Control Flow
### 3.5.1 if Expressions
ç¤ºä¾‹ï¼š
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

éœ€è¦æ³¨æ„æ¡ä»¶ä¸€å®šè¦æ˜¯å¸ƒå°”å€¼ï¼Œå¦åˆ™ä¼šé”™è¯¯ï¼Œå¦‚ï¼š
```rust
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```
rustä¸ä¼šéšå¼åœ°å°†éå¸ƒå°”å€¼è½¬æ¢ä¸ºå¸ƒå°”å€¼

æ˜¯ç”¨else ifå¤„ç†å¤šé‡æ¡ä»¶ï¼š
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

ifæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨letä¸­ä½¿ç”¨å®ƒï¼š
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```
æ³¨æ„ä»£ç å—çš„å€¼å°±æ˜¯æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼Œå› æ­¤ifè¡¨è¾¾å¼çš„å€¼å–å†³äºå“ªä¸€ä¸ªä»£ç å—è¢«æ‰§è¡Œï¼Œè¿™æ„å‘³ç€ifçš„æ¯ä¸ªåˆ†æ”¯çš„å¯èƒ½è¿”å›å€¼éƒ½å¿…é¡»æ˜¯åŒä¸€ä¸ªç±»å‹ï¼Œå¦‚æœä¸æ˜¯çš„è¯ï¼Œä¼šç¼–è¯‘å‡ºé”™ï¼Œå¦‚ï¼š
```rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
```
å› ä¸ºå˜é‡å¿…é¡»æœ‰ä¸€ä¸ªç±»å‹ï¼Œrustå¿…é¡»è¦åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“å˜é‡numberçš„ç±»å‹ï¼Œä»¥éªŒè¯å˜é‡numberåœ¨å…¶ä»–å¤„çš„æœ‰æ•ˆä½¿ç”¨

### 3.5.2 Repetition with Loops
ruståŒ…å«ä¸‰ç§å¾ªç¯ï¼šloopï¼Œwhileï¼Œfor

**loopï¼š**
ç¤ºä¾‹ï¼š
```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

loopå¯ä»¥ç”¨äºæ£€æŸ¥å¯èƒ½ä¼šå¤±è´¥çš„æ“ä½œï¼Œå¦‚æ£€æŸ¥çº¿ç¨‹æ˜¯å¦å®Œæˆäº†ä»»åŠ¡ï¼Œå¦‚æœéœ€è¦å°†æ“ä½œçš„ç»“æœä¼ é€’ç»™loopä»¥å¤–çš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿”å›å€¼åŠ å…¥ç”¨äºåœæ­¢å¾ªç¯çš„breakè¡¨è¾¾å¼ï¼Œå®ƒä¼šè¢«åœæ­¢çš„å¾ªç¯è¿”å›ï¼Œå¦‚ï¼š
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```
æ³¨æ„loopè¡¨è¾¾å¼æ˜¯letè¯­å¥çš„ä¸€éƒ¨åˆ†

ç”¨å¾ªç¯æ ‡ç­¾åœ¨å¤šä¸ªå¾ªç¯é—´æ¶ˆé™¤æ­§ä¹‰
å¦‚æœå­˜åœ¨åµŒå¥—å¾ªç¯ï¼Œbreakå’Œcontinueä¸€èˆ¬åªä½œç”¨äºå†…å±‚å¾ªç¯ï¼Œä½†æˆ‘ä»¬å¯ä»¥å¯¹ä¸€ä¸ªloopæŒ‡å®šä¸€ä¸ªloop labelï¼Œå°†è¯¥æ ‡ç­¾ä¸breakæˆ–continueä¸€èµ·ä½¿ç”¨ä»¥æŒ‡æ˜å…³é”®å­—ä½œç”¨çš„å¾ªç¯æ˜¯å“ªä¸€ä¸ªï¼Œå¦‚ï¼š
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```
å¤–å±‚å¾ªç¯çš„æ ‡ç­¾æ˜¯`'counting_up`ï¼Œå†…å±‚å¾ªç¯çš„ç¬¬ä¸€ä¸ªbreakä¼šé€€å‡ºå†…å±‚å¾ªç¯ï¼Œè€Œ`break 'counting_up`åˆ™ä¼šé€€å‡ºå¤–å±‚å¾ªç¯

**whileï¼š**
ç¤ºä¾‹ï¼š
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

**forï¼š**
ä½¿ç”¨forå¾ªç¯å¯¹ä¸€ä¸ªé›†åˆçš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œä¸€äº›ä»£ç ï¼š
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

ç”¨forå¾ªç¯æ¥å€’è®¡æ—¶ï¼š
```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```
å…¶ä¸­çš„`rev()`æ–¹æ³•ç”¨äºåè½¬`Range`

# 4 Understanding Ownership
### 4.1 What Is Ownership
æ‰€æœ‰æƒæ˜¯ä¸€ç³»åˆ—rustç”¨äºå…³äºç¨‹åºå†…å­˜çš„è§„åˆ™ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šè¿›è¡Œæ£€æŸ¥ï¼Œå¦‚æœå…¶ä¸­çš„ä»»æ„ä¸€ä¸ªè§„åˆ™è¢«è¿åï¼Œåˆ™ç¼–è¯‘ä¸ä¼šæˆåŠŸï¼Œå› æ­¤æ‰€æœ‰æƒç³»ç»Ÿçš„ä»»ä½•åŠŸèƒ½éƒ½ä¸ä¼šåœ¨è¿è¡Œæ—¶å‡æ…¢ç¨‹åº

è¡¥å……ï¼šå…³äºå †å’Œæ ˆ
å †å’Œæ ˆéƒ½æ˜¯è¿è¡Œæ—¶å¯ä¾›ä»£ç ä½¿ç”¨çš„å†…å­˜
æ ˆéµå¾ªåè¿›å…ˆå‡ºï¼Œæ ˆä¸­çš„æ‰€æœ‰æ•°æ®éƒ½å¿…é¡»å ç”¨å·²çŸ¥ä¸”å›ºå®šçš„å¤§å°ï¼Œåœ¨ç¼–è¯‘æ—¶ä½ç½®å¤§å°æˆ–å¤§å°å¯å˜çš„æ•°æ®åˆ™è¦å­˜æ”¾åœ¨å †ä¸Šï¼Œåœ¨å‘å †å­˜æ”¾æ•°æ®æ—¶ï¼Œæˆ‘ä»¬è¯·æ±‚ä¸€å®šå¤§å°çš„ç©ºé—´ï¼Œå†…å­˜åˆ†é…å™¨åœ¨å †ä¸Šæ‰¾åˆ°ä¸€å¤„è¶³å¤Ÿå¤§çš„ç©ºé—´ï¼Œå°†å®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œå¹¶è¿”å›å®ƒçš„æŒ‡é’ˆï¼ŒæŒ‡é’ˆçš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå¯ä»¥å­˜æ”¾åœ¨æ ˆä¸Š
å…¥æ ˆæ¯”åœ¨å †ä¸Šåˆ†é…å†…å­˜è¦å¿«
è®¿é—®æ ˆä¸Šçš„æ•°æ®æ¯”è®¿é—®å †ä¸Šçš„æ•°æ®è¦å¿«
å½“è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œä¼ é€’ç»™å‡½æ•°çš„å€¼å’Œå‡½æ•°çš„å±€éƒ¨å˜é‡è¢«å‹å…¥æ ˆä¸­ï¼Œå½“å‡½æ•°ç»“æŸï¼Œè¿™äº›å€¼è¢«å¼¹å‡ºæ ˆ

æ‰€æœ‰æƒç³»ç»Ÿè§£å†³çš„å°±æ˜¯è·Ÿè¸ªå“ªéƒ¨åˆ†ä»£ç æ­£åœ¨ä½¿ç”¨å †ä¸Šçš„å“ªéƒ¨åˆ†æ•°æ®ï¼Œæœ€å¤§é™åº¦å‡å°å †ä¸Šçš„é‡å¤æ•°æ®çš„æ•°é‡ï¼Œä»¥åŠæ¸…ç†å †ä¸Šä¸å†ä½¿ç”¨çš„æ•°æ®ç¡®ä¿ä¸ä¼šè€—å°½ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰€æœ‰æƒçš„ä¸»è¦ç›®çš„å°±æ˜¯ç®¡ç†å †æ•°æ®

**Ownership Rules**
- rustä¸­çš„æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
- å€¼åœ¨ä»»æ„æ—¶åˆ»æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
- å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ

**Variable Space**
ä½œç”¨åŸŸæ˜¯ä¸€ä¸ªé¡¹(item)åœ¨ç¨‹åºä¸­æœ‰æ•ˆçš„èŒƒå›´ï¼Œå¦‚å¯¹äº`let s = "hello"`ï¼Œå˜é‡sè¢«ç»‘å®šåˆ°äº†ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²å€¼æ˜¯ç¡¬ç¼–ç è¿›æˆ‘ä»¬çš„ç¨‹åºä»£ç ä¸­çš„ï¼Œå˜é‡sä»å®ƒè¢«å£°æ˜åˆ°å½“å‰ä½œç”¨åŸŸç»“æŸæ—¶éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œå¦‚ï¼š
```rust
    {                      // så°šæœªè¢«å£°æ˜ï¼Œæ— æ•ˆ
        let s = "hello";   // sä»æ­¤å¤„èµ·æœ‰æ•ˆ

        // ä½¿ç”¨s
    }                      // ä½œç”¨åŸŸç»“æŸï¼Œsæ— æ•ˆ
```
ä¸¤ä¸ªé‡è¦çš„æ—¶é—´ç‚¹ï¼š
- å½“sè¿›å…¥ä½œç”¨åŸŸï¼Œå®ƒæ˜¯æœ‰æ•ˆçš„
- è¿™ä¸€ç›´æŒç»­åˆ°å®ƒç¦»å¼€ä½œç”¨åŸŸä¸ºæ­¢

**The String Type**
rustçš„å­—ç¬¦ä¸²ç±»å‹é™¤äº†å­—ç¬¦ä¸²å­—é¢å€¼ï¼Œè¿˜æœ‰`String`ç±»å‹ï¼Œè¿™ä¸ªç±»å‹ç®¡ç†è¢«åˆ†é…åˆ°å †ä¸Šçš„æ•°æ®ï¼Œèƒ½å¤Ÿå­˜å‚¨åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„æ–‡æœ¬

æˆ‘ä»¬å¯ä»¥ç”¨`from()`å‡½æ•°ä»å­—ç¬¦ä¸²å­—é¢å€¼åˆ›å»º`String`ï¼Œå¦‚ï¼š`let s = String::from("hello");`
è¿ç®—ç¬¦`::`è¡¨ç¤ºä½¿ç”¨`String`ç±»å‹çš„å‘½åç©ºé—´ä¸‹çš„`from()`å‡½æ•°

`String`ç±»å‹çš„å­—ç¬¦ä¸²æ˜¯å…è®¸è¢«ä¿®æ”¹çš„ï¼š
```rust
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str()åœ¨å­—ç¬¦ä¸²åè¿½åŠ å­—é¢å€¼

    println!("{}", s); // å°†æ‰“å°`hello, world!`

```

**Memory and Allocation**
å­—ç¬¦ä¸²å­—é¢å€¼åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“å…¶å†…å®¹ï¼Œæ–‡æœ¬è¢«ç›´æ¥ç¡¬ç¼–ç è¿›æœ€åçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­

å¯¹äº`String`ç±»å‹ï¼Œä¸ºäº†æ”¯æŒä¸€ä¸ªå¯å˜çš„æ–‡æœ¬ç‰‡æ®µï¼Œæˆ‘ä»¬éœ€è¦åœ¨å †ä¸Šåˆ†é…ä¸€ä¸ªç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„å†…å­˜æ¥å­˜æ”¾å†…å®¹ï¼Œå®ƒåŒ…æ‹¬ä¸¤æ­¥ï¼š
- åœ¨è¿è¡Œæ—¶ï¼Œå‘å†…å­˜åˆ†é…å™¨è¯·æ±‚å†…å­˜
- åœ¨æˆ‘ä»¬å¤„ç†å®Œ`String`åï¼Œå‘å†…å­˜åˆ†é…å™¨è¿”å›å†…å­˜

æˆ‘ä»¬è°ƒç”¨äº†`String::from()`å°±ä¼šå¯¼è‡´è¿è¡Œæ—¶çš„å†…å­˜è¯·æ±‚ï¼Œè¯·æ±‚å†…å­˜çš„æ–¹æ³•åœ¨å„ä¸ªç¼–ç¨‹è¯­è¨€ä¸­æ˜¯é€šç”¨çš„
ä½†é‡Šæ”¾å†…å­˜çš„æœºåˆ¶æœ‰ä¸åŒçš„å®ç°ï¼Œæœ‰çš„ç¼–ç¨‹è¯­è¨€ä½¿ç”¨åƒåœ¾å›æ”¶æœºåˆ¶è‡ªåŠ¨è®°å½•å¹¶æ¸…ç†ä¸å†ä½¿ç”¨çš„å†…å­˜ï¼Œæœ‰çš„ç¼–ç¨‹è¯­è¨€éœ€è¦æ‰‹åŠ¨æ¸…ç†ï¼Œéœ€è¦ç²¾ç¡®åœ°å¯¹ä¸€ä¸ª`allocate`é…å¯¹ä¸€ä¸ª`free`
åœ¨Rustä¸­ï¼Œå†…å­˜åœ¨æ‹¥æœ‰å®ƒçš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸåè¢«è‡ªåŠ¨é‡Šæ”¾ï¼Œå¦‚ï¼š
```rust
    {
        let s = String::from("hello"); // ä»æ­¤å¤„èµ·ï¼Œs æ˜¯æœ‰æ•ˆçš„

        // ä½¿ç”¨ s
    }                                  // æ­¤ä½œç”¨åŸŸå·²ç»“æŸï¼Œ
                                       // s ä¸å†æœ‰æ•ˆ
```
å½“å˜é‡`s`ç¦»å¼€äº†ä½œç”¨åŸŸï¼ŒRustè°ƒç”¨äº†`drop()`å‡½æ•°ï¼Œ`String`ç±»å‹çš„ç¼–å†™è€…å¯ä»¥åœ¨`drop()`å‡½æ•°ä¸­å†™ä¸Šé‡Šæ”¾å†…å­˜çš„ä»£ç ï¼ŒRuståœ¨ç»“å°¾çš„`}`å¤„è‡ªåŠ¨è°ƒç”¨äº†`drop()`

**Variables and Data Interacting with Move**
Rustä¸­ï¼Œå¤šä¸ªå˜é‡å¯ä»¥é‡‡ç”¨ä¸åŒçš„æ–¹å¼ä¸åŒä¸€æ•°æ®è¿›è¡Œäº¤äº’
å¦‚ï¼š
```rust
	let x = 5;
	let y = x;
```
æˆ‘ä»¬å°†å€¼`5`ç»‘å®šåˆ°`x`ï¼Œç„¶åç”Ÿæˆä¸€ä¸ª`x`çš„å€¼çš„æ‹·è´å¹¶ç»‘å®šç»™`y`ï¼Œç°åœ¨æœ‰ä¸¤ä¸ªå˜é‡`x, y`ï¼Œä¸”å€¼éƒ½æ˜¯`5`ï¼Œè€Œæ•´å‹æ˜¯æœ‰å›ºå®šå¤§å°çš„ç®€å•å€¼ï¼Œè¿™ä¸¤ä¸ª`5`å€¼è¢«æ”¾å…¥äº†æ ˆä¸­

å¦‚ï¼š
```rust
	let s1 = String::from("hello");
	let s2 = s1;
```
è¿™é‡Œçš„è¿è¡Œæ–¹å¼åˆ™ä¸ä¸Šé¢ä¸åŒ

`s1`æ˜¯ä¸€ä¸ª`String`ç±»å‹å˜é‡ï¼Œå®ƒçš„å€¼æ˜¯`"hello"`
ä¸€ä¸ª`String`ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šptr, len, capacityï¼Œptræ˜¯ä¸€ä¸ªæŒ‡å‘å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹çš„å†…å­˜çš„æŒ‡é’ˆï¼Œlenæ˜¯é•¿åº¦ï¼Œcapacityæ˜¯å®¹é‡ï¼Œè¿™äº›æ•°æ®éƒ½å­˜å‚¨åœ¨æ ˆä¸Šï¼Œå­—ç¬¦ä¸²çš„å†…å®¹å­˜å‚¨åœ¨å †ä¸Š
é•¿åº¦è¡¨ç¤º`String`å½“å‰å†…å®¹çš„å­—èŠ‚æ•°ï¼Œå®¹é‡æ˜¯`String`ä»å†…å­˜åˆ†é…å™¨è·å¾—çš„å¤šå°‘å­—èŠ‚çš„å†…å­˜
å½“æˆ‘ä»¬æŠŠ`s1`èµ‹å€¼ç»™`s2`ï¼Œæ ˆä¸Šçš„`String`çš„æ•°æ®è¢«å¤åˆ¶äº†ï¼Œå³æˆ‘ä»¬æ‹·è´äº†ptr, len, capacityçš„å€¼ï¼Œä½†å †ä¸Šçš„å€¼æ²¡æœ‰è¢«æ‹·è´

æˆ‘ä»¬çŸ¥é“å½“ä¸€ä¸ªå˜é‡ç¦»å¼€ä½œç”¨åŸŸåï¼ŒRustä¼šè‡ªåŠ¨`drop()`å‡½æ•°æ¸…ç†å˜é‡çš„å †å†…å­˜ï¼Œæ˜¾ç„¶`s1, s2`çš„æŒ‡é’ˆæŒ‡å‘åŒä¸€å¤„å†…å­˜ï¼Œæˆ‘ä»¬è¦é¿å…äºŒæ¬¡é‡Šæ”¾çš„é—®é¢˜

Rustä¼šåœ¨`let s2 = s1;`ä¹‹åè®¤ä¸º`s1`ä¸å†æœ‰æ•ˆï¼Œå› æ­¤Rustä¸éœ€è¦åœ¨`s1`ç¦»å¼€å…¶ä½œç”¨åŸŸåæ¸…ç†ä»»ä½•ä¸œè¥¿
æˆ‘ä»¬å¯ä»¥å°è¯•åœ¨`let s2 = s1;`åä½¿ç”¨`s1`ï¼š
```rust
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
```
Rustç¦æ­¢æˆ‘ä»¬ä½¿ç”¨æ— æ•ˆçš„å¼•ç”¨ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼šborrow of moved value

Rustç§°`let s2 = s1;`çš„æ“ä½œä¸ºç§»åŠ¨(move)ï¼Œ**ç§»åŠ¨å¯ä»¥è®¤ä¸ºæ˜¯æµ…æ‹·è´+æ— æ•ˆç¬¬ä¸€ä¸ªå˜é‡**ï¼Œæˆ‘ä»¬è®¤ä¸º`s1`è¢«ç§»åŠ¨åˆ°äº†`s2`ä¸­

ç°åœ¨åªæœ‰`s2`æ˜¯æœ‰æ•ˆçš„ï¼Œè€Œåœ¨`s2`ç¦»å¼€å…¶ä½œç”¨åŸŸæ—¶ï¼Œå°±ä¼šé‡Šæ”¾è‡ªå·±çš„å†…å­˜

Rustä¸ä¼šè‡ªåŠ¨åˆ›é€ æ·±æ‹·è´

**Variables and Data Interacting with Clone**
æ·±æ‹·è´å †ä¸Šçš„æ•°æ®éœ€è¦è°ƒç”¨`clone()`æ–¹æ³•ï¼Œå¦‚ï¼š
```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

**Stack Only Data: Copy**
å›å¿†ä¹‹å‰çš„ä¸€ä¸ªä¾‹å­ï¼š
```rust
	let x = 5;
	let y = x;

	println("x = {}, y = {}", x, y);
```
è¿™æ®µä»£ç ä¸­ï¼Œæ²¡æœ‰è°ƒç”¨cloneï¼Œxåœ¨èµ‹å€¼åä¾ç„¶æœ‰æ•ˆï¼Œæ²¡æœ‰è¢«ç§»åŠ¨åˆ°yä¸­ï¼Œè¿™æ˜¯å› ä¸ºåƒæ•´å‹è¿™ç§åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„ç±»å‹æ˜¯å®Œå…¨å­˜å‚¨åœ¨æ ˆä¸Šçš„ï¼Œå¯¹äºå…¶å®é™…çš„å€¼è¿›è¡Œæ‹·è´ä¹Ÿæ˜¯éå¸¸å¿«é€Ÿçš„ï¼Œä¸æ¶‰åŠåˆ°æ·±æµ…æ‹·è´çš„åŒºåˆ«ï¼Œéƒ½æ˜¯æ·±æ‹·è´

Rustæœ‰å«åšCopy traitçš„ç‰¹æ®Šæ³¨è§£ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·çš„å­˜å‚¨åœ¨æ ˆä¸Šçš„ç±»å‹ä¸Šï¼Œå¦‚æœä¸€ä¸ªç±»å‹å®ç°äº†Copy traitï¼Œé‚£ä¹ˆä¸€ä¸ªæ—§çš„å˜é‡åœ¨å°†å…¶èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨

Rustä¸å…è®¸æˆ‘ä»¬å¯¹è‡ªèº«æˆ–å…¶ä»»ä½•éƒ¨åˆ†å®ç°äº†Drop traitçš„ç±»å‹æ³¨è§£Copy trait
å¦‚æœæˆ‘ä»¬å¯¹ä¸€ä¸ªå…¶å€¼ç¦»å¼€ä½œç”¨åŸŸéœ€è¦è¿›è¡Œç‰¹æ®Šå¤„ç†çš„ç±»å‹è¿›è¡ŒCopy traitæ³¨è§£ï¼Œå°†ä¼šå¯¼è‡´ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯

ä»»ä½•ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®ç°Copy traitï¼Œä»»ä½•ä¸éœ€è¦å†…å­˜åˆ†é…æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹éƒ½å¯ä»¥å®ç°Copy traitï¼Œå¦‚ï¼š
- æ‰€æœ‰çš„æ•´å‹ï¼Œå¦‚`u32`
- å¸ƒå°”ç±»å‹`bool`
- æ‰€æœ‰çš„æµ®ç‚¹å‹ï¼Œå¦‚`f32`
- å­—ç¬¦ç±»å‹`char`
- å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å®ƒåŒ…å«çš„ç±»å‹éƒ½å®ç°äº†Copy traitï¼Œå¦‚`(i32, i32)`

**Ownership and Functions**
å°†å€¼ä¼ é€’ç»™å‡½æ•°ä¸ç»™å˜é‡èµ‹å€¼çš„åŸç†ç±»ä¼¼ï¼Œåƒå‡½æ•°ä¼ é€’å€¼ä¹Ÿå¯èƒ½ä¼šç§»åŠ¨æˆ–æ‹·è´ï¼Œå¦‚èµ‹å€¼ä¸€æ ·ï¼Œå¦‚ï¼š
```rust
fn main() {
	let s = String::from("hello"); // sè¿›å…¥ä½œç”¨åŸŸ

	take_ownership(s);             // sçš„å€¼è¢«ç§»åŠ¨(move)åˆ°å‡½æ•°ä¸­
	                               // å› æ­¤såˆ°è¿™é‡Œå·²ç»ä¸å†æœ‰æ•ˆ

	let x = 5;                     // xè¿›å…¥ä½œç”¨åŸŸ

	makes_copy(x);                 // xåº”è¯¥è¢«ç§»åŠ¨åˆ°å‡½æ•°ä¸­
	                               // ä½†i32æ˜¯Copyçš„
	                               // å› æ­¤ä¹‹åä»ç„¶å¯ä»¥ä½¿ç”¨x
	
} // åœ¨æ­¤å¤„ï¼Œxå…ˆç¦»å¼€ä½œç”¨åŸŸï¼Œç„¶åæ˜¯sï¼Œä½†æ˜¯så·²ç»æ— æ•ˆï¼Œæ‰€ä»¥æ²¡æœ‰ç‰¹åˆ«çš„äº‹å‘ç”Ÿ

fn takes_ownership(some_string: String) { // some_stringè¿›å…¥ä½œç”¨åŸŸ
	println!("{}", some_string);
} // åœ¨æ­¤å¤„ï¼Œsome_stringç¦»å¼€ä½œç”¨åŸŸï¼Œdropæ–¹æ³•è¢«è°ƒç”¨ï¼Œå †å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integerè¿›å…¥ä½œç”¨åŸŸ
	println!("{}", some_integer); 
} // åœ¨æ­¤å¤„ï¼Œsome_integerç¦»å¼€ä½œç”¨åŸŸï¼Œæ²¡æœ‰ç‰¹åˆ«çš„äº‹å‘ç”Ÿ
```
å¦‚æœæˆ‘ä»¬åœ¨å°è¯•è°ƒç”¨`take_ownership(s)`åå†ä½¿ç”¨sæ—¶ï¼Œä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯

**Return Values and Scope**
è¿”å›å€¼ä¹Ÿå¯ä»¥è½¬ç§»æ‰€æœ‰æƒï¼Œå¦‚ï¼š
```rust
fn main() {
	let s1 = gives_ownership();     // gives_ownership()å°†è¿”å›å€¼
	                                // ç§»åŠ¨(move)ç»™s1

	let s2 = String::from("hello"); // s2è¿›å…¥ä½œç”¨åŸŸ

	let s3 = takes_and_gives_back(s2); // s2è¢«ç§»åŠ¨(move)åˆ°å‡½æ•°
	                                   // takes_and_gives_back()ä¸­
	                                   // å‡½æ•°ä¹Ÿå°†è¿”å›å€¼ç§»åŠ¨(move)ç»™
	                                   // s3
} // åœ¨æ­¤å¤„ï¼Œs3ç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«dropï¼Œs2å·²ç»è¢«ç§»åŠ¨ï¼Œæ— äº‹å‘ç”Ÿï¼Œs1ç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«drop

fn gives_ownership() -> String {      // gives_ownership()ä¼šå°†
                                      // è¿”å›å€¼ç§»åŠ¨ç»™è°ƒç”¨å®ƒçš„å‡½æ•°
    let some_string = String::from("yours"); // some_string
                                             // è¿›å…¥ä½œç”¨åŸŸ
    some_string                       // some_stringè¢«è¿”å›
                                      // å¹¶è¢«ç§»åŠ¨ç»™è°ƒç”¨çš„å‡½æ•°
}

fn takes_and_gives_back(a_string: String) -> String { // a_string
                                                      // è¿›å…¥ä½œç”¨åŸŸ
    a_string                          // a_stringè¢«è¿”å›
                                      // å¹¶è¢«ç§»åŠ¨ç»™è°ƒç”¨çš„å‡½æ•°
}
```

å˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼š å°†å€¼èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡æ—¶è¿›è¡Œç§»åŠ¨ï¼Œå½“æŒæœ‰å †ä¸­æ•°æ®å€¼çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼è¢«dropæ¸…ç†ï¼Œé™¤éå¯¹äºè¿™ä¸ªæ•°æ®å€¼çš„æ‰€æœ‰æƒå·²ç»è¢«ç§»åŠ¨è‡³å¦ä¸€ä¸ªå˜é‡

å¦‚æœæˆ‘ä»¬éœ€è¦è®©å‡½æ•°ä½¿ç”¨ä¸€ä¸ªå€¼ä½†ä¸å¸¦èµ°å®ƒçš„æ‰€æœ‰æƒï¼Œå¯ä»¥ä½¿ç”¨å¼•ç”¨

## 4.2 References and Borrowing
å‡½æ•°å¯ä»¥ä½¿ç”¨å…ƒç»„è¿”å›å¤šä¸ªå€¼ï¼š
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
è¿™æ®µä»£ç ä¸ºäº†åœ¨è°ƒç”¨å‡½æ•°ä¹‹åå¯ä»¥å†ä½¿ç”¨`String`ï¼Œä¸å¾—ä¸å°†`String`å†è¿”å›

æˆ‘ä»¬å¯ä»¥æä¾›ä¸€ä¸ªå¯¹`String`å€¼çš„å¼•ç”¨ï¼Œè¿™ä¸ªå€¼å±äºå…¶ä»–å˜é‡ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹å®ƒçš„å¼•ç”¨å¯¹å…¶è¿›è¡Œè®¿é—®ï¼Œä¸æŒ‡é’ˆä¸åŒçš„æ˜¯ï¼Œå¼•ç”¨ç¡®ä¿æŒ‡å‘æŸä¸ªç‰¹å®šç±»å‹çš„æœ‰æ•ˆå€¼

å¼•ç”¨ä¼ å‚ï¼š
```rust
fn main() {
	let s1 = String::from("hello");

	let len = calculate_length(&s1);

	println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // sæ˜¯Stringçš„å¼•ç”¨
	s.len()
} // åœ¨æ­¤å¤„sç¦»å¼€äº†ä½œç”¨åŸŸï¼Œä½†å®ƒä¸æ‹¥æœ‰å¯¹å¼•ç”¨å€¼çš„æ‰€æœ‰æƒï¼Œå› æ­¤æ²¡æœ‰å‘ç”Ÿdrop
```
æˆ‘ä»¬å®šä¹‰äº†ä»¥ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨ä½œä¸ºå‚æ•°çš„å‡½æ•°ï¼Œå®ƒä¸ä¼šè·å–å€¼çš„æ‰€æœ‰æƒï¼Œå¼•ç”¨å…è®¸æˆ‘ä»¬ä½¿ç”¨ä¸€äº›å€¼ä½†ä¸è·å–å®ƒä»¬çš„ä½¿ç”¨æƒ

`&s1`åˆ›å»ºäº†ä¸€ä¸ªæŒ‡å‘s1çš„å€¼çš„å¼•ç”¨ï¼Œä½†å¼•ç”¨ä¸æ‹¥æœ‰è¿™ä¸ªå€¼
å‡½æ•°ç­¾åä¸­çš„`&`ä¹Ÿè¡¨ç¤ºäº†å‚æ•°çš„ç±»å‹åº”è¯¥æ˜¯ä¸€ä¸ªå¼•ç”¨

å‡½æ•°`calculate_length()`ä¸­ï¼Œå˜é‡sæœ‰æ•ˆçš„ä½œç”¨åŸŸå’Œå‡½æ•°çš„å‚æ•°çš„ä½œç”¨åŸŸæ˜¯ä¸€æ ·çš„ï¼Œä½†sç¦»å¼€ä½œç”¨åŸŸæ—¶ä¸ä¼šdropå€¼ï¼Œå› ä¸ºsæ²¡æœ‰æ‰€æœ‰æƒï¼Œå› æ­¤ä¹Ÿå°±æ— éœ€å½’è¿˜æ‰€æœ‰æƒï¼Œäº‹å®ä¸Šå˜é‡sä»…åŒ…å«äº†ä¸€ä¸ªæˆå‘˜ptrï¼Œptrå­˜å‚¨äº†æŒ‡å‘å˜é‡s1çš„æŒ‡é’ˆ

æˆ‘ä»¬ç§°åˆ›é€ ä¸€ä¸ªå¼•ç”¨çš„è¿‡ç¨‹ä¸ºå€Ÿç”¨

æˆ‘ä»¬ä¸èƒ½é€šè¿‡å¼•ç”¨æ¥ä¿®æ”¹å€¼ï¼š
```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
å¼•ç”¨é»˜è®¤æ˜¯ä¸å¯å˜çš„

**Mutable Reference**
å¯å˜å¼•ç”¨å…è®¸æˆ‘ä»¬ä¿®æ”¹å€Ÿç”¨çš„å€¼ï¼š
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
æˆ‘ä»¬ç”¨`&mut s`åˆ›å»ºäº†ä¸€ä¸ªå¯¹sçš„å€¼çš„å¯å˜å¼•ç”¨ï¼ŒåŒæ—¶æˆ‘ä»¬ä¹Ÿä¿®æ”¹äº†å‡½æ•°ç­¾åï¼Œä½¿å…¶æ¥å—ä¸€ä¸ªå¯å˜å¼•ç”¨ä½œä¸ºå‚æ•°

å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªé™åˆ¶ï¼šå½“æˆ‘ä»¬å¯¹ä¸€ä¸ªå€¼åˆ›å»ºäº†ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œæˆ‘ä»¬å°±ä¸èƒ½å¯¹å®ƒå†åˆ›å»ºå…¶ä»–çš„å¼•ç”¨ï¼Œå¦‚ï¼š
```rust
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
```
ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œæˆ‘ä»¬ä¸èƒ½åœ¨åŒä¸€æ—¶é—´å°†så¤šæ¬¡ä½œä¸ºå¯å˜å˜é‡å€Ÿå‡º

è¿™ä¸€é™åˆ¶é™åˆ¶æˆ‘ä»¬ç”¨ä¸€ç§éå¸¸è°¨æ…çš„æ–¹å¼ä½¿ç”¨å¼•ç”¨çš„å¯å˜æ€§ï¼ŒRustçš„è¿™ä¸€ç‰¹æ€§æ˜¯ä¸ºäº†åœ¨ç¼–è¯‘æ—¶å°±é¿å…æ•°æ®ç«äº‰(data race)ï¼Œæ•°æ®ç«äº‰å‘ç”Ÿçš„æƒ…å†µæ˜¯ï¼š
- ä¸¤ä¸ªåŠå…¶ä»¥ä¸Šæ•°é‡çš„æŒ‡é’ˆåŒæ—¶è®¿é—®åŒä¸€æ•°æ®
- è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆè¢«ç”¨æ¥å†™å…¥æ•°æ®
- æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶
æ•°æ®ç«äº‰ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºï¼Œå¹¶ä¸”éš¾ä»¥åœ¨è¿è¡Œæ—¶è¿½è¸ªï¼ŒRusté€šè¿‡æ‹’ç»ç¼–è¯‘å¯èƒ½ä¼šå­˜åœ¨æ•°æ®ç«äº‰çš„ä»£ç é¿å…æ•°æ®ç«äº‰çš„å‡ºç°

æˆ‘ä»¬å¯ä»¥ç”¨å¤§æ‹¬å·åˆ›å»ºä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œä»¥å…è®¸å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œåªæ˜¯ä¸èƒ½åŒæ—¶æ‹¥æœ‰ï¼š
```rust
fn main() {
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 åœ¨è¿™é‡Œç¦»å¼€äº†ä½œç”¨åŸŸï¼Œæ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å¼•ç”¨

    let r2 = &mut s;
}
```

ç›¸ä¼¼åœ°ï¼Œç»“åˆä½¿ç”¨å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ä¹Ÿä¼šå¯¼è‡´é—®é¢˜ï¼š
```rust
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
```
å½“æˆ‘ä»¬å¯¹ä¸€ä¸ªå€¼åˆ›å»ºäº†ä¸å¯å˜å¼•ç”¨æ—¶ï¼Œä¸èƒ½å†åˆ›å»ºå¯¹å®ƒçš„å¯å˜å¼•ç”¨ï¼Œä½†å¯ä»¥åˆ›å»ºæ›´å¤šçš„ä¸å¯å˜å¼•ç”¨

ä¸€ä¸ªå¼•ç”¨çš„ä½œç”¨åŸŸä»å£°æ˜çš„åœ°æ–¹å¼€å§‹ä¸€ç›´æŒç»­åˆ°æœ€åä¸€æ¬¡ä½¿ç”¨ä¸ºæ­¢ï¼Œå¦‚ï¼š
```rust
	let mut s = String::from("hello");

	let r1 = &s; // æ²¡é—®é¢˜
	let r2 = &s; // æ²¡é—®é¢˜
	println!("{} and {}", r1, r2);
	// åœ¨è¿™ä¹‹år1, r2æ²¡æœ‰å†è¢«ä½¿ç”¨

	let r3 = &mut s; // æ²¡é—®é¢˜
	println!("{}", r3);
```
è¿™æ®µä»£ç å¯ä»¥æ­£å¸¸ç¼–è¯‘ï¼Œå› ä¸ºæœ€åä¸€æ¬¡å¯¹ä¸å¯å˜å¼•ç”¨çš„ä½¿ç”¨å‘ç”Ÿåœ¨å¯¹å¯å˜å¼•ç”¨çš„å£°æ˜ä¹‹å‰ï¼Œä¸å¯å˜å¼•ç”¨çš„ä½œç”¨åŸŸåœ¨`println()`ä¹‹åç»“æŸï¼Œè€Œå¯å˜å¼•ç”¨è¿˜æœªè¢«åˆ›å»ºï¼Œä½œç”¨åŸŸæ²¡æœ‰é‡å 

**Dangling References**
æ‚¬å‚æŒ‡é’ˆæŒ‡æŒ‡é’ˆæŒ‡å‘äº†è¢«é‡Šæ”¾çš„å†…å­˜ï¼Œè¿™äº›å†…å­˜ç”šè‡³å¯èƒ½è¢«åˆ†é…ç»™äº†å…¶ä»–çš„æŒæœ‰è€…ï¼Œåœ¨Rustä¸­ï¼Œç¼–è¯‘å™¨ä¼šç¡®ä¿å¼•ç”¨æ°¸è¿œä¸ä¼šå˜ä¸ºæ‚¬å‚çŠ¶æ€ï¼Œå³å¦‚æœæˆ‘ä»¬æ‹¥æœ‰äº†å¯¹ä¸€äº›æ•°æ®çš„å¼•ç”¨ï¼Œç¼–è¯‘å™¨ä¼šç¡®ä¿åœ¨å¼•ç”¨ç¦»å¼€å®ƒçš„ä½œç”¨åŸŸä¹‹å‰ï¼Œæ•°æ®ä¸ä¼šç¦»å¼€å®ƒçš„ä½œç”¨åŸŸ

åœ¨Rustä¸­åˆ›å»ºæ‚¬å‚å¼•ç”¨ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼š
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

ä¸ºä»£ç æ·»åŠ æ³¨é‡Šï¼š
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle() è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¼•ç”¨

    let s = String::from("hello"); // s æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸²

    &s // è¿”å›å­—ç¬¦ä¸² s çš„å¼•ç”¨
} // è¿™é‡Œ s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«dropï¼Œå…¶å†…å­˜è¢«é‡Šæ”¾ã€‚
  // å±é™©ï¼
```
å˜é‡`s`åœ¨`dangle()`å†…è¢«åˆ›å»ºï¼Œå½“è¯¥å‡½æ•°ç»“æŸï¼Œ`s`è¢«é‡Šæ”¾ï¼Œä½†æˆ‘ä»¬å°è¯•è¿”å›å®ƒçš„å¼•ç”¨ï¼Œé‚£ä¹ˆå¼•ç”¨å°†ä¼šæŒ‡å‘ä¸€ä¸ªæ— æ•ˆçš„`String`

å¦‚æœç›´æ¥è¿”å›`s`ï¼Œåˆ™æ²¡é—®é¢˜ï¼š
```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
å‡½æ•°çš„è¿”å›ä¼šè®©`s`å¯¹å€¼çš„æ‰€æœ‰æƒè¢«ç§»åŠ¨å‡ºå»ï¼Œ`s`çš„ä½œç”¨åŸŸç»“æŸåï¼Œæ²¡æœ‰å€¼ä¼šè¢«é‡Šæ”¾

**The Rules of References**
- åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆåªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆå¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
- å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„

## 4.3 The Slice Type
sliceå…è®¸æˆ‘ä»¬å¼•ç”¨é›†åˆä¸­ä¸€æ®µè¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸ç”¨å¼•ç”¨æ•´ä¸ªé›†åˆ
sliceæ˜¯ä¸€ç±»å¼•ç”¨ï¼Œå› æ­¤æ²¡æœ‰æ‰€æœ‰æƒ

è§£å†³ä¸€ä¸ªé—®é¢˜ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªç”¨ç©ºæ ¼åˆ†éš”å•è¯çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›åœ¨è¯¥å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚å¦‚æœå‡½æ•°åœ¨è¯¥å­—ç¬¦ä¸²ä¸­å¹¶æœªæ‰¾åˆ°ç©ºæ ¼ï¼Œåˆ™æ•´ä¸ªå­—ç¬¦ä¸²å°±æ˜¯ä¸€ä¸ªå•è¯ï¼Œæ­¤æ—¶åº”è¯¥è¿”å›æ•´ä¸ªå­—ç¬¦ä¸²

å¦‚æœä¸ä½¿ç”¨sliceï¼š
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```
è§£é‡Šï¼š
æˆ‘ä»¬éœ€è¦é€ä¸ªå…ƒç´ åœ°æ£€æŸ¥`String`ä¸­çš„å€¼æ˜¯å¦ä¸ºç©ºæ ¼ï¼Œå› æ­¤ç”¨`as_bytes()`æ–¹æ³•å°†å…¶è½¬åŒ–ä¸ºå­—èŠ‚æ•°ç»„
`for (i, &item) in bytes.iter().enumerate() {`åœ¨å­—èŠ‚æ•°ç»„ä¸Šåˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå…¶ä¸­`iter()`æ–¹æ³•è¿”å›é›†åˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œ`enumerate()`æ–¹æ³•åŒ…è£…äº†`iter()`çš„ç»“æœï¼Œè¿”å›å…ƒç»„
æˆ‘ä»¬ä½¿ç”¨æ¨¡å¼æ¥ç»“æ„`enumerate()`è¿”å›çš„å…ƒç»„
åœ¨å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å­—èŠ‚çš„å­—é¢å€¼è¯­æ³•æ¥å¯»æ‰¾ä»£è¡¨ç©ºæ ¼çš„å­—èŠ‚ï¼Œå¦‚æœæ‰¾åˆ°äº†ç©ºæ ¼ï¼Œè¿”å›å…¶ç´¢å¼•ï¼Œå¦åˆ™è¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦

æˆ‘ä»¬è¿”å›äº†ä¸€ä¸ªç‹¬ç«‹çš„`usize`ï¼Œä½†è¿™ä¸ªæ•°å€¼åªæœ‰åœ¨`&String`çš„ä¸Šä¸‹æ–‡èœæ‰èƒ½ä¿è¯å®ƒæ˜¯æœ‰æ„ä¹‰çš„ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸`String`ç›¸åˆ†ç¦»çš„å€¼ï¼Œæ— æ³•ä¿è¯å®ƒå°†æ¥ä»ç„¶æœ‰æ•ˆï¼Œå¦‚ï¼š
```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word çš„å€¼ä¸º 5

    s.clear(); // è¿™æ¸…ç©ºäº†å­—ç¬¦ä¸²ï¼Œä½¿å…¶ç­‰äº ""

    // word åœ¨æ­¤å¤„çš„å€¼ä»ç„¶æ˜¯ 5ï¼Œ
    // ä½†æ˜¯æ²¡æœ‰æ›´å¤šçš„å­—ç¬¦ä¸²è®©æˆ‘ä»¬å¯ä»¥æœ‰æ•ˆåœ°åº”ç”¨æ•°å€¼ 5, word çš„å€¼ç°åœ¨å®Œå…¨æ— æ•ˆï¼
}
```

å¦‚æœç¼–å†™ä¸€ä¸ª`second_word()`å‡½æ•°ï¼Œå‡½æ•°ç­¾ååˆ™éœ€è¦å†™æˆè¿™æ ·ï¼š
`fn second_word(s: &String) -> (usize, usize) {`
æˆ‘ä»¬éœ€è¦è·Ÿè¸ªä¸€ä¸ªå¼€å§‹ç´¢å¼•å’Œç»“å°¾ç´¢å¼•ï¼ŒåŒæ—¶æœ‰äº†æ›´å¤šçš„ä»æ•°æ®çš„æŸä¸ªçŠ¶æ€è®¡ç®—è€Œæ¥çš„å€¼ï¼Œå´å®Œå…¨æ²¡æœ‰è·Ÿè¿™ä¸ªçŠ¶æ€ç›¸ç»‘å®šï¼Œè¿™äº›å’Œæ•°æ®çš„çŠ¶æ€ä¸ç›¸å…³çš„å˜é‡éœ€è¦å’Œæ•°æ®çš„çŠ¶æ€ä¿æŒåŒæ­¥

**String Slices**
å­—ç¬¦ä¸²sliceæ˜¯å¯¹`String`ä¸­ä¸€éƒ¨ä»½å€¼çš„å¼•ç”¨ï¼Œå¦‚ï¼š
```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
}
```
sliceçš„æ•°æ®ç»“æ„æœ‰ä¸¤éƒ¨åˆ†ï¼Œptrå’Œlenï¼Œåˆ†åˆ«å­˜å‚¨äº†sliceçš„å¼€å§‹ä½ç½®å’Œsliceçš„é•¿åº¦ï¼Œå¦‚`let world = &s[6..11]`ï¼Œ`world`å°†åŒ…å«ä¸€ä¸ªæŒ‡å‘`s`çš„ç¬¬å…­ä¸ªç´¢å¼•ä¸Šçš„å­—èŠ‚çš„æŒ‡é’ˆï¼Œä»¥åŠé•¿åº¦å€¼`5`

ä»é›¶å¼€å§‹å¯ä»¥å¿½ç•¥`starting_index`ï¼Œå¦‚ï¼š
```rust
#![allow(unused)]
fn main() {
	let s = String::from("hello");
	
	let slice = &s[0..2];
	let slice = &s[..2];
}
```

ä»¥`String`çš„å°¾éƒ¨ç»“æŸå¯ä»¥å¿½ç•¥`ending_index`ï¼Œå¦‚ï¼š
```rust
#![allow(unused)]
fn main() {
	let s = String::from("hello");
	
	let len = s.len();
	
	let slice = &s[3..len];
	let slice = &s[3..];
}
```

è·å–æ•´ä¸ªå­—ç¬¦ä¸²çš„sliceï¼š
```rust
#![allow(unused)]
fn main() {
	let s = String::from("hello");
	
	let len = s.len();
	
	let slice = &s[0..len];
	let slice = &s[..];
}
```

æ³¨ï¼šä¸èƒ½ä»ä¸€ä¸ªå¤šå­—èŠ‚å­—ç¬¦çš„ä¸­é—´åˆ›å»ºsliceï¼Œç´¢å¼•å¿…é¡»åœ¨æœ‰æ•ˆçš„UTF-8å­—ç¬¦è¾¹ç•Œå†…

ä½¿ç”¨sliceé‡å†™`first_word()`ï¼š
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```
å­—ç¬¦ä¸²sliceçš„ç±»å‹å£°æ˜å†™ä½œ`&str`ï¼Œç°åœ¨å‡½æ•°è¿”å›çš„æ˜¯ä¸åº•å±‚æ•°æ®å…³è”çš„å•ä¸ªå€¼

å‡½æ•°`second_word()`çš„ç­¾åä¹Ÿå¯ä»¥å†™æˆ`fn second_word(s: &String) -> &str {`

ç”¨sliceç‰ˆæœ¬å°è¯•ä¿®æ”¹å€¼ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼š
```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
`clear()`è¯•å›¾æ¸…ç©º`String`ï¼Œå› æ­¤å®ƒä¼šå°è¯•è·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œæ­¤æ—¶ä¸å¯å˜å¼•ç”¨ä»åœ¨ä½œç”¨åŸŸå†…ï¼Œå› æ­¤Rustç¦æ­¢äº†å¯å˜å¼•ç”¨çš„è·å–

**String Literals as Slices**
ä¹‹å‰æˆ‘ä»¬æåˆ°å­—ç¬¦ä¸²çš„å­—é¢å€¼è¢«å­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼š
`let s = "Hello, world!";`
è¿™é‡Œ`s`çš„ç±»å‹å®é™…ä¸Šæ˜¯`&str`ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘äºŒè¿›åˆ¶æ–‡ä»¶ç‰¹å®šä½ç½®çš„sliceï¼Œè€Œç”±äº`&str`æ˜¯ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œå­—ç¬¦ä¸²å­—é¢å€¼ä¹Ÿæ˜¯ä¸å¯å˜çš„

**String Slices as Parameters**
æ”¹è¿›`first_word()`çš„å‡½æ•°ç­¾åï¼š
`fn first_word(s: &str) -> &str {`
å®ƒå¯ä»¥æ¥å—å­—ç¬¦ä¸²çš„sliceï¼Œå¦‚æœéœ€è¦ä¼ é€’æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œå°±ä¼ é€’æ•´ä¸ªå­—ç¬¦ä¸²çš„sliceï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä¼ é€’å¯¹`String`çš„å¼•ç”¨ï¼Œå¦‚ï¼š
```rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` é€‚ç”¨äº `String`çš„ sliceï¼Œéƒ¨åˆ†æˆ–å…¨éƒ¨
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` ä¹Ÿé€‚ç”¨äº `String` çš„å¼•ç”¨ï¼Œ
    // è¿™ç­‰ä»·äºæ•´ä¸ª `String` çš„ slice
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` é€‚ç”¨äºå­—ç¬¦ä¸²å­—é¢å€¼çš„sliceï¼Œéƒ¨åˆ†æˆ–å…¨éƒ¨
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // å› ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼å·²ç»æ˜¯å­—ç¬¦ä¸² slice äº†ï¼Œ
    // è¿™ä¹Ÿæ˜¯é€‚ç”¨çš„ï¼Œæ— éœ€ slice è¯­æ³•ï¼
    let word = first_word(my_string_literal);
}
```

**Other Slices**
å…¶ä»–ç±»å‹åŒæ ·å¯ä»¥åˆ›é€ sliceï¼š
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```
è¿™ä¸ªsliceçš„ç±»å‹æ˜¯`&[i32]`ï¼Œå®ƒåŒæ ·å­˜å‚¨äº†æŒ‡å‘å…¶å¼€å§‹å…ƒç´ çš„æŒ‡é’ˆå’Œé•¿åº¦

# 5 Using Structs to Structure Related Data
## 5.1 Defining and Instantiating Structs
æˆ‘ä»¬ä½¿ç”¨ `struct` å…³é”®å­—å®šä¹‰ç»“æ„ä½“ï¼Œç»“æ„ä½“ä¸­çš„æ¯ä¸€å­—æ®µåŒ…æ‹¬äº†æ•°æ®åç§°åŠå…¶ç±»å‹ï¼š
```rust
struct User {
	active: bool,
	username: String,
	email: String,
	sign_in_count: u64,
}
```

å®šä¹‰äº†ç»“æ„ä½“ä¹‹åï¼Œæˆ‘ä»¬é€šè¿‡ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“çš„å€¼ä¸ºå®ƒåˆ›é€ ä¸€ä¸ªå®ä¾‹ï¼Œç”¨ `key: value` çš„å½¢å¼è¿›è¡ŒæŒ‡å®šï¼Œå¦‚ï¼š
```rust
fn main() {
	let user = User {
		active: true,
		username: String::from("someusername123"),
		email: String::from("someone@example.com"),
		sign_in_count: 1,
	};
}
```

å¯¹ç»“æ„ä½“å†…éƒ¨å€¼çš„è®¿é—®å¯ä»¥ä½¿ç”¨ `.` 
å¦‚æœå®ä¾‹æ˜¯å¯å˜çš„ï¼Œå¯ä»¥ç›´æ¥æ”¹å˜å­—æ®µçš„å€¼ï¼Œå¦‚ï¼š
```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```
æ³¨æ„æ•´ä¸ªå®ä¾‹éƒ½æ˜¯å¯å˜çš„ï¼ŒRustä¸å…è®¸å•ç‹¬æ ‡è®°æŸä¸ªå­—æ®µå€¼ä¸ºå¯å˜çš„

æˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°çš„ç»“å°¾æ„é€ ä¸€ä¸ªç»“æ„ä½“çš„æ–°å®ä¾‹ä½œä¸ºæœ€åçš„è¡¨è¾¾å¼ï¼Œä»¥è¿”å›è¿™ä¸ªå®ä¾‹ï¼š
```rust
fn build_user(email: String, username: String) -> User {
	User {
		active: true,
		username: username,
		email: email,
		sign_in_count: 1,
	}
}
```

**Using the Field Init Shorthand**
å¦‚æœå‚æ•°åç§°å’Œç»“æ„ä½“å­—æ®µåç§°ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•ï¼š
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username, // ä»£æ›¿äº† username: username
        email,  // ä»£æ›¿äº† email: email
        sign_in_count: 1,
    }
}
```

**Creating Instance from Other Instance with Struct Update Syntax**
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•æ¥ä½¿ç”¨æ—§å®ä¾‹çš„å¤§éƒ¨åˆ†å€¼åˆ›å»ºæ–°å®ä¾‹ï¼Œå¦‚æœä¸ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼š
```rust
fn main() {
    // --snip--
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼š
```rust
fn main() {
	// --snip--
	let user2 = User {
		email: String::from("another@example.com"),
		..user1
	};
}
```
è¯­æ³• `..` æŒ‡å®šäº†å‰©ä½™æ²¡æœ‰æ˜¾å¼è®¾ç½®å€¼çš„å­—æ®µçš„å€¼å’Œç»™å®šå®ä¾‹çš„å¯¹åº”å­—æ®µç›¸åŒï¼Œæ³¨æ„è¯¥è¯­æ³•å¿…é¡»æ”¾åœ¨æœ€å

æ³¨æ„ç»“æ„ä½“æ›´æ–°è¯­æ³•å’Œä½¿ç”¨ `=` çš„èµ‹å€¼æ˜¯ä¸€æ ·çš„ï¼Œå°†ä¼šå¯¼è‡´æ‰€æœ‰æƒçš„ç§»åŠ¨ï¼Œåœ¨æ­¤ä¾‹ä¸­ï¼Œæˆ‘ä»¬åœ¨åˆ›å»ºäº† `user2` ä¹‹åå°±ä¸èƒ½å†ä½¿ç”¨ `user1` äº†ï¼Œå› ä¸º `user1` ä¸­çš„ `username` å­—æ®µä¸­çš„ `String` è¢«ç§»åŠ¨ç»™äº† `user2` ä¸­çš„ `username`ï¼Œå¦‚æœæˆ‘ä»¬ç»™Â `user2`Â çš„Â `email`Â å’ŒÂ `username`Â éƒ½èµ‹äºˆæ–°çš„Â `String`Â å€¼ï¼Œä»è€Œåªä½¿ç”¨Â `user1`Â çš„Â `active`Â å’ŒÂ `sign_in_count`Â å€¼ï¼Œé‚£ä¹ˆÂ `user1`Â åœ¨åˆ›å»ºÂ `user2`Â åä»ç„¶æœ‰æ•ˆï¼Œå› ä¸º`active`Â å’ŒÂ `sign_in_count`Â çš„ç±»å‹éƒ½æ˜¯å®ç°Â `Copy`Â trait çš„ç±»å‹

**Using Tuple Structs Without Named Fields to Create Different Types**
Rustä¹Ÿæ”¯æŒå®šä¹‰å’Œå…ƒç»„ç±»ä¼¼çš„ç»“æ„ä½“ï¼Œç§°ä¸ºå…ƒç»„ç»“æ„ä½“ï¼Œå…ƒç»„ç»“æ„ä½“æ²¡æœ‰å­—æ®µåï¼Œåªæœ‰å­—æ®µçš„ç±»å‹

å®šä¹‰å…ƒç»„ç»“æ„ä½“ï¼š
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
	let black = Color(0, 0, 0);
	let origin = Point(0, 0, 0);
}
```
æ³¨æ„å˜é‡blackå’Œoriginçš„å€¼çš„ç±»å‹æ˜¯ä¸åŒçš„ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒå…ƒç»„ç»“æ„ä½“çš„å®ä¾‹ï¼Œæˆ‘ä»¬å®šä¹‰çš„æ¯ä¸ªç»“æ„ä½“éƒ½æœ‰å…¶è‡ªå·±çš„ç±»å‹ï¼Œå³ä½¿ç»“æ„ä½“çš„å­—æ®µå¯èƒ½æœ‰ç€ç›¸åŒçš„ç±»å‹
å…ƒç»„ç»“æ„ä½“å¯ä»¥ç”¨è§£æ„è¯­æ³•è¿›è¡Œè§£æ„ï¼Œä¹Ÿå¯ä»¥ç”¨ `.` åŠ ç´¢å¼•è®¿é—®å•ç‹¬çš„å€¼

**Unit-Like Structs Without Any Fields**
æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ä½“ç§°ä¸ºç±»å•å…ƒç»“æ„ä½“ï¼Œå› ä¸ºå®ƒä»¬ç±»ä¼¼äºå•å…ƒç±»å‹ `()` (unitç±»å‹)ï¼Œå½“æˆ‘ä»¬éœ€è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°ä¸€ä¸ªtraitï¼Œä½†ä¸æƒ³è¦åœ¨è¿™ä¸ªç±»å‹ä¸Šå­˜å‚¨ä»»ä½•æ•°æ®æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ç±»å•å…ƒç»“æ„ä½“

å£°æ˜å’Œå®ä¾‹åŒ–ç±»å•å…ƒç»“æ„ä½“ï¼š
```rust
struct AlwaysEqual;

fn main {
	let subject = AlwaysEqual; // å®ä¾‹åŒ–
}
```

**Ownership of Struct Data**
åœ¨ç»“æ„ä½“å®šä¹‰ï¼š
```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†å¯¹å€¼æ‹¥æœ‰æ‰€æœ‰æƒçš„ `String` ç±»å‹ï¼Œè€Œä¸æ˜¯ `&str` (å­—ç¬¦ä¸²slice)ç±»å‹ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦ç»“æ„ä½“çš„æ¯ä¸ªå®ä¾‹éƒ½æ‹¥æœ‰è‡ªå·±çš„æ•°æ®ï¼Œå¹¶ä¸”åªè¦è¯¥å®ä¾‹æœ‰æ•ˆï¼Œæ•°æ®å°±æœ‰æ•ˆ

ä½†ç»“æ„ä½“ä¹Ÿå¯ä»¥å­˜å‚¨æŒ‡å‘ç”±å…¶ä»–å¯¹è±¡æ‹¥æœ‰çš„æ•°æ®çš„å¼•ç”¨ï¼Œä½†æˆ‘ä»¬éœ€è¦ç”¨ä¸Šç”Ÿå‘½å‘¨æœŸï¼Œç”Ÿå‘½å‘¨æœŸç”¨äºä¿è¯ç»“æ„ä½“å¼•ç”¨çš„æ•°æ®åœ¨ç»“æ„ä½“æœ‰æ•ˆæ—¶ä¸€å®šæ˜¯æœ‰æ•ˆçš„ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦åœ¨ç»“æ„ä½“ä¸­å­˜å‚¨ä¸€ä¸ªå¼•ç”¨ï¼Œä½†ä¸æŒ‡å®šå£°æ˜å‘¨æœŸï¼Œç¼–è¯‘å™¨å°†æŠ¥é”™ï¼š
```rust
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}
```

## 5.2 An Example Program Using Structs
ä¸€ä¸ªç®€å•çš„ç¨‹åºï¼š
```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```

æ³¨æ„ `area` å‡½æ•°çš„ç­¾åï¼š`fn area(width: u32, height: u32) -> u32 {`
å‡½æ•° `area` åº”è¯¥ç”¨äºè®¡ç®—å‡ºä¸€ä¸ªé•¿æ–¹å½¢çš„é¢ç§¯ï¼Œå®ƒçš„ä¸¤ä¸ªå‚æ•°æ²¡æœ‰è¡¨ç°å®ƒä»¬æœ¬èº«çš„å…³è”æ€§

**Refactoring with Tuples**
å¯ä»¥é‡‡ç”¨å…ƒç»„ä¼ å‚ï¼š
```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```
å…ƒç»„å¢åŠ äº†ç»“æ„æ€§ï¼Œä½†æ²¡æœ‰ç»™å‡ºå…ƒç´ çš„åç§°ï¼Œåªèƒ½ä»¥ä¸‹æ ‡ç´¢å¼•

**Refactoring with Structs: Adding More Meaning**
é‡‡ç”¨ç»“æ„ä½“ä¼ å‚ï¼š
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```
ä¸ºäº†ä¿æŒæ‰€æœ‰æƒï¼Œé‡‡ç”¨äº†å¼•ç”¨ä¼ å‚
é‡‡ç”¨ç»“æ„ä½“ï¼Œä»£ç æœ‰äº†æ›´å¼ºçš„è§£é‡Šæ€§ï¼Œå‡½æ•°çš„ç­¾åæ›´åŠ æ¸…æ™°

**Adding Useful Functionality with Derived Traits**
`println!` å®ä¸èƒ½ç”¨äºç›´æ¥æ‰“å°ç»“æ„ä½“ï¼š
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```
ç¼–è¯‘å™¨æŠ¥é”™ï¼š
`error[E0277]: Rectangle doesn't implement std::fmt::Display`

`prinln!` å®èƒ½å¤„ç†å¾ˆå¤šç±»å‹çš„æ ¼å¼ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œ`{}` ä¼šå‘Šè¯‰ `println!` ä½¿ç”¨ `Display` æ ¼å¼ï¼Œå³ç›´æ¥æä¾›ç»™ç»ˆç«¯ç”¨æˆ·æŸ¥çœ‹çš„è¾“å‡ºï¼Œç›®å‰æ‰€è§çš„åŸºæœ¬ç±»å‹é»˜è®¤éƒ½å®ç°äº† `Display` ï¼Œå› ä¸ºå®ƒä»¬çš„æ˜¾ç¤ºæ–¹å¼æ˜¯æ˜ç¡®çš„ï¼Œä½†æ˜¯å¯¹äºç»“æ„ä½“ï¼Œå¯ä»¥æœ‰ä¸åŒçš„æ˜¾ç¤ºæ–¹å¼ï¼Œå› æ­¤Rustæ²¡æœ‰å¯¹ç»“æ„ä½“å®ç° `Display` 

å¦‚æœæˆ‘ä»¬å°†è¯­å¥æ”¹æˆï¼š`println!("rect1 is {:?}", rect1);` ï¼Œ`{:?}` ä¼šå‘Šè¯‰ `println!` ä½¿ç”¨ `Debug` è¾“å‡ºæ ¼å¼ï¼Œ `Debug` traitå…è®¸æˆ‘ä»¬ç”¨ä¸€ç§æ–¹ä¾¿å¼€å‘è€…dubugçš„æ–¹å¼æ‰“å°ç»“æ„ä½“ï¼ŒRustå¯¹ç»“æ„ä½“é»˜è®¤å®ç°äº† `Debug`

æˆ‘ä»¬éœ€è¦åœ¨ç»“æ„ä½“å®šä¹‰ä¹‹å‰æ˜¾å¼åŠ ä¸Šå¤–éƒ¨å±æ€§ `[derive(Debug)]` æ¥ä¸ºç»“æ„ä½“æ˜¾å¼é€‰æ‹©è¿™ä¸ªåŠŸèƒ½ï¼š
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

ä¹Ÿå¯ä»¥ä½¿ç”¨ `{:#?}`

å¦ä¸€ç§å¯ä»¥ç”¨ `Debug` æ ¼å¼æ‰“å°æ•°æ®çš„æ–¹æ³•æ˜¯ `dbg!` å®ï¼Œ`dbg!` å®ä¼šæ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒ( `println!` å®æ¥æ”¶çš„æ˜¯å¼•ç”¨)ï¼Œæ‰“å°å‡ºè°ƒç”¨è¯¥å®æ—¶æ‰€åœ¨çš„æ–‡ä»¶å’Œè¡Œå·ï¼Œä»¥åŠè¡¨è¾¾å¼çš„å€¼ï¼Œç„¶åè¿”å›å¯¹è¯¥å€¼çš„æ‰€æœ‰æƒ

`dbg!` ä¼šæ‰“å°åˆ° `stderr` å³æ ‡å‡†é”™è¯¯æ§åˆ¶å°æµï¼Œ `println!` ä¼šæ‰“å°åˆ° `stdout` å³æ ‡å‡†è¾“å‡ºæ§åˆ¶å°æµ

ä½¿ç”¨ `dbg!` å®ï¼š
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```
æˆ‘ä»¬å¯ä»¥å°† `dbg!` æ”¾åœ¨è¡¨è¾¾å¼ `(30 * scale)` å‘¨å›´ï¼Œå› ä¸ºå®ƒä¼šè¿”å›æ‰€æœ‰æƒï¼Œå› æ­¤ `width` ä¼šå¾—åˆ°ç›¸åŒçš„å€¼ï¼Œå’Œæ²¡æœ‰ `dbg!` æ˜¯ä¸€æ ·çš„
æˆ‘ä»¬ä¸å¸Œæœ› `rect1` çš„æ‰€æœ‰æƒè¢«å¤ºèµ°ï¼Œå› æ­¤ä¹Ÿå¯ä»¥ä¼ é€’å¼•ç”¨

ç»“æœï¼š
```cmd
> cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ–‡ä»¶åï¼Œè¡Œæ•°ï¼Œè¡¨è¾¾å¼ï¼Œä»¥åŠå®ƒçš„å€¼( `Debug` æ ¼å¼)

Rustæä¾›äº†å¾ˆå¤šå¯ä»¥é€šè¿‡ä½¿ç”¨ `derive` å±æ€§ä½¿ç”¨çš„ traitï¼Œä¸ºæˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹å¢åŠ è¡Œä¸º

## 5.3 Method Syntax
æ–¹æ³•åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡ä¸­è¢«å®šä¹‰(æˆ–è€…æ˜¯æšä¸¾æˆ–traitå¯¹è±¡çš„ä¸Šä¸‹æ–‡)ï¼Œå®ƒä»¬çš„ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ `self` ï¼Œè¡¨ç¤ºè°ƒç”¨å®ƒä»¬çš„ç»“æ„ä½“å®ä¾‹

**Defining Methods**
æˆ‘ä»¬å¯ä»¥å®šä¹‰ `Rectangle` ç»“æ„ä½“çš„ `area` æ–¹æ³•ï¼š
```rust
#[derive(Debug)]
struct Rectangle {
	width: u32,
	height: u32
}

impl Rectangle {
	fn area(&self) -> u32 {
		self.width * self.width
	}
}

fn main() {
	let rect1 = Rectangle {
		width: 30,
		height: 50,
	};
	
	println!("The area of the rectangle is {} square pixels.", 
	rect.area());
}
```
ä¸ºäº†å°†æ–¹æ³•å®šä¹‰åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡å†…ï¼Œæˆ‘ä»¬å¼€å§‹äº†ä¸€ä¸ª `impl` å—ï¼Œä½äºå—å†…çš„æ‰€æœ‰å†…å®¹éƒ½å°†ä¸ `Rectangle` å†…å®¹å…³è”
æ–¹æ³•å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `self`
æ–¹æ³•ä½¿ç”¨æ–¹æ³•è¯­æ³•è°ƒç”¨ï¼Œå³ä¸€ä¸ªå®ä¾‹ååŠ ä¸€ä¸ª `.`

åœ¨æ–¹æ³•å‡½æ•°çš„ç­¾åä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `&self` ä»¥æ›¿ä»£ `rectangle: &Rectangle`ï¼Œ`&self` å®é™…ä¸Šæ˜¯ `self: &Self` çš„ç¼©å†™ï¼Œè€Œåœ¨ä¸€ä¸ª `impl` å—ä¸­ï¼Œ`Self` ç±»å‹æ˜¯ `impl` å—ç±»å‹çš„åˆ«å
æ–¹æ³•å‡½æ•°å¿…é¡»æœ‰ä¸€ä¸ªåå« `self` çš„å‚æ•°ï¼Œå‚æ•°çš„ç±»å‹æ˜¯ `Self`ï¼Œæˆ‘ä»¬ä½¿ç”¨ `self` ä½œä¸ºå…¶ç¼©å†™ï¼Œå¦‚æœæˆ‘ä»¬ä¸å¸Œæœ›æ–¹æ³•å‡½æ•°å¤ºå–æ‰€æœ‰æƒï¼Œæˆ‘ä»¬éœ€è¦åŠ ä¸Š `&` è¡¨ç¤ºå€Ÿç”¨
ä»…ä»…ä½¿ç”¨ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å¼•ç”¨çš„æƒ…å†µæ˜¯å¾ˆå°‘è§çš„ï¼Œé€šå¸¸ç”¨åœ¨è¯¥æ–¹æ³•æ˜¯å°† `self` è½¬æ¢ä¸ºåˆ«çš„å®ä¾‹ï¼Œæˆ‘ä»¬å¸Œæœ›é˜²æ­¢è°ƒç”¨è€…åœ¨è½¬æ¢åä½¿ç”¨åŸå§‹çš„å®ä¾‹

æ–¹æ³•çš„åç§°å’Œç»“æ„ä½“ä¸­å­—æ®µçš„åç§°å¯ä»¥ç›¸åŒï¼Œå¦‚ï¼š
```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```
Rustç¼–è¯‘å™¨å°†é€šè¿‡æ˜¯å¦ `.width` åé¢æœ‰ `()` æ¥åŒºåˆ†

ä¸è¿‡ä¸å­—æ®µåŒåçš„æ–¹æ³•ä¸€èˆ¬å°†è¢«å®šä¹‰ä¸ºåªè¿”å›å­—æ®µçš„å€¼ï¼Œè€Œä¸æ‰§è¡Œå…¶ä»–æ“ä½œï¼Œç§°è¿™æ ·çš„æ–¹æ³•ä¸º `getters` ï¼ŒRustä¸ä¼šå¯¹å…¶è‡ªåŠ¨å®ç°ï¼Œ`getters` çš„ä½¿ç”¨åœºæ™¯åœ¨äºæˆ‘ä»¬å°†å­—æ®µå®šä¹‰ä¸ºç§æœ‰ï¼Œæ–¹æ³•ä¸ºå…¬æœ‰ï¼Œå› æ­¤å¯¹å­—æ®µçš„åªè¯»è®¿é—®ä½œä¸ºè¯¥ç±»å‹çš„å…¬å…±APIçš„ä¸€éƒ¨åˆ†

Rustçš„è‡ªåŠ¨å¼•ç”¨å’Œè§£å¼•ç”¨ï¼š
å½“æˆ‘ä»¬ä½¿ç”¨ `object.something()` è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒRustä¼šè‡ªåŠ¨ä¸º `object` æ·»åŠ  `&`, `&mut`, `*`ï¼Œä»¥ä¾¿ä½¿ `object` åŒ¹é…æ–¹æ³•ç­¾åï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™äº›ä»£ç æ˜¯ç­‰ä»·çš„ï¼š
```rust
p1.distance(&p2)
(&p1).distance(&p2)
```
è¯¥è‡ªåŠ¨å¼•ç”¨æ–¹æ³•ä¹‹æ‰€ä»¥æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºæ–¹æ³•æ€»æ˜¯æœ‰ä¸€ä¸ªæ˜ç¡®çš„æ¥æ”¶è€…ç±»å‹ï¼Œå³ `self` çš„ç±»å‹ï¼Œå› æ­¤Rustå¯ä»¥æ˜ç¡®åœ°è®¡ç®—å‡ºæ–¹æ³•æ˜¯ä»…ä»…è¯»å–(`&self`)ï¼Œä½œå‡ºä¿®æ”¹(`&mut self`)ï¼Œæˆ–æ˜¯è·å–æ‰€æœ‰æƒ(`self`)

**Methods with More Parameters**
æˆ‘ä»¬å¸Œæœ›å®šä¹‰ä¸€ä¸ªå¯ä»¥åˆ¤æ–­ä¸€ä¸ªé•¿æ–¹å½¢æ˜¯å¦å®Œå…¨åŒ…å«å¦ä¸€ä¸ªé•¿æ–¹å½¢çš„æ–¹æ³•ï¼š
```rust
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
æ˜¾ç„¶æ–¹æ³•éœ€è¦ä¸€ä¸ª `Rectangle` ç±»çš„ä¸å¯å˜å¼•ç”¨çš„ç±»å‹çš„å‚æ•°ï¼Œæˆ‘ä»¬åœ¨ `impl` å—ä¸­å®šä¹‰è¿™ä¸ªæ–°çš„æ–¹æ³•ï¼š
```rust
impl Rectangle {
	fn area(&self) -> u32 {
		self.width * self.height
	}
	fn can_hold(&self, other: &Rectangle) -> bool {
		self.width > other.width && self.height > other.height
	}
}
```

**Associated Functions**
æ‰€æœ‰åœ¨ `impl` å—ä¸­å®šä¹‰çš„å‡½æ•°éƒ½ç§°ä¸ºå…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬ä¸ `impl` åé¢å‘½åçš„ç±»å‹ç›¸å…³ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸ä»¥ `self` ä¸ºç¬¬ä¸€å‚æ•°çš„å…³è”å‡½æ•°(å› æ­¤ä¸æ˜¯æ–¹æ³•)ï¼Œå› ä¸ºè¿™äº›æ–¹æ³•å¹¶ä¸ä½œç”¨äºç»“æ„ä½“çš„æŸä¸€ç‰¹å®šå®ä¾‹
åœ¨ `String` ç±»å‹ä¸Šå®šä¹‰çš„ `String::from` å‡½æ•°å°±æ˜¯ä¸€ä¸ªå…³è”å‡½æ•°

ä¸ä½œä¸ºæ–¹æ³•çš„å…³è”å‡½æ•°å¸¸ç”¨ä½œæ”¾å›ä¸€ä¸ªç»“æ„ä½“æ–°å®ä¾‹çš„æ„é€ å‡½æ•°ï¼Œåç§°ä¸€èˆ¬ä¸º `new` ï¼Œå¦‚ï¼š
```rust
impl Rectangle {
	fn square(size: u32) -> Self {
		Self {
			width: size,
			height: size,
		}
	}
}
```
åœ¨ `impl` å—ä¸­ï¼Œå…³é”®è¯ `Self` æŒ‡ä»£ `impl` å…³é”®å­—åå‡ºç°çš„ç±»å‹ï¼Œæ­¤å¤„æŒ‡ä»£ `Rectangle`

æˆ‘ä»¬ä½¿ç”¨ç»“æ„ä½“åå’Œ `::` æ¥è°ƒç”¨å…³è”å‡½æ•°ï¼Œå¦‚`let sq = Rectangle::square(3);` ï¼Œè¯¥å‡½æ•°ä½äºç»“æ„ä½“çš„å‘½åç©ºé—´ä¸­

`::` è¯­æ³•ç”¨äºå…³è”å‡½æ•°å’Œæ¨¡å—åˆ›é€ çš„å‘½åç©ºé—´

**Multiple impl Blocks**
æ¯ä¸ªç»“æ„ä½“éƒ½å…è®¸æ‹¥æœ‰å¤šä¸ª `impl` å—ï¼š
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

# 6 Enums and Pattern Matching
## 6.1 Defining an Enum
ä»»ä½•ä¸€ä¸ªIPåœ°å€åªæœ‰ä¸¤ç§å¯èƒ½çš„å½¢å¼ï¼ŒIPv4æˆ–IPv6ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æšä¸¾ç±»å‹å®šä¹‰ä¸€ä¸ª `IpAddKind` ï¼Œå¹¶åˆ—å‡ºå®ƒçš„æ‰€ç”¨å¯èƒ½å€¼ `V4` å’Œ `V6` ï¼Œå®ƒä»¬ç§°ä¸ºæšä¸¾çš„æˆå‘˜
```rust
enum IpAddKind {
	 V4,
	 V6,
}
```
**Enum Values**
æˆ‘ä»¬å¯ä»¥åˆ›å»º `IpAddKind` ä¸¤ä¸ªä¸åŒæˆå‘˜çš„å®ä¾‹ï¼š
```rust
let four = IpAddKind::V4;
let six = IpAddKind::V6;
```
æšä¸¾çš„æˆå‘˜éƒ½ä½äºå…¶æ ‡è¯†ç¬¦çš„å‘½åç©ºé—´ä¸­ï¼Œæ³¨æ„ `IpAddKind::V4` å’Œ `IpAddKind::V6` éƒ½æ˜¯åŒä¸€ç±»å‹çš„ï¼š
```rust
fn route(ip_kind : IpAddKind) {}

route(IpAddKind::V4);
route(IpAddKind::V6);
```

å¦‚æœæˆ‘ä»¬éœ€è¦å­˜å‚¨IPåœ°å€çš„ç±»å‹å’Œå…·ä½“çš„å€¼ï¼Œå¯ä»¥ï¼š
```rust
enum IpAddKind {
	 V4,
	 V6,
}

struct IpAddr {
	kind: IpAddrKind,
	address: String,
}

let home = IpAddr {
	kind: IpAddrKind::V4,
	address: String::from("127.0.0.1"),
}

let loopback = IpAddr {
	kind: IpAddrKind::V6,
	address: String::From("::1"),
}
```
æˆ‘ä»¬ä½¿ç”¨äº†ç»“æ„ä½“ä½¿æšä¸¾æˆå‘˜å’Œå€¼å…³è”

æˆ‘ä»¬å¯ä»¥ç”¨æ›´ç®€æ´çš„æ–¹å¼è¡¨ç¤ºç›¸åŒçš„æ¦‚å¿µï¼Œå³ä»…ä»…ä½¿ç”¨æšä¸¾ç±»å‹ï¼Œå¹¶ä¸”å°†æ•°æ®ç›´æ¥æ”¾è¿›æ¯ä¸ªæšä¸¾æˆå‘˜ï¼š
```rust
enum IpAddr {
	V4(String),
	V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
```
æˆ‘ä»¬å°†ä¸¤ä¸ªæˆå‘˜éƒ½å…³è”äº† `String` å€¼ï¼Œå°†æ•°æ®ç›´æ¥é™„åŠ åˆ°äº†æšä¸¾çš„æ¯ä¸ªæˆå‘˜ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æ¯ä¸ªæˆ‘ä»¬å®šä¹‰çš„æšä¸¾æˆå‘˜çš„åå­—åŒæ—¶ä¹Ÿæˆä¸ºäº†æ„å»ºæšä¸¾å®ä¾‹çš„å‡½æ•°ï¼Œå¦‚ `IpAddr::V4()` æ¥å—ä¸€ä¸ª `String` ç±»å‹å‚æ•°ï¼Œè¿”å›ä¸€ä¸ª `IpAddr` ç±»å‹çš„å®ä¾‹ï¼Œè¿™äº›æ„é€ å‡½æ•°ä¼šåœ¨å®šä¹‰æšä¸¾ç±»å‹çš„æ—¶å€™è‡ªåŠ¨è¢«å®šä¹‰

æšä¸¾ç±»å‹çš„æ¯ä¸ªæˆå‘˜å¯ä»¥å¤„ç†ä¸åŒç±»å‹å’Œæ•°é‡çš„æ•°æ®ï¼Œå¦‚ï¼š
```rust
enum IpAddr {
	V4(u8, u8, u8, u8),
	V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

Rustçš„æ ‡å‡†åº“æä¾›äº†ç”¨äºå­˜å‚¨å’Œç¼–ç IPåœ°å€çš„ç±»å‹ï¼Œæ ‡å‡†åº“å®šä¹‰äº†æšä¸¾ç±»å‹ `IpAddr` ï¼Œè€Œæˆå‘˜å…³è”çš„æ•°æ®çš„ç±»å‹æ˜¯è‡ªå®šä¹‰çš„ç»“æ„ä½“ç±»å‹ï¼š
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
è¿™è¯´æ˜æˆ‘ä»¬å¯ä»¥å°†ä»»æ„ç±»å‹çš„æ•°æ®æ”¾å…¥æšä¸¾ç±»å‹çš„æˆå‘˜ä¸­ï¼Œç”šè‡³å¦ä¸€ä¸ªæšä¸¾ç±»å‹

æ³¨æ„å³ä½¿æ ‡å‡†åº“æœ‰ `IpAddr` çš„å®šä¹‰ï¼Œä½†å¦‚æœæˆ‘ä»¬æ²¡æœ‰å°†æ ‡å‡†åº“çš„å®šä¹‰å¼•å…¥ä½œç”¨åŸŸï¼Œå°±ä¸ä¼šå¼•å‘å†²çª

æˆå‘˜ä¸­å†…åµŒäº†å¤šç§ç±»å‹çš„æšä¸¾ç±»å‹ï¼š
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
è¯¥æšä¸¾ç±»å‹æœ‰å››ä¸ªä¸åŒç±»å‹çš„æˆå‘˜ï¼š
- `Quit` æ²¡æœ‰å…³è”ä»»ä½•æ•°æ®
- `Move` åŒ…å«äº†å‘½åçš„å­—æ®µï¼Œç±»ä¼¼ç»“æ„ä½“
- `Write` åŒ…å«äº†ä¸€ä¸ª `String`
- `ChangeColor` åŒ…å«äº†3ä¸ª `i32`

äº‹å®ä¸Šå®šä¹‰æšä¸¾ç±»å‹çš„æˆå‘˜å°±åƒå®šä¹‰äº†å¤šä¸ªä¸åŒç±»å‹çš„ç»“æ„ä½“ï¼Œå¦‚ï¼š
```rust
struct QuitMessage; // unit struct ç±»å•å…ƒç»“æ„ä½“
struct MoveMessge {
	x: i32,
	y: i32,
}
struct WriteMessage(String); // tuple struct å…ƒç»„ç»“æ„ä½“
struct ChangeColorMessage(i32, i32, i32); //tuple struct å…ƒç»„ç»“æ„ä½“
```

ç»“æ„ä½“å’Œæšä¸¾çš„å¦ä¸€ä¸ªç›¸ä¼¼ç‚¹æ˜¯æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨æšä¸¾ç±»å‹ä¸Šå®šä¹‰æ–¹æ³•ï¼Œå¦‚ï¼š
```rust
impl Message {
	fn call(&self) {
		// method body
	}
}
let m = Message::Write(String::from("hello"));
m.call()
```
æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå˜é‡ `m` ï¼Œå®ƒçš„å€¼æ˜¯ `Message::Write(String::from("hello"))` ï¼Œå½“ `m.call()` è°ƒç”¨æ—¶ï¼Œæ–¹æ³•ä½“é€šè¿‡ `&self` å‚æ•°è·å–äº†è¿™ä¸ªå€¼ï¼Œå³è·å–äº†è°ƒç”¨è¿™ä¸ªæ–¹æ³•çš„å€¼

**The Option Enum and Its Advantages Over Null Values**
`Option` æ˜¯æ ‡å‡†åº“å®šä¹‰çš„ä¸€ä¸ªæšä¸¾ç±»å‹

åœ¨Rustä¸­ï¼Œä¸å­˜åœ¨ç©ºå€¼çš„æ¦‚å¿µï¼Œåœ¨æœ‰ç©ºå€¼çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ€»æ˜¯å¤„äºè¿™ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šç©ºå€¼å’Œéç©ºå€¼
ä½†ç©ºå€¼çš„é—®é¢˜åœ¨äºå½“æˆ‘ä»¬å°è¯•åƒä½¿ç”¨ä¸€ä¸ªéç©ºå€¼ä¸€æ ·ä½¿ç”¨ä¸€ä¸ªç©ºå€¼ï¼Œä¼šå¯¼è‡´æŸç§å½¢å¼çš„é”™è¯¯
ç©ºå€¼å°è¯•è¡¨è¾¾çš„æ¦‚å¿µæ˜¯ï¼šç©ºå€¼æ˜¯ä¸€ä¸ªå› ä¸ºæŸç§åŸå› ç›®å‰æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼

Rustæ²¡æœ‰ç©ºå€¼ï¼Œè€Œæ˜¯æ‹¥æœ‰ä¸€ä¸ªå¯ä»¥ç¼–ç å­˜åœ¨æˆ–ä¸å­˜åœ¨çš„æ¦‚å¿µçš„æšä¸¾ç±»å‹ï¼Œå³ `Option<T>` ï¼Œå®šä¹‰äºæ ‡å‡†åº“ä¸­ï¼š
```rust
enum Option<T> {
	None,
	Some(T),
}
```
`Option<T>` åŒ…å«åœ¨äº†precludeä¸­ï¼Œå› æ­¤ä¸éœ€è¦æ˜¾å¼åœ°å°†å…¶ä»£å…¥ä½œç”¨åŸŸï¼Œ`Option<T>` çš„æˆå‘˜ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ä½¿ç”¨ `Option::` å‰ç¼€æ¥ä½¿ç”¨ `Some` å’Œ `None` 

`<T>` è¯­æ³•è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°ï¼Œ`<T>` æ„å‘³ç€ `Option` æšä¸¾ä¸­çš„ `Some` æˆå‘˜å¯ä»¥åŒ…å«ä»»æ„ç±»å‹çš„æ•°æ®ï¼Œä¸åŒçš„ `<T>` å¯ä»¥è®© `Option<T>` æˆä¸ºä¸åŒçš„ç±»å‹ï¼Œå¦‚ï¼š
```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```
`some_number` çš„ç±»å‹æ˜¯ `Option<i32>` ï¼Œ`some_char` çš„ç±»å‹æ˜¯ `Option<char>` ï¼Œæˆ‘ä»¬åœ¨ `Some` æˆå‘˜ä¸­æŒ‡å®šäº†å€¼ï¼Œå› æ­¤Rustå¯ä»¥æ¨æ–­å…¶ç±»å‹ï¼Œè€Œ `absent_number` æ— æ³•çš„ç±»å‹æ— æ³•ä» `None` æ¨æ–­ï¼Œå› æ­¤éœ€è¦æ˜¾å¼æŒ‡å®šç±»å‹

å› ä¸º `Option<T>` å’Œ `T` æ˜¯å®Œå…¨ä¸åŒçš„ç±»å‹ï¼Œç¼–è¯‘å™¨ä¸å…è®¸æˆ‘ä»¬åƒè¿™æ˜¯ä¸€ä¸ªè‚¯å®šæœ‰æ•ˆçš„å€¼ä¸€æ ·ä½¿ç”¨ `Option<T>` ï¼Œå¦‚ï¼š
```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```
ä¼šç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º `Option<i8>` å’Œ `i8` çš„ç±»å‹ä¸åŒï¼ŒRustä¸å…è®¸å°†å…¶ç›¸åŠ ï¼Œå½“åœ¨Rustä¸­æ‹¥æœ‰ä¸€ä¸ª `i8` ç±»å‹çš„å€¼ï¼Œç¼–è¯‘å™¨ä¼šç¡®ä¿å®ƒçš„å€¼æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œæˆ‘ä»¬æ— éœ€å¯¹å®ƒåšç©ºå€¼æ£€æŸ¥ï¼Œè€Œå½“æˆ‘ä»¬ä½¿ç”¨ `Option<i8>` ç±»å‹æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å®ƒçš„å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µ

å› æ­¤æˆ‘ä»¬åœ¨å¯¹ `Option<T>` è¿›è¡Œè¿ç®—ä¹‹å‰ï¼Œå¿…é¡»å°†å®ƒè½¬åŒ–ä¸º `T` ï¼Œè€Œè¿™å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ•è·åˆ°ç©ºå€¼æœ€å¸¸è§çš„é—®é¢˜ä¹‹ä¸€ï¼šå‡è®¾æŸå€¼ä¸ä¸ºç©ºè€Œå®é™…ä¸Šä¸ºç©º

Rusté€šè¿‡è¿™æ ·æ¶ˆé™¤äº†é”™è¯¯åœ°å‡è®¾ä¸€ä¸ªéç©ºå€¼çš„å±é™©ï¼Œä¸ºäº†æ‹¥æœ‰ä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å€¼ï¼Œæˆ‘ä»¬éœ€è¦æ˜¾å¼åœ°å°†å…¶ç±»å‹å£°æ˜ä¸º `Option<T>` ï¼Œè€Œå½“æˆ‘ä»¬è¦ä½¿ç”¨ `Option<T>` æ—¶ï¼Œéœ€è¦æ˜ç¡®å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µï¼Œè‹¥ä¸€ä¸ªå€¼çš„ç±»å‹ä¸æ˜¯ `Option<T>` ï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°è®¤ä¸ºå®ƒçš„å€¼ä¸ä¸ºç©º

é€šå¸¸æˆ‘ä»¬ç”¨ `match` è¡¨è¾¾å¼å¤„ç†æšä¸¾ç±»å‹ï¼Œé€šè¿‡æšä¸¾ç±»å‹çš„ä¸åŒæˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç 

## 6.2 The match Control Flow Construct
`match` æ§åˆ¶æµè¿ç®—ç¬¦å…è®¸æˆ‘ä»¬å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œç›¸åº”ä»£ç ï¼Œæ¨¡å¼å¯ä»¥æ˜¯å­—é¢å€¼ï¼Œå˜é‡åï¼Œé€šé…ç¬¦ç­‰ç­‰ï¼Œä½¿ç”¨ `match` æ—¶ï¼Œç¼–è¯‘å™¨æ£€æŸ¥ä¼šç¡®ä¿æ‰€æœ‰å¯èƒ½çš„æƒ…å†µéƒ½å¾—åˆ°äº†å¤„ç†

ä½¿ç”¨ `match` çš„ä¾‹å­ï¼š
```rust
enum Coin {
	Penny,
	Nickel,
	Dime,
	Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
	match coin {
		Coin::Penny => 1,
		Coin::Nickel => 5,
		Coin::Dime => 10,
		Coin::Quarter => 25,
	}
}
```
æˆ‘ä»¬åœ¨ `match` å…³é”®å­—åè·Ÿä¸Šäº†ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæœ¬ä¾‹ä¸­æ˜¯ `coin` çš„å€¼ï¼Œå®ƒå’Œ `if` å…³é”®å­—çš„åŒºåˆ«åœ¨äº `if` åè·Ÿçš„æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»è¿”å›ä¸€ä¸ªå¸ƒå°”ç±»å‹çš„å€¼ï¼Œè€Œ `match` åçš„è¡¨è¾¾å¼çš„å€¼å¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œæœ¬ä¾‹ä¸­çš„ç±»å‹æ˜¯ `Coin` æšä¸¾ç±»å‹

ä¹‹åæˆ‘ä»¬è·Ÿä¸Šäº† `match` åˆ†æ”¯ï¼Œä¸€ä¸ª `match` åˆ†æ”¯ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šæ¨¡å¼+ä»£ç ï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼æ˜¯å€¼ `Coin::Penny` ï¼Œä»£ç æ˜¯å€¼ `1` ï¼Œæ¯ä¸ªåˆ†æ”¯ç”±é€—å·éš”å¼€

`match` è¡¨è¾¾å¼æ‰§è¡Œæ—¶ï¼Œå®ƒå°†å€¼ä¸æ¨¡å¼ä¸€ä¸€åŒ¹é…ï¼Œå¦‚æœæˆåŠŸåŒ¹é…ï¼Œåˆ™æ‰§è¡Œä»£ç ï¼Œè€Œè¿™äº›ä»£ç åº”æ˜¯è¡¨è¾¾å¼ï¼Œè¯¥è¡¨è¾¾å¼çš„ç»“æœå€¼å°†ä½œä¸ºæ•´ä¸ª `match` è¡¨è¾¾å¼çš„è¿”å›å€¼

å¦‚æœéœ€è¦åœ¨åˆ†æ”¯ä¸­è¿è¡Œå¤šè¡Œä»£ç ï¼Œéœ€è¦ä½¿ç”¨å¤§æ‹¬å·ï¼Œå¹¶ä¸”åˆ†æ”¯åçš„é€—å·å¯ä»¥çœç•¥ï¼Œåˆ†æ”¯çš„è¿”å›å€¼æ˜¯ä»£ç å—ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼š
```rust
fn value_in_cents(coin: Coin) -> u8 {
	match coin {
		Coin::Penny => {
			println!("Lucky penny!");
			1	
		}
		Coin::Nickel => 5, 
		Coin::Dime => 10, 
		Coin::Quarter => 25,
	}
}
```

**Patterns That Bind to Values**
`match` åˆ†æ”¯çš„å¦ä¸€ä¸ªä½œç”¨æ˜¯ç»‘å®šåŒ¹é…æ¨¡å¼çš„éƒ¨åˆ†å€¼ï¼Œè¿™ä¹Ÿæ˜¯å¦‚ä½•ä»æšä¸¾æˆå‘˜ä¸­æå–å€¼çš„ï¼š
```rust
#[derive(Debug)] // è¿™æ ·å¯ä»¥ç«‹åˆ»çœ‹åˆ°å·çš„åç§°
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```
æˆ‘ä»¬åœ¨æšä¸¾ç±»å‹ `Coin` çš„æˆå‘˜ `Quarter` çš„ä¸­å­˜æ”¾ä¸€ä¸ªç±»å‹ä¸º `UsState` çš„å€¼

åœ¨ `match` è¡¨è¾¾å¼ä¸­ï¼Œæˆ‘ä»¬åœ¨åŒ¹é… `Coin::Quarter` æˆå‘˜çš„åˆ†æ”¯çš„æ¨¡å¼ä¸­å¢åŠ äº†ä¸€ä¸ª `state` å˜é‡ï¼Œå½“æˆå‘˜ `Coin::Quarter` åŒ¹é…æˆåŠŸï¼Œå˜é‡ `state` å°†å’Œè¯¥æˆå‘˜ç›¸å…³è”çš„å€¼ç»‘å®šï¼š
```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```
å¦‚æœè°ƒç”¨Â `value_in_cents(Coin::Quarter(UsState::Alaska))`ï¼Œå‚æ•°å˜é‡ `coin`Â å°†æ˜¯Â `Coin::Quarter(UsState::Alaska)` ï¼ŒåŒ¹é…æ—¶ï¼Œ`state`Â å°†ä¼šä¸å€¼Â `UsState::Alaska` ç»‘å®šï¼Œä¹‹åæˆ‘ä»¬å¯ä»¥é€šè¿‡ `state` ä½¿ç”¨å€¼ `UsState::Alaska`

**Matching with Option\<T\>**
`Option<T>` ä¹Ÿæ˜¯æšä¸¾ç±»å‹ï¼Œå› æ­¤ä¹Ÿå¯ä»¥æ­é… `match` å…³é”®å­—ï¼š
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
	match x {
		None => None,
		Some(i) => Some(i+1),
	}
}
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```
å½“æˆ‘ä»¬è°ƒç”¨ `plus_one(five)` ï¼Œ`plus_one` å‡½æ•°ä½“ä¸­çš„ `x` å°†ä¼šæ˜¯å€¼ `Some(5)` ï¼Œç„¶åå’Œ `Some(i)` åŒ¹é…ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„æˆå‘˜ï¼Œç„¶å `i` ç»‘å®šäº† `Some` ä¸­åŒ…å«çš„å€¼ï¼Œå³ `i` æ‹¥æœ‰äº†å€¼ `5` ï¼Œä¹‹åæˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªå«æœ‰æ–°çš„å€¼ `6` çš„ `Some` å¹¶è¿”å›

**Matches Are Exhaustive**
`match` çš„åˆ†æ”¯å¿…é¡»åŒ…å«æ‰€æœ‰å¯èƒ½æ€§ï¼Œå¦‚ï¼š
```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```
ä¼šç¼–è¯‘é”™è¯¯ï¼ŒRustä¼šå‘Šè¯‰æˆ‘ä»¬å“ªäº›æ¨¡å¼ç¼ºå¤±äº†
å› æ­¤Rustä¸­çš„åŒ¹é…æ˜¯å¯ç©·å°½çš„ï¼Œå¿…é¡»åŒ…å«æ‰€æœ‰çš„å¯èƒ½æ€§

**Catch-all Patterns and the _ Placeholder**
åœ¨ `match` ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°å¯¹ç‰¹å®šçš„å€¼é‡‡å–ç‰¹æ®Šæ“ä½œï¼Œè€Œå¯¹å…¶ä»–çš„å€¼é‡‡å–é»˜è®¤æ“ä½œï¼š
```rust
let dice_roll = 9;
match dice_roll {
	3 => add_fancy_hat(),
	7 => remove_fancy_hat(),
	other => move_player(other),
}
fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```
å‰ä¸¤ä¸ªåˆ†æ”¯çš„åŒ¹é…æ¨¡å¼æ˜¯å­—é¢å€¼ `3` å’Œ `7`  ï¼Œæœ€åä¸€ä¸ªåˆ†æ”¯æ¶µç›–äº† `u8` çš„æ‰€æœ‰å…¶ä»–å¯èƒ½çš„å€¼ï¼Œå…¶æ¨¡å¼æ˜¯åä¸º `other` å˜é‡ï¼Œ`move_player` å‡½æ•°ä½¿ç”¨äº†è¿™ä¸ªå˜é‡
é€šé…æ¨¡å¼å¿…é¡»æ”¾åœ¨æœ€å

å¦‚æœæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€šé…æ¨¡å¼ï¼Œä½†ä¸å¸Œæœ›ä½¿ç”¨å…¶è·å–çš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡å¼ `_` ï¼Œè¿™ä¸ªæ¨¡å¼å¯ä»¥åŒ¹é…ä»»æ„å€¼ä½†ä¸ä¼šè¿›è¡Œç»‘å®šï¼Œè¿™å‘Šè¯‰Rustæˆ‘ä»¬ä¸ä¼šä½¿ç”¨è¿™ä¸ªå€¼ï¼Œå› æ­¤Rustä¹Ÿä¸ä¼šè­¦å‘Šæˆ‘ä»¬å­˜åœ¨æœªä½¿ç”¨çš„å˜é‡ï¼š
```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
}
```

å¦‚æœæˆ‘ä»¬åªæ˜¯å¸Œæœ›æ»¡è¶³ `match` çš„å¯ç©·ä¸¾æ€§ï¼Œä½†é€šé…æ¨¡å¼ä¸‹ä¸ä¼šæ‰§è¡Œä»»ä½•ä»£ç ï¼Œåˆ™ï¼š
```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
}
```
æˆ‘ä»¬ä½¿ç”¨å•å…ƒå€¼(ç©ºå…ƒç»„)ä½œä¸º `_` åˆ†æ”¯çš„ä»£ç ï¼Œæ˜ç¡®å‘Šè¯‰Rustæˆ‘ä»¬ä¸ä¼šä½¿ç”¨ä¸å‰é¢æ¨¡å¼ä¸åŒ¹é…çš„å€¼ï¼Œå¹¶ä¸”ä¸ä¼šåœ¨è¿™ç§æƒ…å†µä¸‹è¿è¡Œä»»ä½•ä»£ç 

## 6.3 Concise Control Flow with if let
`if let` è¯­æ³•ç”¨äºå¤„ç†åªåŒ¹é…ä¸€ä¸ªæ¨¡å¼çš„å€¼è€Œå¿½ç•¥å…¶ä»–æ¨¡å¼çš„æƒ…å†µï¼Œå¦‚ï¼š
```rust
let config_max = Some(3u8);
match config_max {
	Some(max) => println!("The maximum is configured to be {}",max),
	_ => (),
}
```
è¯¥ç¨‹åºåŒ¹é… `config_max` å˜é‡ä¸­çš„ `Option<u8>` ç±»å‹çš„å€¼ï¼Œå¹¶ä¸”åªæœ‰åœ¨è¯¥å€¼ä¸º `Some` æˆå‘˜æ—¶æ‰§è¡Œä»£ç 

å¦‚æœä½¿ç”¨ `if let` è¯­æ³•ï¼š
```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
	println!("The maximum is configured to be {}", max);
}
```
`if let` è¯­æ³•ä¸­ï¼Œæ¨¡å¼å’Œè¡¨è¾¾å¼é€šè¿‡ç­‰å·åˆ†éš”ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼å’Œ `match` ç›¸åŒï¼Œç­‰å·åçš„è¡¨è¾¾å¼å¯¹åº” `match` åçš„è¡¨è¾¾å¼ï¼Œç­‰å·å‰çš„æ¨¡å¼å¯¹åº” `match` ä¸­çš„æ¨¡å¼ï¼Œå¦‚æœæ¨¡å¼ä¸åŒ¹é…ï¼Œ`if let` åçš„ä»£ç å—ä¸ä¼šæ‰§è¡Œ

å¯ä»¥è®¤ä¸º `if let` è¯­æ³•æ˜¯ `match` è¯­æ³•çš„è¯­æ³•ç³–

å¯ä»¥åœ¨ `if let` è¯­æ³•ä¸­æ·»åŠ  `else` ï¼Œ`else` å—ä¸­çš„ä»£ç å’Œ `match` è¡¨è¾¾å¼ä¸­ `_` å—ä¸­çš„ä»£ç ç›¸åŒ
ä»¥ä¸‹ä¸¤ç§æ–¹å¼æ˜¯ç­‰ä»·çš„ï¼š
```rust
let mut count = 0;
match coin {
	Coin::Quarter(state) => println!("State quarter from {:?}!", state),
	_ => count += 1,
}
```
```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
	println!("State quarter from {:?}!", state);
} else {
	count += 1;
}
```

# 7 Managing Growing Projects with Packages, Crates, and Modules
ç›®å‰æˆ‘ä»¬ç¼–å†™çš„ä»£ç éƒ½å¤„äºä¸€ä¸ªæ–‡ä»¶çš„ä¸€ä¸ªæ¨¡å—ä¸­
ä¸€ä¸ªåŒ…(package)å¯ä»¥åŒ…å«å¤šä¸ªäºŒè¿›åˆ¶crateé¡¹å’Œä¸€ä¸ªå¯é€‰çš„crateåº“ï¼Œéšç€åŒ…çš„å¢é•¿ï¼Œæˆ‘ä»¬å¯ä»¥å°†åŒ…ä¸­çš„éƒ¨åˆ†ä»£ç æå–å‡ºæ¥åšæˆç‹¬ç«‹çš„crateï¼Œè¿™äº›crateå°±ä¼šä½œä¸ºå¤–éƒ¨ä¾èµ–é¡¹
å¯¹äºç”±ä¸€ç³»åˆ—äº’ç›¸å…³è”çš„åŒ…ç»„æˆçš„è¶…å¤§å‹é¡¹ç›®ï¼ŒCargoæä¾›äº†å·¥ä½œç©ºé—´åŠŸèƒ½

å°è£…ä½¿å¾—æˆ‘ä»¬åœ¨é«˜çš„çº§åˆ«é‡ç”¨ä»£ç ï¼Œå½“æˆ‘ä»¬å®ç°ä¸€ä¸ªæ“ä½œåï¼Œå…¶ä»–ä»£ç å¯ä»¥é€šè¿‡è¯¥ä»£ç çš„å…¬å…±æ¥å£è¿›è¡Œè°ƒç”¨ï¼Œè€Œä¸éœ€è¦å®ƒæ˜¯å¦‚ä½•å®ç°çš„

ä½œç”¨åŸŸï¼šä»£ç æ‰€åœ¨çš„åµŒå¥—ä¸Šä¸‹æ–‡ä¸­æœ‰ä¸€ç»„å®šä¹‰ä¸ºâ€œin scopeâ€çš„åç§°ï¼ŒåŒä¸€ä¸ªä½œç”¨åŸŸä¸èƒ½æœ‰ä¸¤ä¸ªåç§°ç›¸åŒçš„é¡¹

Rustçš„æ¨¡å—ç³»ç»ŸåŒ…æ‹¬ï¼š
- åŒ…(Packages)ï¼šCargoçš„ä¸€ä¸ªåŠŸèƒ½ï¼Œå…è®¸æˆ‘ä»¬æ„å»ºï¼Œæµ‹è¯•å’Œåˆ†äº«crates
- Cratesï¼šä¸€ä¸ªæ¨¡å—æ ‘ï¼Œå½¢æˆäº†åº“å’ŒäºŒè¿›åˆ¶å¯æ‰§è¡Œé¡¹ç›®
- æ¨¡å—(Modules)å’Œ useï¼šå…è®¸æˆ‘ä»¬æ§åˆ¶ä½œç”¨åŸŸå’Œè·¯å¾„çš„ç§æœ‰æ€§
- è·¯å¾„(Paths)ï¼šä¸€ç§å‘½åç»“æ„ä½“ã€å‡½æ•°ã€æ¨¡å—ç­‰é¡¹çš„æ–¹å¼

## 7.1 Packages and Crates
ä¸€ä¸ªcrateæ˜¯Ruståœ¨ç¼–è¯‘æ—¶çš„æœ€å°å•ä½ï¼Œå¦‚æœæˆ‘ä»¬ç”¨ `rustc` å‘½ä»¤ç¼–è¯‘ï¼Œä¼ é€’ä¸€ä¸ªæºä»£ç æ–‡ä»¶ç»™å®ƒï¼Œç¼–è¯‘å™¨ä¼šå°†è¿™ä¸ªæ–‡ä»¶è§†ä¸ºä¸€ä¸ªcrate
crateå¯ä»¥åŒ…å«æ¨¡å—ï¼Œè€Œæ¨¡å—å¯ä»¥å®šä¹‰åœ¨å…¶ä»–æ–‡ä»¶ï¼Œç„¶åå’Œcrateä¸€èµ·ç¼–è¯‘

crateæœ‰ä¸¤ç§å½¢å¼ï¼šäºŒè¿›åˆ¶é¡¹(äºŒè¿›åˆ¶crate)æˆ–åº“(åº“crate)
äºŒè¿›åˆ¶é¡¹å¯ä»¥è¢«ç¼–è¯‘ä¸ºå¯æ‰§è¡Œç¨‹åºï¼Œå¦‚ä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åºæˆ–ä¸€ä¸ªæœåŠ¡å™¨ï¼Œå› æ­¤ä»–ä»¬å¿…é¡»æœ‰ä¸€ä¸ª `main` å‡½æ•°å®šä¹‰ç¨‹åºæ‰§è¡Œæ—¶éœ€è¦åšçš„äº‹ï¼Œæˆ‘ä»¬ç›®å‰åˆ›å»ºçš„crateéƒ½æ˜¯äºŒè¿›åˆ¶é¡¹
åº“æ²¡æœ‰ `main` å‡½æ•°ï¼Œå®ƒä»¬ä¹Ÿä¸ä¼šè¢«ç¼–è¯‘æˆå¯æ‰§è¡Œç¨‹åºï¼Œå®ƒä»¬æä¾›ä¸€äº›å‡½æ•°çš„å®šä¹‰ä»¥ä¾¿å…¶ä»–é¡¹ç›®ä½¿ç”¨ï¼Œå¦‚ `rand` crateå°±æä¾›äº†ç”Ÿæˆéšæœºæ•°çš„å‡½æ•°ï¼Œå¤§å¤šæ•°æ—¶å€™ï¼ŒcrateæŒ‡çš„æ˜¯åº“ï¼Œå’Œå…¶ä»–ç¼–ç¨‹è¯­è¨€çš„libraryæ¦‚å¿µä¸€è‡´

`crate root` æ˜¯ä¸€ä¸ªæºæ–‡ä»¶ï¼ŒRustç¼–è¯‘å™¨ä»¥å®ƒä¸ºèµ·å§‹ç‚¹ï¼Œå¹¶æ„å»ºæˆ‘ä»¬çš„crateçš„æ ¹æ¨¡å—

åŒ…(package)æ˜¯æä¾›ä¸€ç³»åˆ—åŠŸèƒ½çš„ä¸€ä¸ªæˆ–å¤šä¸ªcrateï¼Œä¸€ä¸ªåŒ…ä¼šåŒ…å«ä¸€ä¸ª `Cargo.toml` æ–‡ä»¶æ¥æè¿°å¦‚ä½•æ„å»ºè¿™äº›crate

Cargoå®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªåŒ…ï¼Œå®ƒåŒ…å«äº†ä¸€äº›äºŒè¿›åˆ¶é¡¹ï¼Œè¿™äº›äºŒè¿›åˆ¶é¡¹å®ç°äº†Cargoçš„å‘½ä»¤è¡ŒæŒ‡ä»¤ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™äº›æŒ‡ä»¤æ¥æ„å»ºæˆ‘ä»¬çš„ä»£ç ï¼ŒåŒæ—¶ï¼ŒCargoä¹ŸåŒ…å«äº†è¿™äº›äºŒè¿›åˆ¶é¡¹çš„æ‰€ä¾èµ–çš„åº“ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥åˆ©ç”¨Cargoä¸­çš„è¿™äº›åº“è‡ªå·±å®ç°Cargoçš„å‘½ä»¤è¡Œå·¥å…·

ä¸€ä¸ªåŒ…åªèƒ½åŒ…å«è‡³å¤šä¸€ä¸ªåº“ï¼Œä½†å¯ä»¥åŒ…å«ä»»æ„å¤šä¸ªäºŒè¿›åˆ¶é¡¹
ä¸€ä¸ªåŒ…ä¸å…è®¸æ˜¯ç©ºçš„ï¼Œå¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ªcrate(æ— è®ºæ˜¯åº“è¿˜æ˜¯äºŒè¿›åˆ¶é¡¹)

åˆ›å»ºä¸€ä¸ªåŒ…ï¼š
```cmd
> cargo new my-project
	Created binary (application) `my-project` package
	
> dir my-project
Cargo.toml
src

> dir my-projuct/src
main.rs
```
å½“æˆ‘ä»¬è¿è¡Œäº† `cargo new` ï¼Œ Cargoä¸ºæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå«åš `my-project` çš„åŒ…ï¼ŒåŒæ—¶é¡¹ç›®æ ¹ç›®å½•ä¸‹æœ‰ä¸€ä¸ª `Cargo.toml` æ–‡ä»¶ï¼Œå¯ä»¥å‘ç° `Cargo.toml` æ–‡ä»¶ä¸­æ²¡æœ‰æåˆ° `src/main.rs` æ–‡ä»¶ï¼Œå› ä¸ºCargoéµå¾ª `src/main.rs` å°±æ˜¯ä¸åŒ…åŒåçš„äºŒè¿›åˆ¶é¡¹çš„crateæ ¹ï¼ŒåŒæ ·åœ°ï¼Œå¦‚æœCargoå‘ç°åŒ…ç›®å½•ä¸­åŒ…å«äº† `src/lib.rs` ï¼Œåˆ™Cargoä¼šè®¤ä¸ºåŒ…ä¸­åŒ…å«äº†ä¸åŒ…åŒåçš„åº“ï¼Œä¸”å®ƒçš„crateæ ¹æ˜¯ `src/lib.rs` ï¼Œcrateæ ¹æ–‡ä»¶å°†ç”±Cargoä¼ ç»™ `rustc` æ¥æ„å»ºåº“æˆ–äºŒè¿›åˆ¶é¡¹

åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬æœ‰äº†åªåŒ…å« `src/main.rs` çš„åŒ…ï¼Œè¯´æ˜å®ƒåªåŒ…å«äº†ä¸€ä¸ªåä¸º `my-project` çš„äºŒè¿›åˆ¶é¡¹(äºŒè¿›åˆ¶crate)ï¼Œå¦‚æœä¸€ä¸ªåŒ…åŒ…å«äº† `src/main.rs` å’Œ `src/lib.rs` è¯´æ˜å®ƒåŒ…å«äº†ä¸¤ä¸ªcrateï¼Œä¸€ä¸ªäºŒè¿›åˆ¶é¡¹ï¼Œä¸€ä¸ªåº“ï¼Œä¸”åå­—éƒ½ä¸åŒ…ç›¸åŒ

ä¸€ä¸ªåŒ…å¯ä»¥æœ‰å¤šä¸ªäºŒè¿›åˆ¶é¡¹ï¼Œå…¶ä»–çš„äºŒè¿›åˆ¶é¡¹å­˜å‚¨åœ¨ `src/bin` ç›®å½•ä¸‹ï¼Œè¯¥ç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶éƒ½ä¼šç¼–è¯‘æˆç‹¬ç«‹çš„äºŒè¿›åˆ¶é¡¹

## 7.2 Defining Modules to Control Scope and Privacy
**Modules Cheat Sheet**
- ä»crateæ ¹èŠ‚ç‚¹å¼€å§‹
	å½“ç¼–è¯‘ä¸€ä¸ªcrateæ—¶ï¼Œç¼–è¯‘å™¨é¦–å…ˆåœ¨crateæ ¹æ–‡ä»¶(é€šå¸¸å¯¹ä¸€ä¸ªåº“crateè€Œè¨€æ˜¯ `src/lib.rs` ï¼Œå¯¹ä¸€ä¸ªäºŒè¿›åˆ¶crateè€Œè¨€æ˜¯ `src/main.rs`)ä¸­å¯»æ‰¾éœ€è¦è¢«ç¼–è¯‘çš„ä»£ç 
- å£°æ˜æ¨¡å—
	åœ¨crateæ ¹æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å£°æ˜æ–°çš„æ¨¡å—ï¼Œæ¯”å¦‚æˆ‘ä»¬ç”¨ `mod garden` å£°æ˜äº†ä¸€ä¸ªå« `garden` çš„æ¨¡å—ï¼Œç¼–è¯‘å™¨ä¼šåœ¨ä¸‹åˆ—è·¯å¾„å¯»æ‰¾æ¨¡å—ä»£ç ï¼š
	- å†…è”ï¼šå¦‚æœ `mod garden` åæ˜¯å¤§æ‹¬å·è€Œä¸æ˜¯åˆ†å·ï¼Œåœ¨å¤§æ‹¬å·ä¸­å¯»æ‰¾
	- æ–‡ä»¶ `src/garden.rs` 
	- æ–‡ä»¶ `src/garden/mod.rs`
- å£°æ˜å­æ¨¡å—
	åœ¨é™¤äº†crateæ ¹æ–‡ä»¶ä»¥å¤–çš„å…¶ä»–æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å­æ¨¡å—ï¼Œæ¯”å¦‚æˆ‘ä»¬å¯ä»¥åœ¨ `src/garden.rs` ä¸­å®šä¹‰ `mod vegetables` ï¼Œç¼–è¯‘å™¨ä¼šåœ¨ä»¥çˆ¶æ¨¡å—å‘½åçš„ç›®å½•ä¸­å¯»æ‰¾å­æ¨¡å—ä»£ç ï¼š
	-  å†…è”ï¼šå¦‚æœ `mod vegetables` åæ˜¯å¤§æ‹¬å·è€Œä¸æ˜¯åˆ†å·ï¼Œåœ¨å¤§æ‹¬å·ä¸­å¯»æ‰¾
	- æ–‡ä»¶ `src/garden/vegetables.rs`
	- æ–‡ä»¶ `src/garden/vegetables/mod.rs`
- æ¨¡å—ä¸­çš„ä»£ç è·¯å¾„
	ä¸€æ—¦ä¸€ä¸ªæ¨¡å—æ˜¯æˆ‘ä»¬crateçš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨éšç§è§„åˆ™å…è®¸çš„å‰æä¸‹ï¼Œä»åŒä¸€ä¸ªcrateå†…çš„ä»»æ„åœ°æ–¹ï¼Œé€šè¿‡ä»£ç è·¯å¾„å¼•ç”¨è¯¥æ¨¡å—çš„ä»£ç 
	æ¯”å¦‚ä¸€ä¸ªgarden vegetablesæ¨¡å—ä¸‹çš„ `Asparagus` ç±»å‹å¯ä»¥é€šè¿‡ `crate::garden::vegetables::Asparagus` è¢«æ‰¾åˆ°
- ç§æœ‰vså…¬æœ‰
	ä¸€ä¸ªæ¨¡å—é‡Œçš„ä»£ç é»˜è®¤å¯¹å…¶çˆ¶æ¨¡å—ç§æœ‰ï¼Œåœ¨å£°æ˜æ—¶ç”¨ `pub mod` ä»¥ä½¿å¾—æ¨¡å—å…¬æœ‰ï¼Œè‹¥è¦ä½¿ä¸€ä¸ªå…¬æœ‰æ¨¡å—é‡Œçš„æˆå‘˜å…¬æœ‰ï¼Œéœ€è¦åœ¨å®ƒä»¬çš„å£°æ˜å‰åŠ ä¸Š `pub` å…³é”®å­—
- `use` å…³é”®å­—
	åœ¨ä¸€ä¸ªä½œç”¨åŸŸå†…ï¼Œ`use` å…³é”®å­—åˆ›å»ºäº†ä¸€ä¸ªæˆå‘˜çš„å¿«æ·æ–¹å¼ï¼Œç”¨äºå‡å°‘é•¿è·¯å¾„çš„é‡å¤
	å¦‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªä½œç”¨åŸŸå†…é€šè¿‡
	`use crate::garden::vegetables::Asparagus` åˆ›å»ºä¸€ä¸ªå¿«æ·æ–¹å¼ï¼Œç„¶ååœ¨è¯¥ä½œç”¨åŸŸå†…é€šè¿‡ `Asparagus` æ¥ä½¿ç”¨è¯¥ç±»å‹

**Grouping Related Code in Modules**
æ¨¡å—è®©æˆ‘ä»¬å¯ä»¥å¯¹ä¸€ä¸ªcrateä¸­çš„ä»£ç è¿›è¡Œåˆ†ç»„ï¼Œä»¥æé«˜å¯è¯»æ€§å’Œé‡ç”¨æ€§ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨æ¨¡å—æ¥æ§åˆ¶é¡¹çš„ç§æœ‰æ€§ï¼Œä¸€ä¸ªæ¨¡å—ä¸­çš„ä»£ç é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œç§æœ‰é¡¹æ˜¯ä¸å¯ä¸ºå¤–éƒ¨ä½¿ç”¨çš„å†…åœ¨è¯¦ç»†å®ç°ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†æ¨¡å—å’Œå…¶ä¸­çš„é¡¹æ ‡è®°ä¸ºå…¬å¼€çš„ï¼Œä»¥å…è®¸å¤–éƒ¨ä»£ç ä½¿ç”¨å’Œä¾èµ–å®ƒä»¬

åˆ›å»ºä¸€ä¸ª `restaurant` åº“ï¼Œå®šä¹‰ä¸€äº›æ¨¡å—å’Œå‡½æ•°ï¼š
`cargo new --lib restaurant`

å®šä¹‰ä¸€ä¸ªåŒ…å«äº†å…¶ä»–å†…ç½®äº†å‡½æ•°çš„æ¨¡å—çš„æ¨¡å— `front_of_house` ï¼š
```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```
æˆ‘ä»¬é€šè¿‡ `mod` å…³é”®å­—å®šä¹‰ä¸€ä¸ªæ¨¡å—ï¼Œæ¨¡å—çš„ä¸»ä½“åœ¨èŠ±æ‹¬å·å†…ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ¨¡å—å†…å®šä¹‰å…¶ä»–æ¨¡å—ï¼Œæ¨¡å—å†…è¿˜å¯ä»¥ä¿å­˜ä¸€äº›å¯¹å…¶ä»–é¡¹çš„å®šä¹‰ï¼Œå¦‚ç»“æ„ä½“ï¼Œæšä¸¾ç±»å‹ï¼Œå¸¸é‡ï¼Œç‰¹æ€§(trait)ï¼Œå‡½æ•°

æˆ‘ä»¬é€šè¿‡ä½¿ç”¨æ¨¡å—å°†ç›¸å…³çš„å®šä¹‰åˆ†ç»„åˆ°ä¸€èµ·ï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥åŸºäºåˆ†ç»„å¯¹ä»£ç è¿›è¡Œå¯¼èˆªå’Œä½¿ç”¨ï¼Œä¿æŒç¨‹åºçš„ç»„ç»‡æ€§

`src/lib.rs` å’Œ `src/main.rs` ç§°ä¸ºcrateæ ¹ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªæ–‡ä»¶çš„å†…å®¹éƒ½åˆ†åˆ«åœ¨crateæ¨¡å—ç»“æ„(æ¨¡å—æ ‘)çš„æ ¹éƒ¨å½¢æˆäº†ä¸€ä¸ªåä¸ºcrateçš„æ¨¡å—ï¼Œä»¥åŠå…¶ä»–çš„å­æ¨¡å—ï¼ŒæŒ‰æ ‘å½¢ç»„ç»‡ï¼Œå¦‚ï¼š
```cmd
crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
```
æ¨¡å—æ ‘å±•ç¤ºäº†æ¨¡å—çš„çˆ¶å­/åµŒå¥—ç»“æ„å’Œå…„å¼Ÿç»“æ„ï¼Œæ³¨æ„æ ¹æ˜¯åä¸º `crate` çš„éšå¼æ¨¡å—

## 7.3 Paths for Referring to an Item in the Module Tree
Rustä½¿ç”¨è·¯å¾„åœ¨æ¨¡å—æ ‘ä¸­å®šä½ä¸€ä¸ªé¡¹ï¼Œè·¯å¾„æœ‰ä¸¤ç§å½¢å¼ï¼š
- ç»å¯¹è·¯å¾„
	ä»¥crateæ ¹(root)å¼€å¤´çš„å…¨è·¯å¾„ï¼Œè‹¥æ˜¯ç”¨äºè®¿é—®å¤–éƒ¨crateçš„ä»£ç çš„ç»å¯¹è·¯å¾„ï¼Œåˆ™ä»¥å…¶crateåå¼€å¤´ï¼Œè‹¥æ˜¯ç”¨äºè®¿é—®å½“å‰crateçš„ä»£ç çš„ç»å¯¹è·¯å¾„ï¼Œåˆ™ä»¥å­—é¢å€¼Â `crate`Â å¼€å¤´
- ç›¸å¯¹è·¯å¾„
	ä»¥Â `self`ã€`super`Â æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦å¼€å¤´ï¼Œè·¯å¾„ä»å½“å‰æ¨¡å—å¼€å§‹
è·¯å¾„ä¸­çš„æ ‡è¯†ç¬¦ç”±åŒå†’å· `::` åˆ†å‰²

åœ¨crateæ ¹å®šä¹‰ä¸€ä¸ªæ–°å‡½æ•°Â `eat_at_restaurant`ï¼Œ`eat_at_restaurant`Â å‡½æ•°æ˜¯æˆ‘ä»¬crateåº“çš„ä¸€ä¸ªå…¬å…±APIï¼Œæ‰€ä»¥ä½¿ç”¨Â `pub`Â å…³é”®å­—æ¥æ ‡è®°å®ƒï¼Œæˆ‘ä»¬éœ€è¦åœ¨å…¶ä¸­è°ƒç”¨Â `add_to_waitlist`Â å‡½æ•°ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼š
```rust
mod front_of_house {
	mod hosting {
		fn add_to_waitlist() {}
	}
}

pub fn eat_at_restaurant() {
	// ç»å¯¹è·¯å¾„
	crate::front_of_house::hosting::add_to_waitlist();
	// ç›¸å¯¹è·¯å¾„
	front_of_house::hosting::add_to_waitlist();
}
```
ç¬¬ä¸€ç§æ–¹å¼æ˜¯ç»å¯¹è·¯å¾„ï¼Œå› ä¸º `add_to_waitlist`Â å‡½æ•°ä¸Â `eat_at_restaurant`Â è¢«å®šä¹‰åœ¨åŒä¸€crateä¸­ï¼Œå¯ä»¥ä½¿ç”¨Â `crate`Â å…³é”®å­—ä¸ºèµ·å§‹çš„ç»å¯¹è·¯å¾„
ç¬¬äºŒç§æ–¹å¼æ˜¯ç›¸å¯¹è·¯å¾„ï¼Œè¿™ä¸ªè·¯å¾„ä»¥Â `front_of_house`Â ä¸ºèµ·å§‹ï¼Œå› ä¸ºè¿™ä¸ªæ¨¡å—åœ¨æ¨¡å—æ ‘ä¸­ï¼Œä¸Â `eat_at_restaurant`Â å®šä¹‰åœ¨åŒä¸€å±‚çº§ï¼Œä»¥æ¨¡å—åå¼€å¤´æ„å‘³ç€è¯¥è·¯å¾„æ˜¯ç›¸å¯¹è·¯å¾„

ä¸€èˆ¬å€¾å‘äºä½¿ç”¨ç»å¯¹è·¯å¾„

è¿™æ®µä»£ç ä¼šäº§ç”Ÿä¸€ä¸ªç¼–è¯‘é”™è¯¯ï¼Œé”™è¯¯ä¿¡æ¯å‘Šè¯‰æˆ‘ä»¬Â `hosting`Â æ¨¡å—æ˜¯ç§æœ‰çš„ï¼Œåœ¨ Rustä¸­ï¼Œé»˜è®¤æ‰€æœ‰é¡¹(å‡½æ•°ã€æ–¹æ³•ã€ç»“æ„ä½“ã€æšä¸¾ã€æ¨¡å—å’Œå¸¸é‡)å¯¹çˆ¶æ¨¡å—éƒ½æ˜¯ç§æœ‰çš„ï¼Œä¸å…è®¸é€šè¿‡ `front_of_house` è®¿é—®

Rustä¸­ï¼Œçˆ¶æ¨¡å—ä¸­çš„é¡¹ä¸èƒ½ä½¿ç”¨å­æ¨¡å—ä¸­çš„ç§æœ‰é¡¹ï¼Œä½†æ˜¯å­æ¨¡å—ä¸­çš„é¡¹å¯ä»¥ä½¿ç”¨å®ƒä»¬çˆ¶æ¨¡å—ä¸­çš„é¡¹ï¼Œè¿™æ˜¯å› ä¸ºå­æ¨¡å—çš„åŠŸèƒ½æ˜¯å°è£…å¹¶éšè—çˆ¶æ¨¡å—ä¸­æŸä¸ªé¡¹çš„å®ç°è¯¦æƒ…ï¼Œå› æ­¤å­æ¨¡å—éœ€è¦çœ‹åˆ°è¿™ä¸ªé¡¹å®šä¹‰çš„ä¸Šä¸‹æ–‡

Rusté€‰æ‹©ä»¥é»˜è®¤éšè—å†…éƒ¨å®ç°ç»†èŠ‚çš„æ–¹å¼æ¥å®ç°æ¨¡å—ç³»ç»ŸåŠŸèƒ½ï¼Œæ–¹ä¾¿æ›´æ”¹å†…éƒ¨ä»£ç è€Œä¸ä¼šç ´åå¤–éƒ¨ä»£ç ï¼Œä½†Rustä¹Ÿæä¾›äº†é€šè¿‡ä½¿ç”¨Â `pub`Â å…³é”®å­—æ¥åˆ›å»ºå…¬å…±é¡¹ï¼Œä½¿å­æ¨¡å—çš„å†…éƒ¨éƒ¨åˆ†æš´éœ²ç»™ä¸Šçº§æ¨¡å—

**Exposing Paths with theÂ `pub`Â Keyword**
æˆ‘ä»¬æƒ³è®©çˆ¶æ¨¡å—ä¸­çš„Â `eat_at_restaurant`Â å‡½æ•°å¯ä»¥è®¿é—®å­æ¨¡å—ä¸­çš„Â `add_to_waitlist`Â å‡½æ•°ï¼Œéœ€è¦ä½¿ç”¨Â `pub`Â å…³é”®å­—æ¥æ ‡è®°Â `hosting`Â æ¨¡å—ï¼š
```rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // ç»å¯¹è·¯å¾„
    crate::front_of_house::hosting::add_to_waitlist();

    // ç›¸å¯¹è·¯å¾„
    front_of_house::hosting::add_to_waitlist();
}
```
æˆ‘ä»¬åœ¨Â `mod hosting`Â å‰æ·»åŠ äº†Â `pub`Â å…³é”®å­—ï¼Œä½¿å…¶å˜æˆå…¬æœ‰çš„ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡Â `front_of_house` è®¿é—®Â `hosting` ï¼Œå³å¦‚æœæˆ‘ä»¬å¯ä»¥è®¿é—®Â `front_of_house`ï¼Œé‚£æˆ‘ä»¬ä¹Ÿå¯ä»¥è®¿é—®Â `hosting`
ä½†ç¼–è¯‘ä»ä¼šæ˜¾ç¤ºæŠ¥é”™ï¼Œå› ä¸ºRustä¸­ï¼Œé»˜è®¤æ‰€æœ‰é¡¹(å‡½æ•°ã€æ–¹æ³•ã€ç»“æ„ä½“ã€æšä¸¾ã€æ¨¡å—å’Œå¸¸é‡)å¯¹çˆ¶æ¨¡å—éƒ½æ˜¯ç§æœ‰çš„ï¼Œå³ `hosting` ä¸­çš„é¡¹å¯¹å®ƒæ˜¯ç§æœ‰çš„ï¼Œä½¿æ¨¡å—å…¬æœ‰å¹¶ä¸ä½¿å…¶å†…å®¹ä¹Ÿæ˜¯å…¬æœ‰çš„(ç§æœ‰æ€§è§„åˆ™ä¸ä½†åº”ç”¨äºæ¨¡å—ï¼Œè¿˜åº”ç”¨äºç»“æ„ä½“ã€æšä¸¾ã€å‡½æ•°å’Œæ–¹æ³•)

å› æ­¤ï¼Œæ¨¡å—ä¸Šçš„Â `pub`Â å…³é”®å­—åªå…è®¸å…¶çˆ¶æ¨¡å—å¼•ç”¨å®ƒï¼Œè€Œä¸å…è®¸è®¿é—®å†…éƒ¨ä»£ç 
æ¨¡å—ä»…æ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œå› æ­¤æˆ‘ä»¬åœ¨å°†æ¨¡å—å˜ä¸ºå…¬æœ‰çš„åŒæ—¶ï¼Œéœ€è¦æ›´æ·±å…¥åœ°é€‰æ‹©å°†æ¨¡å—ä¸­çš„ä¸€ä¸ªæˆ–å¤šä¸ªé¡¹å˜ä¸ºå…¬æœ‰

å°†Â `pub`Â å…³é”®å­—æ”¾ç½®åœ¨Â `add_to_waitlist`Â å‡½æ•°çš„å®šä¹‰ä¹‹å‰ï¼Œä½¿å…¶å˜æˆå…¬æœ‰ï¼š
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // ç»å¯¹è·¯å¾„
    crate::front_of_house::hosting::add_to_waitlist();

    // ç›¸å¯¹è·¯å¾„
    front_of_house::hosting::add_to_waitlist();
}
```
ç°åœ¨ä»£ç å¯ä»¥ç¼–è¯‘é€šè¿‡äº†

åœ¨ç»å¯¹è·¯å¾„ä¸­ï¼Œæˆ‘ä»¬ä»Â `crate`Â ä¹Ÿå°±æ˜¯crateæ ¹å¼€å§‹ï¼Œcrate æ ¹ä¸­å®šä¹‰äº†Â `front_of_house`Â æ¨¡å—ï¼Œè™½ç„¶Â `front_of_house`Â æ¨¡å—å¯¹å…¶çˆ¶æ¨¡å—æ˜¯ç§æœ‰çš„ï¼Œä¸è¿‡å› ä¸ºÂ `eat_at_restaurant`Â å‡½æ•°ä¸Â `front_of_house`Â å®šä¹‰äºåŒä¸€æ¨¡å—ä¸­(å³`eat_at_restaurant`Â å’ŒÂ `front_of_house`Â æ˜¯å…„å¼Ÿ)ï¼Œæˆ‘ä»¬å¯ä»¥ä»Â `eat_at_restaurant`Â ä¸­å¼•ç”¨Â `front_of_house`ï¼Œå› ä¸º`hosting`Â æ¨¡å—ä½¿ç”¨äº†Â `pub`Â æ ‡è®°ï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®Â `hosting`Â çš„çˆ¶æ¨¡å—ï¼Œæ‰€ä»¥å¯ä»¥è®¿é—®Â `hosting`ï¼Œæœ€åç”±äº`add_to_waitlist`Â å‡½æ•°è¢«æ ‡è®°ä¸ºÂ `pub`Â ï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®å…¶çˆ¶æ¨¡å—ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°è°ƒç”¨æ˜¯æœ‰æ•ˆçš„

åœ¨ç›¸å¯¹è·¯å¾„ï¼Œå…¶é€»è¾‘ä¸ç»å¯¹è·¯å¾„ç›¸åŒï¼Œé™¤äº†ç¬¬ä¸€æ­¥ï¼Œä¸åŒäºä» crate æ ¹å¼€å§‹ï¼Œè·¯å¾„ä»Â `front_of_house`Â å¼€å§‹ï¼Œå› ä¸º `front_of_house`Â æ¨¡å—ä¸Â `eat_at_restaurant`Â å®šä¹‰äºåŒä¸€æ¨¡å—ï¼Œæ‰€ä»¥ä»Â `eat_at_restaurant`Â ä¸­å¼€å§‹å®šä¹‰çš„è¯¥æ¨¡å—ç›¸å¯¹è·¯å¾„æ˜¯æœ‰æ•ˆçš„ï¼Œæ¥ä¸‹æ¥å› ä¸ºÂ `hosting`Â å’ŒÂ `add_to_waitlist`Â è¢«æ ‡è®°ä¸ºÂ `pub`ï¼Œè·¯å¾„å…¶ä½™çš„éƒ¨åˆ†ä¹Ÿæ˜¯æœ‰æ•ˆçš„ï¼Œå› æ­¤å‡½æ•°è°ƒç”¨ä¹Ÿæ˜¯æœ‰æ•ˆçš„

**Best Practices for Packages with a Binary and a Library**
æˆ‘ä»¬çŸ¥é“åŒ…å¯ä»¥åŒæ—¶åŒ…å«ä¸€ä¸ªÂ _src/main.rs_Â äºŒè¿›åˆ¶crateæ ¹å’Œä¸€ä¸ªÂ _src/lib.rs_Â åº“crateæ ¹ï¼Œä¸”è¿™ä¸¤ä¸ªcrateé»˜è®¤ä»¥åŒ…åæ¥å‘½å

é€šå¸¸ï¼Œè¿™ç±»åŒæ—¶åŒ…å«äºŒè¿›åˆ¶crateå’Œåº“crateçš„åŒ…ï¼Œåœ¨äºŒè¿›åˆ¶crateä¸­ä¼šåŒ…å«åˆšå¥½è¶³å¤Ÿçš„ä»£ç æ¥å¯åŠ¨ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¯æ‰§è¡Œæ–‡ä»¶è°ƒç”¨åº“crateçš„ä»£ç (ä½œä¸ºç¤ºä¾‹)

è¿™ç±»çš„åŒ…çš„æ¨¡å—æ ‘ä¸€èˆ¬å®šä¹‰åœ¨Â _src/lib.rs_Â ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä»¥åŒ…åå¼€å¤´çš„è·¯å¾„åœ¨äºŒè¿›åˆ¶crateä¸­ä½¿ç”¨å…¬æœ‰é¡¹
äº‹å®ä¸Šï¼ŒåŒ…ä¸­çš„äºŒè¿›åˆ¶crateåŒå…¶å®ƒå¤–éƒ¨crateä¸€æ ·ï¼Œæ˜¯åº“crateçš„ç”¨æˆ·ï¼Œåªèƒ½ä½¿ç”¨å…¬æœ‰API

**Starting Relative Paths with super**
å¦‚æœæˆ‘ä»¬æƒ³è¦ä»çˆ¶æ¨¡å—å¼€å§‹æ„å»ºç›¸å¯¹è·¯å¾„ï¼Œè€Œä¸æ˜¯ä»å½“å‰æ¨¡å—å¼€å§‹ï¼Œå¯ä»¥é€šè¿‡åœ¨ç›¸å¯¹è·¯å¾„çš„å¼€å¤´ä½¿ç”¨Â `super`Â ï¼Œç±»ä¼¼ä»¥Â `..`Â è¯­æ³•å¼€å§‹ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿè·¯å¾„

`back_of_house`Â æ¨¡å—ä¸­çš„å®šä¹‰çš„Â `fix_incorrect_order`Â å‡½æ•°é€šè¿‡æŒ‡å®šçš„Â `super`Â èµ·å§‹çš„Â `serve_order`Â è·¯å¾„ï¼Œæ¥è°ƒç”¨çˆ¶æ¨¡å—ä¸­çš„Â `deliver_order`Â å‡½æ•°ï¼š
```rust
fn deliver_order() {}

mod back_of_house {
	fn fix_incorrect_order() {
		cook_order();
		super::deliver_order();
	}
	fn cook_order() {}
}
```
`fix_incorrect_order`Â å‡½æ•°åœ¨Â `back_of_house`Â æ¨¡å—ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨Â `super`Â è¿›å…¥äº†Â `back_of_house`Â çš„çˆ¶æ¨¡å—ï¼Œå³æœ¬ä¾‹ä¸­çš„Â `crate`Â æ ¹ï¼Œä»¥æ‰¾åˆ°å®šä¹‰äºå…¶ä¸­çš„Â `deliver_order` 

**Making Structs and Enums Public**
`pub`Â åŒæ ·å¯ä»¥ç”¨äºåˆ›å»ºå…¬æœ‰çš„ç»“æ„ä½“å’Œæšä¸¾ç±»å‹ï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä¸€ä¸ªç»“æ„ä½“å®šä¹‰çš„å‰é¢ä½¿ç”¨äº†Â `pub`Â ï¼Œè¿™ä¸ªç»“æ„ä½“ä¼šå˜æˆå…¬æœ‰çš„ï¼Œä½†æ˜¯è¿™ä¸ªç»“æ„ä½“çš„å­—æ®µä»ç„¶æ˜¯ç§æœ‰çš„ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®æƒ…å†µå†³å®šæ¯ä¸ªå­—æ®µæ˜¯å¦å…¬æœ‰

å®šä¹‰äº†ä¸€ä¸ªå…¬æœ‰ç»“æ„ä½“Â `back_of_house:Breakfast`ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªå…¬æœ‰å­—æ®µÂ `toast`Â å’Œç§æœ‰å­—æ®µÂ `seasonal_fruit` ï¼š
```rust
mod back_of_house {
	pub struct Breakfast {
		pub toast: String,
		seasonal_fruit: String,
	}
	impl Breakfase {
		pub in summer(toast: &str) -> Breakfast {
			Breakfast {
				toast: String::from(toast),
				seasonal_fruit: String::from("peaches"),
			}
		}
	}
}

pub fn ead_at_restaurant() {
	// åœ¨å¤å¤©è®¢è´­ä¸€ä¸ªé»‘éº¦åœŸå¸ä½œä¸ºæ—©é¤
	let mut meal = back_of_house::Breakfast::summer("Rye");
	// æ”¹å˜ä¸»æ„æ›´æ¢æƒ³è¦é¢åŒ…çš„ç±»å‹
	meal.toast = String::from("Wheat");
	println!("I'd like {} toast please", meal.toast);

	// å¦‚æœå–æ¶ˆä¸‹ä¸€è¡Œçš„æ³¨é‡Šä»£ç ä¸èƒ½ç¼–è¯‘ï¼› 
	// ä¸å…è®¸æŸ¥çœ‹æˆ–ä¿®æ”¹æ—©é¤é™„å¸¦çš„å­£èŠ‚æ°´æœ 
	// meal.seasonal_fruit = String::from("blueberries");
}
```
å› ä¸ºÂ `back_of_house::Breakfast`Â ç»“æ„ä½“çš„Â `toast`Â å­—æ®µæ˜¯å…¬æœ‰çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨Â `eat_at_restaurant`Â ä¸­ä½¿ç”¨ç‚¹å·æ¥éšæ„çš„è¯»å†™Â `toast`Â å­—æ®µï¼Œä½†å› ä¸º`seasonal_fruit`Â æ˜¯ç§æœ‰çš„ï¼Œæˆ‘ä»¬ä¸èƒ½åœ¨Â `eat_at_restaurant`Â ä¸­ä½¿ç”¨Â `seasonal_fruit`Â å­—æ®µ

å¦å¤–è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸ºÂ `back_of_house::Breakfast`Â å…·æœ‰ç§æœ‰å­—æ®µï¼Œæ‰€ä»¥è¿™ä¸ªç»“æ„ä½“éœ€è¦æä¾›ä¸€ä¸ªå…¬å…±çš„å…³è”å‡½æ•°æ¥æ„é€ Â `Breakfast`Â çš„å®ä¾‹(åœ¨æœ¬ä¾‹ä¸­æ˜¯Â `summer`)
å¦‚æœÂ `Breakfast`Â æ²¡æœ‰è¿™æ ·çš„å‡½æ•°ï¼Œæˆ‘ä»¬å°†æ— æ³•åœ¨Â `eat_at_restaurant`Â ä¸­åˆ›å»ºÂ `Breakfast`Â å®ä¾‹ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½åœ¨Â `eat_at_restaurant`Â ä¸­è®¾ç½®ç§æœ‰å­—æ®µÂ `seasonal_fruit`Â çš„å€¼

è€Œå¯¹äºæšä¸¾ç±»å‹æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬åœ¨Â `enum`Â å…³é”®å­—å‰é¢åŠ ä¸ŠÂ `pub`å°†å…¶è®¾ä¸ºå…¬æœ‰ï¼Œåˆ™å®ƒçš„æ‰€æœ‰æˆå‘˜éƒ½å°†å˜ä¸ºå…¬æœ‰ï¼Œå¦‚ï¼š
```rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

å› ä¸ºæšä¸¾ç±»å‹çš„ä½¿ç”¨å¤§å¤šæ•°æ˜¯ä½¿ç”¨å®ƒçš„æˆå‘˜ï¼Œå› æ­¤æšä¸¾æˆå‘˜é»˜è®¤å°±æ˜¯å…¬æœ‰çš„
ç»“æ„ä½“é€šå¸¸ä½¿ç”¨æ—¶ä¸ä¸€å®šæ¶‰åŠåˆ°å­—æ®µå†…éƒ¨ï¼Œå› æ­¤ç»“æ„ä½“çš„å­—æ®µé»˜è®¤éƒ½æ˜¯ç§æœ‰çš„

## 7.4 Bring Paths into Scope with the use Keyword
åœ¨ä¸€ä¸ªä½œç”¨åŸŸå†…ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Â `use`Â å…³é”®å­—åˆ›å»ºä¸€ä¸ªçŸ­è·¯å¾„ï¼Œç„¶åå°±å¯ä»¥åœ¨ä½œç”¨åŸŸä¸­çš„ä»»ä½•åœ°æ–¹ä½¿ç”¨è¿™ä¸ªæ›´çŸ­çš„åå­—

ç”¨ `use crate::front_of_house::hosting` å°†Â `crate::front_of_house::hosting`Â æ¨¡å—å¼•å…¥
`eat_at_restaurant`Â å‡½æ•°çš„æ‰€å¤„çš„ä½œç”¨åŸŸï¼š
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```
ä¹‹ååªéœ€è¦æŒ‡å®šÂ `hosting::add_to_waitlist`Â å³å¯åœ¨Â `eat_at_restaurant`Â ä¸­è°ƒç”¨Â `add_to_waitlist`Â å‡½æ•°

åœ¨ä½œç”¨åŸŸä¸­ä½¿ç”¨Â `use` å°†è·¯å¾„å¼•å…¥ä½œç”¨åŸŸç±»ä¼¼äºåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºè½¯è¿æ¥(ç¬¦å·è¿æ¥/symbolic link)

æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡åœ¨ crate æ ¹å¢åŠ Â `use crate::front_of_house::hosting`ï¼Œä½¿å¾—Â `hosting`åœ¨ä½œç”¨åŸŸä¸­æˆä¸ºæœ‰æ•ˆçš„åç§°ï¼Œå¦‚åŒÂ `hosting`Â æ¨¡å—è¢«å®šä¹‰äº crate æ ¹ä¸€æ ·

é€šè¿‡Â `use`Â å°†è·¯å¾„å¼•å…¥ä½œç”¨åŸŸæ—¶ä¹Ÿä¼šæ£€æŸ¥ç§æœ‰æ€§

æ³¨æ„ `use` åˆ›å»ºçš„åç§°åªæœ‰åœ¨ `use` å…³é”®å­—æ‰€åœ¨çš„ä½œç”¨åŸŸå†…æ‰æœ‰æ•ˆ/`use`Â è¯­å¥åªé€‚ç”¨äºå…¶æ‰€åœ¨çš„ä½œç”¨åŸŸï¼š
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
```
å°†Â `eat_at_restaurant`Â å‡½æ•°ç§»åŠ¨åˆ°Â `customer`Â å­æ¨¡å—ï¼Œè¿™æ—¶ `eat_at_restaurant`Â å‡½æ•°æ‰€å¤„çš„ä½œç”¨åŸŸæ˜¯å’ŒÂ `use`Â è¯­å¥æ‰€å¤„çš„ä½œç”¨åŸŸä¸åŒçš„ï¼Œå› æ­¤ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯

ä½†æ˜¯åœ¨å­æ¨¡å—Â `customer`Â å†…é€šè¿‡Â `super::hosting`Â å¼•ç”¨çˆ¶æ¨¡å—ä¸­çš„è¿™ä¸ªçŸ­è·¯å¾„åˆ™å¯ä»¥ï¼Œè¯´æ˜ `use` è¯­å¥å¼•å…¥çš„çŸ­è·¯å¾„æ˜¯åªè¯»å¤„äºåŒä¸€ä½œç”¨åŸŸçš„å…„å¼Ÿå¯è§çš„ï¼Œå› æ­¤å­æ¨¡å—å¯ä»¥é€šè¿‡çˆ¶æ¨¡å—è¿›è¡Œè®¿é—®

**Creating IdiomaticÂ `use`Â Paths**
æŒ‡å®šÂ `use crate::front_of_house::hosting`Â ï¼Œç„¶ååœ¨Â `eat_at_restaurant`ä¸­è°ƒç”¨Â `hosting::add_to_waitlist`Â æ˜¯æƒ¯ç”¨çš„åšæ³•

ä½†æ˜¯ç›´æ¥å°†Â `add_to_waitlist`Â å¼•å…¥ä½œç”¨åŸŸä¹Ÿæ˜¯å¯è¡Œçš„ï¼š
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
```

ä½†æ˜¯ä¸æ¨èè¿™ä¸ªåšæ³•ï¼Œä½¿ç”¨Â `use`Â å°†å‡½æ•°å¼•å…¥ä½œç”¨åŸŸçš„ä¹ æƒ¯ç”¨æ³•ä¸€èˆ¬æ˜¯å…ˆä½¿ç”¨Â `use`Â å°†å‡½æ•°çš„çˆ¶æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼Œç„¶ååœ¨è°ƒç”¨å‡½æ•°æ—¶æŒ‡å®šçˆ¶æ¨¡å—ï¼Œå› ä¸ºè¿™æ ·å¯ä»¥æ¸…æ™°åœ°è¡¨æ˜å‡½æ•°ä¸æ˜¯åœ¨æœ¬åœ°å®šä¹‰çš„

è€Œä½¿ç”¨Â `use`Â å¼•å…¥ç»“æ„ä½“ã€æšä¸¾å’Œå…¶ä»–é¡¹æ—¶ï¼Œä¹ æƒ¯æ˜¯æŒ‡å®šå®ƒä»¬çš„å®Œæ•´è·¯å¾„ï¼Œç›´æ¥å°†å®ƒä»¬å¼•å…¥ä½œç”¨åŸŸï¼Œå¦‚å°†Â `HashMap`Â ç»“æ„ä½“å¼•å…¥äºŒè¿›åˆ¶ crate ä½œç”¨åŸŸï¼š
```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

ä½†ç”±äºçˆ¶æ¨¡å—åç§°ä¸åŒä½†è‡ªèº«åç§°ç›¸åŒçš„é¡¹å¯èƒ½äº§ç”Ÿå†²çªï¼Œæ‰€ä»¥åº”è¯¥çµæ´»ä½¿ç”¨ï¼Œå¦‚å°†ä¸¤ä¸ªå…·æœ‰ç›¸åŒåç§°ä½†ä¸åŒçˆ¶æ¨¡å—çš„Â `Result`Â ç±»å‹å¼•å…¥ä½œç”¨åŸŸï¼Œå¹¶å¼•ç”¨å®ƒä»¬ï¼š
```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
    Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
    Ok(())
}
```
æˆ‘ä»¬é€šè¿‡ä½¿ç”¨çˆ¶æ¨¡å—ä»¥åŒºåˆ†è¿™ä¸¤ä¸ªÂ `Result`Â ç±»å‹

**Providing New Names with theÂ `as`Â Keyword**
ä½¿ç”¨Â `use`Â å°†ä¸¤ä¸ªåŒåç±»å‹å¼•å…¥åŒä¸€ä½œç”¨åŸŸè¿™ä¸ªé—®é¢˜è¿˜æœ‰å¦ä¸€ä¸ªè§£å†³åŠæ³•ï¼šåœ¨è¿™ä¸ªç±»å‹çš„è·¯å¾„åé¢ï¼Œæˆ‘ä»¬ä½¿ç”¨Â `as`Â æŒ‡å®šä¸€ä¸ªæ–°çš„æœ¬åœ°åç§°æˆ–è€…åˆ«åï¼š
```rust
use std::io::Result as IoResult;
use std::fmt::Result;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
```

**Re-exporting Names withÂ `pub use`**
å½“æˆ‘ä»¬ç”¨ `use` å°†ä¸€ä¸ªåç§°å¸¦å…¥ä½œç”¨åŸŸæ—¶ï¼Œè¿™ä¸ªæ–°çš„åå­—é»˜è®¤ä¼šè¢«è®¤ä¸ºæ˜¯è¿™ä¸ªä½œç”¨åŸŸå†…çš„ä¸€ä¸ªç§æœ‰çš„åå­—ï¼Œå› æ­¤è™½ç„¶å¯ä»¥è¢«åŒä½œç”¨åŸŸå†…çš„é¡¹ä½¿ç”¨ï¼Œä½†æ˜¯å¯¹äºä½œç”¨åŸŸå¤–æ˜¯ä¸å¯è§çš„
ä½¿ç”¨ `pub use` å¯ä»¥ä½¿è¿™ä¸ªåå­—æˆä¸ºå…¬æœ‰çš„åå­—ï¼Œè¿™ç§æŠ€æœ¯è¢«ç§°ä¸º â€œ_é‡å¯¼å‡º_(_re-exporting_)â€ï¼Œæˆ‘ä»¬ä¸ä»…å°†ä¸€ä¸ªåç§°å¯¼å…¥äº†å½“å‰ä½œç”¨åŸŸï¼Œè¿˜å…è®¸åˆ«äººæŠŠå®ƒå¯¼å…¥ä»–ä»¬è‡ªå·±çš„ä½œç”¨åŸŸï¼š
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

åœ¨è¿™ä¸ªä¿®æ”¹ä¹‹å‰ï¼Œå¤–éƒ¨ä»£ç éœ€è¦ä½¿ç”¨è·¯å¾„Â `restaurant::front_of_house::hosting::add_to_waitlist()`Â æ¥è°ƒç”¨Â `add_to_waitlist`Â å‡½æ•°
ç°åœ¨ï¼Œå¤–éƒ¨ä»£ç ç°åœ¨å¯ä»¥ä½¿ç”¨è·¯å¾„Â `restaurant::hosting::add_to_waitlist` æ¥è°ƒç”¨Â `add_to_waitlist`Â å‡½æ•°ï¼Œå³ `pub use`Â ä»æ ¹æ¨¡å—é‡å¯¼å‡ºäº†Â `hosting`Â æ¨¡å—

ä½¿ç”¨Â `pub use`ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§ç»“æ„ç¼–å†™ä»£ç ï¼Œå´å°†ä¸åŒçš„ç»“æ„å½¢å¼æš´éœ²å‡ºæ¥

**Using External Packages**
åœ¨ç¬¬äºŒç« ä¸­æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªçŒœçŒœçœ‹æ¸¸æˆï¼Œé‚£ä¸ªé¡¹ç›®ä½¿ç”¨äº†ä¸€ä¸ªå¤–éƒ¨åŒ…ï¼Œ`rand`ï¼Œæ¥ç”Ÿæˆéšæœºæ•°ã€‚ä¸ºäº†åœ¨é¡¹ç›®ä¸­ä½¿ç”¨Â `rand`ï¼Œåœ¨Â _Cargo.toml_Â ä¸­åŠ å…¥äº†å¦‚ä¸‹è¡Œï¼š
`rand = "0.8.5"`
å°† `rand` ä½œä¸ºä¾èµ–é¡¹åœ¨Â _Cargo.toml_Â ä¸­åŠ å…¥å‘Šè¯‰äº† Cargo è¦ä»Â crates.io ä¸‹è½½Â `rand`Â å’Œå…¶ä¾èµ–ï¼Œä»¥ä½¿ `rand` å¯åœ¨æˆ‘ä»¬çš„é¡¹ç›®ä»£ç ä¸­ä½¿ç”¨

æ¥ç€ï¼Œæˆ‘ä»¬ä½¿ç”¨ `use::rand(åŒ…å)::é¡¹å` å°†æˆ‘ä»¬éœ€è¦çš„é¡¹å¼•å…¥ä½œç”¨åŸŸ
ç¬¬äºŒç« çš„ â€œç”Ÿæˆä¸€ä¸ªéšæœºæ•°â€ éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬æ›¾å°†Â `Rng`Â trait å¼•å…¥ä½œç”¨åŸŸå¹¶è°ƒç”¨äº†Â `rand::thread_rng`Â å‡½æ•°ï¼š
```rust
use std::io;
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
```

crates.io ä¸Šæœ‰å¾ˆå¤š Rust ç¤¾åŒºæˆå‘˜å‘å¸ƒçš„åŒ…ï¼Œå°†å…¶å¼•å…¥è‡ªå·±çš„é¡¹ç›®éƒ½éœ€è¦ç›¸åŒçš„æ­¥éª¤ï¼šåœ¨Â _Cargo.toml_Â åˆ—å‡ºæ‰€éœ€è¦çš„åŒ…å¹¶é€šè¿‡Â `use`Â å°†å…¶ä¸­å®šä¹‰çš„é¡¹å¼•å…¥é¡¹ç›®åŒ…çš„ä½œç”¨åŸŸä¸­

æ³¨æ„Â `std`Â æ ‡å‡†åº“å¯¹äºæˆ‘ä»¬çš„åŒ…æ¥è¯´ä¹Ÿæ˜¯å¤–éƒ¨ crate
å› ä¸ºæ ‡å‡†åº“éš Rust è¯­è¨€ä¸€åŒåˆ†å‘ï¼Œæ— éœ€ä¿®æ”¹Â _Cargo.toml_Â æ¥å¼•å…¥Â `std`ï¼Œä¸è¿‡ä¹Ÿéœ€è¦é€šè¿‡Â `use`Â å°†æ ‡å‡†åº“ä¸­å®šä¹‰çš„é¡¹å¼•å…¥é¡¹ç›®åŒ…çš„ä½œç”¨åŸŸä¸­æ¥å¼•ç”¨å®ƒä»¬ï¼Œæ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨çš„Â `HashMap`ï¼š`use std::collections::HashMap;`
è¿™æ˜¯ä¸€ä¸ªä»¥æ ‡å‡†åº“ crate åÂ `std`Â ä¸ºå¼€å¤´çš„çš„ç»å¯¹è·¯å¾„

**Using Nested Paths to Clean Up LargeÂ `use`Â Lists**
å½“éœ€è¦å¼•å…¥å¾ˆå¤šå®šä¹‰äºç›¸åŒåŒ…æˆ–ç›¸åŒæ¨¡å—çš„é¡¹æ—¶ï¼Œä¸ºæ¯ä¸€é¡¹å•ç‹¬åˆ—å‡ºä¸€è¡Œä¼šå ç”¨æºç å¾ˆå¤§çš„ç©ºé—´ï¼Œå¦‚ï¼š
```rust
use rand::Rng;
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
```
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åµŒå¥—è·¯å¾„å°†å®šä¹‰äºç›¸åŒåŒ…æˆ–ç›¸åŒæ¨¡å—çš„é¡¹åœ¨ä¸€è¡Œä¸­å¼•å…¥ä½œç”¨åŸŸ
è¿™ä¹ˆåšéœ€è¦æŒ‡å®šè·¯å¾„çš„ç›¸åŒéƒ¨åˆ†ï¼Œæ¥ç€æ˜¯ `::` ï¼Œæ¥ç€æ˜¯å¤§æ‹¬å·ä¸­çš„å„è‡ªä¸åŒçš„è·¯å¾„éƒ¨åˆ†ï¼š
```rust
use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--
```

å¯ä»¥åœ¨è·¯å¾„çš„ä»»ä½•å±‚çº§ä½¿ç”¨åµŒå¥—è·¯å¾„ï¼š
```rust
use std::io;
use std::io::Write;
```
ç­‰ä»·äº
```rust
use std::io::{self, Write};
```

**The Glob Operator**
å¦‚æœæˆ‘ä»¬å¸Œæœ›å°†ä¸€ä¸ªè·¯å¾„ä¸‹çš„æ‰€æœ‰å…¬æœ‰é¡¹éƒ½å¼•å…¥ä½œç”¨åŸŸï¼Œå¯ä»¥æŒ‡å®šè·¯å¾„åè·Ÿglob è¿ç®—ç¬¦ `*` ï¼š
```rust
use std::collections::*;
```
å°†Â `std::collections`Â ä¸­å®šä¹‰çš„æ‰€æœ‰å…¬æœ‰é¡¹å¼•å…¥å½“å‰ä½œç”¨åŸŸ

glob è¿ç®—ç¬¦éœ€è¦è°¨æ…ä½¿ç”¨ï¼Œå› ä¸ºå®ƒä¼šä½¿å¾—æˆ‘ä»¬éš¾ä»¥æ¨å¯¼ä½œç”¨åŸŸä¸­æœ‰ä»€ä¹ˆåç§°ä»¥åŠå®ƒä»¬æ˜¯åœ¨ä½•å¤„å®šä¹‰çš„

## 7.5 Seperating Modules into Different Files
ç›®å‰ä¸ºæ­¢çš„æ‰€æœ‰çš„ä¾‹å­éƒ½ä»…åœ¨ä¸€ä¸ªæ–‡ä»¶(crate æ ¹æ–‡ä»¶ä¸­ï¼Œå¯¹äºåº“crateï¼Œæ ¹æ–‡ä»¶æ˜¯Â _src/lib.rs_ ï¼Œå¯¹äºäºŒè¿›åˆ¶crateï¼Œæ ¹æ–‡ä»¶æ˜¯ _src/main.rs_Â )ä¸­å®šä¹‰å¤šä¸ªæ¨¡å—ï¼Œå½“æ¨¡å—å˜å¾—æ›´å¤§æ—¶ï¼Œéœ€è¦å°†å®ƒä»¬çš„å®šä¹‰ç§»åŠ¨åˆ°å•ç‹¬çš„æ–‡ä»¶ä¸­ï¼Œä»è€Œä½¿ä»£ç æ›´å®¹æ˜“é˜…è¯»

å°†Â `front_of_house`Â æ¨¡å—æå–åˆ°å…¶è‡ªå·±çš„æ–‡ä»¶ä¸­çš„æµç¨‹ï¼š
```rust
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```
åˆ é™¤Â `front_of_house`Â æ¨¡å—çš„å¤§æ‹¬å·ä¸­çš„ä»£ç ï¼Œåªç•™ä¸‹Â `mod front_of_house;`å£°æ˜
ç°åœ¨ç›´åˆ°åˆ›å»ºÂ _src/front_of_house.rs_Â æ–‡ä»¶ä¹‹å‰ï¼Œä»£ç éƒ½ä¸èƒ½ç¼–è¯‘ï¼Œåœ¨æ­¤åªå¯¹æ¨¡å—è¿›è¡Œäº†å£°æ˜ï¼Œè€Œæ²¡æœ‰å®ç°

æ¨¡å—çš„ä»£ç è¦æ”¾å…¥Â _src/front_of_house.rs_Â çš„æ–‡ä»¶ä¸­ï¼ŒRustç¼–è¯‘å™¨æ‰¾åˆ°äº† crate æ ¹ä¸­åå«Â `front_of_house`Â çš„æ¨¡å—å£°æ˜ï¼Œå°±ä¼šåœ¨ _src_ ç›®å½•ä¸‹æœå¯»å’Œæ¨¡å—ååŒåçš„æ–‡ä»¶ï¼š
```rust
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```

åœ¨æ¨¡å—æ ‘ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨ `mod` å£°æ˜ä¸€æ¬¡å°±åŠ è½½è¯¥æ¨¡å—çš„æ–‡ä»¶ï¼Œä¸€æ—¦ç¼–è¯‘å™¨çŸ¥é“äº†è¿™ä¸ªæ–‡ä»¶æ˜¯é¡¹ç›®çš„ä¸€éƒ¨åˆ†(é€šè¿‡æˆ‘ä»¬çš„å£°æ˜çŸ¥é“)ï¼Œå®ƒå°±ç¡®å®šäº†è¯¥æ¨¡å—åœ¨æ¨¡å—æ ‘ä¸­çš„å…·ä½“ä½ç½®ï¼Œå› æ­¤é¡¹ç›®ä¸­çš„å…¶ä»–æ–‡ä»¶åº”è¯¥ä½¿ç”¨è¯¥æ¨¡å—å£°æ˜ä½ç½®çš„è·¯å¾„æ¥å¼•ç”¨è¯¥æ¨¡å—ï¼Œå’Œæ¨¡å—æ–‡ä»¶çš„è·¯å¾„æ— å…³ï¼Œå› æ­¤ `mod` å¹¶ä¸ç­‰ä»·äºå…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­çš„ `include` æ“ä½œ

å°†Â `hosting`Â æ¨¡å—æå–åˆ°è‡ªå·±çš„æ–‡ä»¶ä¸­çš„æµç¨‹ï¼š
å› ä¸ºÂ `hosting`Â ä¸æ˜¯æ ¹æ¨¡å—ï¼Œè€Œæ˜¯Â `front_of_house`Â çš„å­æ¨¡å—ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°†Â `hosting`Â çš„æ–‡ä»¶æ”¾åœ¨ä¸å®ƒçˆ¶æ¨¡å—åŒåçš„ç›®å½• _src/front_of_house/_ ä¸­

æˆ‘ä»¬ä¿®æ”¹Â _src/front_of_house.rs_Â ä½¿ä¹‹ä»…åŒ…å«Â `hosting`Â æ¨¡å—çš„å£°æ˜ï¼š
`pub mod hosting;`

å°†æ¨¡å—çš„å®šä¹‰å†™åœ¨ _src/front_of_house/hosting.rs_ æ–‡ä»¶ä¸­ï¼š
`pub fn add_to_waitlist() {}`

**Alternate File Paths**
Rust ç¼–è¯‘å™¨é™¤äº†æ”¯æŒä»¥ä¸Šä»‹ç»çš„æ–‡ä»¶è·¯å¾„å¤–ï¼Œä»ç„¶æ”¯æŒä¸€ç§æ›´è€çš„æ–‡ä»¶è·¯å¾„ï¼Œæ¯”å¦‚ï¼š
å¯¹äºå£°æ˜äº crate æ ¹çš„Â `front_of_house`Â æ¨¡å—ï¼Œç¼–è¯‘å™¨ä¼šåœ¨å¦‚ä¸‹ä½ç½®æŸ¥æ‰¾æ¨¡å—ä»£ç ï¼š
- _src/front_of_house.rs_
- _src/front_of_house/mod.rs_ (è€é£æ ¼)
å¯¹äºÂ `front_of_house`Â çš„å­æ¨¡å—Â `hosting`ï¼Œç¼–è¯‘å™¨ä¼šåœ¨å¦‚ä¸‹ä½ç½®æŸ¥æ‰¾æ¨¡å—ä»£ç ï¼š
- _src/front_of_house/hosting.rs_
- _src/front_of_house/hosting/mod.rs_ (è€é£æ ¼)

å¦‚æœå¯¹åŒä¸€æ¨¡å—åŒæ—¶ä½¿ç”¨è¿™ä¸¤ç§è·¯å¾„é£æ ¼ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯
åœ¨åŒä¸€é¡¹ç›®ä¸­çš„ä¸åŒæ¨¡å—æ··ç”¨ä¸åŒçš„è·¯å¾„é£æ ¼æ˜¯å…è®¸çš„ï¼Œä½†ä¸æ¨è
ä½¿ç”¨Â _mod.rs_Â è¿™ä¸€æ–‡ä»¶åçš„é£æ ¼çš„ä¸»è¦ç¼ºç‚¹æ˜¯ä¼šå¯¼è‡´é¡¹ç›®ä¸­å‡ºç°å¾ˆå¤šÂ _mod.rs_Â æ–‡ä»¶

**Summary**
Rust æä¾›äº†å°†åŒ…åˆ†æˆå¤šä¸ª crateï¼Œå°† crate åˆ†æˆæ¨¡å—ï¼Œä»¥åŠé€šè¿‡æŒ‡å®šç»å¯¹æˆ–ç›¸å¯¹è·¯å¾„ä»ä¸€ä¸ªæ¨¡å—å¼•ç”¨å¦ä¸€ä¸ªæ¨¡å—ä¸­å®šä¹‰çš„é¡¹çš„æ–¹å¼
å¯ä»¥é€šè¿‡ä½¿ç”¨Â `use`Â è¯­å¥å°†ç›¸å…³è·¯å¾„ä¸‹çš„é¡¹å¼•å…¥ä½œç”¨åŸŸï¼Œ`use` æ”¯æŒåµŒå¥—è·¯å¾„
æ¨¡å—å®šä¹‰çš„ä»£ç é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œå¯ä»¥é€‰æ‹©å¢åŠ Â `pub`Â å…³é”®å­—ä½¿å…¶å®šä¹‰å˜ä¸ºå…¬æœ‰

# 8 Common Collections
Rustæ ‡å‡†åº“ä¸­åŒ…å«äº†è®¸å¤šé›†åˆæ•°æ®ç±»å‹ï¼Œä¸å†…å»ºçš„æ•°ç»„å’Œå…ƒç»„æ•°æ®ç±»å‹ä¸åŒçš„æ˜¯ï¼Œè¿™äº›é›†åˆæ•°æ®ç±»å‹æ‰€æŒ‡å‘çš„æ•°æ®éƒ½æ˜¯å­˜å‚¨åœ¨å †ä¸Šçš„ï¼Œå› æ­¤æ•°æ®çš„æ•°é‡ä¸è¦æ±‚åœ¨ç¼–è¯‘çš„æ—¶å€™å°±å·²çŸ¥ï¼Œä¹Ÿå¯ä»¥åœ¨è¿è¡Œæ—¶å¢åŠ æˆ–å‡å°‘

Rustå¸¸ç”¨çš„é›†åˆæ•°æ®ç±»å‹åŒ…æ‹¬ï¼š
- å‘é‡(vector)
- å­—ç¬¦ä¸²(string)
- å“ˆå¸Œè¡¨(hash map)

## 8.1 Storing Lists of Values with Vectors
å‘é‡ç±»å‹åœ¨Rustä¸­å†™ä¸º `Vec<T>` ï¼Œå‘é‡ä¸­çš„æ•°æ®åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­ç´§æŒ¨ç€æ’åˆ—çš„ï¼Œå‘é‡ç±»å‹åªèƒ½å‚¨å­˜ç›¸åŒç±»å‹çš„å€¼

**Creating a New Vector**
è°ƒç”¨ `Vec::new` å‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºå‘é‡ï¼š
```rust
let v: Vec<i32> = Vec::new();
```
æˆ‘ä»¬å¯¹å˜é‡ `v` å¢åŠ äº†ç±»å‹æ³¨è§£ï¼Œå› ä¸ºéœ€è¦åœ¨æ²¡æœ‰å¾€å‘é‡ä¸­æ’å…¥å€¼çš„æƒ…å†µä¸‹å‘Šè¯‰ç¼–è¯‘å™¨å‘é‡éœ€è¦å­˜å‚¨çš„æ•°æ®çš„ç±»å‹
å‘é‡ç±»å‹æ˜¯ç”¨æ³›å‹å®ç°çš„ï¼Œå³ `Vec<T>` æ˜¯ä¸ªæ³›å‹

å¦‚æœæˆ‘ä»¬ä½¿ç”¨åˆå§‹å€¼æ¥åˆ›å»ºä¸€ä¸ªå‘é‡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `vec!` å®ï¼Œè®©Rustè‡ªåŠ¨æ¨å¯¼å‘é‡çš„ç±»å‹ï¼š
```rust
let v = vec![1, 2, 3];
```
æ­¤ä¾‹ä¸­ï¼ŒRustä¼šæ¨æ–­å‘é‡çš„ç±»å‹ä¸º `Vec<i32>` ï¼Œå› ä¸º `i32` æ˜¯é»˜è®¤çš„æ•´æ•°ç±»å‹ï¼Œæˆ‘ä»¬æä¾›äº† `i32` ç±»å‹çš„åˆå§‹å€¼ï¼ŒRustå°±ä¼šåˆ›å»º `Vec<i32>` ç±»å‹çš„å‘é‡

**Updating a Vector**
`push` æ–¹æ³•å¯ä»¥ä¸ºå‘é‡æ–°å¢å…ƒç´ ï¼š
```rust
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
```
æ³¨æ„å‘é‡ä¹Ÿå±äºå˜é‡ï¼Œå¦‚æœéœ€è¦å®ƒå¯å˜ï¼Œéœ€è¦åœ¨å£°æ˜æ—¶å†™ä¸Š `mut` å…³é”®å­—
Rustå¯ä»¥æ ¹æ® `push` å…¥çš„æ•°æ®çš„ç±»å‹æ¨æ–­å‘é‡çš„ç±»å‹ï¼Œæœ¬ä¾‹ä¸­ï¼Œå› ä¸º `push` å…¥çš„æ•°æ®æ˜¯ `i32` ï¼ŒRustæ¨æ–­å‘é‡çš„ç±»å‹æ˜¯ `Vec<i32>` ï¼Œå› æ­¤çœç•¥äº†ç±»å‹æ³¨è§£

**Reading Elements of Vectors**
å¯ä»¥é€šè¿‡ç´¢å¼•æˆ– `get` æ–¹æ³•å¼•ç”¨å‘é‡ä¸­å‚¨å­˜çš„å€¼ï¼š
```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2]; // è¿”å›å¯¹ç‰¹å®šä½ç½®å…ƒç´ çš„å¼•ç”¨
println!("The third element is {third}");

let third: Option<&i32> = v.get(2); //è¿”å› Option<&T>
match third {
	Some(third) => println!("The third element is {third}"),
	None => println!("There is no third element"),
}
```

æ˜¾ç„¶ï¼Œåœ¨å°è¯•è·å–è¶…å‡ºæ•°ç»„èŒƒå›´çš„å…ƒç´ æ—¶ï¼Œé€šè¿‡ä¸‹æ ‡ç´¢å¼•å’Œé€šè¿‡ `get` æ–¹æ³•çš„è¡Œä¸ºæ˜¯ä¸ä¸€æ ·çš„ï¼š
```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```
å¯¹äºç›´æ¥ä½¿ç”¨ `[]` ç´¢å¼•ï¼Œå½“å¼•ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„å…ƒç´ æ—¶ï¼ŒRustä¼španicï¼Œç¨‹åºå´©æºƒ
å¦‚æœæˆ‘ä»¬è®¤ä¸ºå°è¯•è®¿é—®è¶…è¿‡å‘é‡èŒƒå›´çš„å…ƒç´ æ˜¯ä¸€ä¸ªä¸¥é‡é”™è¯¯çš„æƒ…å†µï¼Œè¿™æ—¶åº”è¯¥ä½¿ç¨‹åºå´©æºƒï¼Œåˆ™é‡‡ç”¨ `[]` ç›´æ¥ç´¢å¼•å³å¯

å¯¹äºä½¿ç”¨ `get` æ–¹æ³•ï¼Œå½“å®ƒè¢«ä¼ é€’äº†ä¸€ä¸ªæ•°ç»„èŒƒå›´å¤–çš„ç´¢å¼•æ—¶ï¼Œå®ƒä¼šè¿”å› `Option<&T>::None` ï¼Œå¦‚æœæˆ‘ä»¬è®¤ä¸ºå¶å°”å°è¯•è®¿é—®è¶…è¿‡å‘é‡èŒƒå›´çš„å…ƒç´ æ˜¯ä¸€ä¸ªæ­£å¸¸æƒ…å†µï¼Œå¹¶ä¸”åœ¨ä»£ç æ·»åŠ äº†å¤„ç† `Some(&element)` å’Œ `None` çš„é€»è¾‘æ—¶ï¼Œåˆ™é‡‡ç”¨ `get` æ–¹æ³•

æ¯”å¦‚å¤„ç†ç”¨æˆ·è¾“å…¥æ—¶ï¼Œé‡‡ç”¨ `get` æ–¹æ³•ï¼Œå¹¶æ·»åŠ é”™è¯¯å¤„ç†çš„é€»è¾‘ï¼Œæ¯”ç®€å•è®©ç¨‹åºå´©æºƒæ›´å‹å¥½

åœ¨Rustä¸­ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“ï¼Œæ¯å½“ç¨‹åºè¦è·å–ä¸€ä¸ªæœ‰æ•ˆçš„å¼•ç”¨ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨(borrow checker)å°±ä¼šæ ¹æ®æ‰€æœ‰æƒå’Œå¼•ç”¨è§„åˆ™è¿›è¡Œæ£€æŸ¥ï¼Œç¡®ä¿è¿™ä¸ªå¼•ç”¨æ˜¯ç¬¦åˆè§„åˆ™ä¸”æœ‰æ•ˆçš„
æˆ‘ä»¬å·²ç»çŸ¥é“ï¼Œåœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œä¸èƒ½åŒæ—¶è·å–å¯¹ä¸€ä¸ªå€¼çš„å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ï¼Œè¿™ä¸ªè§„åˆ™å¯¹å‘é‡ç±»å‹ä¹Ÿé€‚ç”¨ï¼š
```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```
ä¸Šè¿°ä»£ç ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œæˆ‘ä»¬åœ¨ `let first = &v[0]` ä¸­è·å–äº†å¯¹å‘é‡çš„ç¬¬ä¸€ä¸ªå€¼çš„ä¸å¯å˜å¼•ç”¨ï¼Œè¿™ä¸ªå¼•ç”¨æœ€åä½¿ç”¨äº `println!` å‡½æ•°ï¼Œå› æ­¤åœ¨è¿™ä¸ªä¸å¯å˜å¼•ç”¨çš„ä½œç”¨åŸŸä¸­ï¼Œæˆ‘ä»¬åœ¨ `v.push(6)` ä¸­è·å–äº†æ•´ä¸ªå‘é‡ï¼Œæˆ–è€…è¯´å‘é‡ä¸­æ‰€æœ‰å€¼çš„å¯å˜å¼•ç”¨ï¼Œæ˜¾ç„¶å‘ç”Ÿäº†å†²çª

`v.push` éœ€è¦è·å–å‘é‡ä¸­æ‰€æœ‰å€¼çš„å¯å˜å¼•ç”¨çš„åŸå› æ˜¯å½“æˆ‘ä»¬å¾€å‘é‡ç»“å°¾å¢åŠ æ–°çš„å…ƒç´ çš„æ—¶å€™ï¼Œå¯èƒ½å†…å­˜ä¸­æ²¡æœ‰è¶³å¤Ÿçš„è¿ç»­ç©ºé—´å¯ä»¥åœ¨ä¹‹å‰çš„ç»“å°¾æ·»åŠ è¿™ä¸ªå…ƒç´ ï¼Œå› æ­¤éœ€è¦è¯·æ±‚OSåˆ†é…æ–°çš„å†…å­˜å—ï¼Œå¹¶å°†æ•°æ®å…¨éƒ¨æ‹·è´åˆ°æ–°å†…å­˜å—ä¸­ï¼Œè¿™æ—¶åŸæ¥çš„å¼•ç”¨å°±æŒ‡å‘äº†è¢«é‡Šæ”¾çš„å†…å­˜ï¼Œæˆä¸ºæ‚¬ç©ºå¼•ç”¨

**Iterating over the Values in a Vector**
å¯ä»¥ä½¿ç”¨ `for` å¾ªç¯éå†å‘é‡ä¸­çš„å…ƒç´ ï¼š
```rust
let v = vec![100, 32, 57];
for i in &v {
	println!("{i}");
}
```
æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `for` å¾ªç¯æ¥è·å–äº†å‘é‡ä¸­æ¯ä¸ª `i32` ç±»å‹çš„å€¼çš„ä¸å¯å˜å› å¼•ç”¨

åŒæ ·å¯ä»¥ç”¨ `for` å¾ªç¯è·å–æ¯ä¸ªå€¼çš„å¯å˜å¼•ç”¨ï¼š
```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
	*i += 50;
}
```
è¦è®¿é—®å¯å˜å¼•ç”¨æ‰€æŒ‡å‘çš„å€¼ï¼Œéœ€è¦ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦ `*` 

åŒæ ·ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ `for` å¾ªç¯ä¸­ç»™å‘é‡æ’å…¥æˆ–åˆ é™¤å€¼ï¼Œä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºå¯¹å‘é‡çš„ä¿®æ”¹æ¶‰åŠåˆ°å¯¹å‘é‡ä¸­æ‰€æœ‰çš„å€¼è¿›è¡Œå¯å˜å¼•ç”¨ï¼Œè€Œåœ¨ `for` å¾ªç¯ç»“æŸå‰ï¼Œå¯¹å‘é‡ä¸­çš„å„ä¸ªå€¼çš„å¼•ç”¨ä»å¤„äºä½œç”¨åŸŸå†…

**Using an Enum to Store Multiple Types**
æšä¸¾ç±»å‹çš„æˆå‘˜éƒ½å±äºåŒä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œä½†æ˜¯å®ƒä»¬å¯ä»¥å…³è”ä¸åŒç±»å‹çš„å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æšä¸¾ç±»å‹å®ç°åœ¨å‘é‡ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ï¼š
```rust
enum SpreadsheetCell {
	Int(i32),
	Float(f64),
	Text(String),
}

let row = vec![
	SpreadsheetCell::Int(3),
	SpreadSheetCell::Text(String::from("blue")),
	SpreadsheetCell::Float(10.12),
];
```
æ³¨æ„æœ¬ä¾‹ä¸­ï¼Œæˆå‘˜ `Int` , `Text` , `Float` éƒ½å±äºæšä¸¾ç±»å‹ `SpreadsheetCell`

Rustä¹‹æ‰€ä»¥éœ€è¦åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“å‘é‡ä¸­å€¼çš„ç‰¹å®šç±»å‹æ˜¯å› ä¸ºè¿™å¯ä»¥ä½¿å¾—å®ƒå‡†ç¡®çŸ¥é“å­˜å‚¨ä¸€ä¸ªå…ƒç´ éœ€è¦åˆ†é…å¤šå°‘å†…å­˜ï¼Œå¦å¤–ï¼Œç¡®å®šçš„ç±»å‹ä¹Ÿæ–¹ä¾¿Rustæ£€æŸ¥å¯¹äºè¯¥å‘é‡ä¸­çš„å…ƒç´ çš„æ“ä½œæ˜¯å¦åˆæ³•

å¦‚æœå·²ç»çŸ¥é“äº†å‘é‡ä¸­å¯èƒ½å­˜å‚¨çš„æ‰€æœ‰å¯èƒ½ç±»å‹ï¼Œä¹Ÿå¯é‡‡ç”¨å­˜å‚¨æšä¸¾ç±»å‹çš„æ–¹å¼è¾¾åˆ°ä½¿å¾—åœ¨å‘é‡ä¸­å­˜å‚¨å¤šä¸ªç±»å‹çš„å€¼çš„ç›®çš„ï¼Œå¯¹äºæšä¸¾ç±»å‹ï¼ŒRustç¼–è¯‘å™¨ä¼šç¡®ä¿æ‰€æœ‰çš„æƒ…å†µéƒ½åœ¨ `match` ä¸­å¾—åˆ°äº†å¤„ç†

**Dropping a Vector Drops Its Elements**
ç±»ä¼¼äºä»»ä½•å…¶ä»–çš„Â `struct`ï¼Œå‘é‡åœ¨å…¶ç¦»å¼€ä½œç”¨åŸŸæ—¶ä¼šè¢«é‡Šæ”¾ï¼š
```rust
{
	let v = vec![1, 2, 3, 4];

	// do stuff with v
} // v goes out of scope and is freed here
```
å½“å‘é‡è¢«é‡Šæ”¾ï¼Œå®ƒåŒ…å«çš„æ‰€æœ‰çš„å€¼éƒ½ä¼šè¢«é‡Šæ”¾
å€Ÿç”¨æ£€æŸ¥å™¨ä¹Ÿä¿è¯äº†ä»»ä½•å¯¹å‘é‡çš„å€¼çš„å¼•ç”¨åªæœ‰åœ¨å‘é‡æœ¬èº«æœ‰æ•ˆæ—¶æ‰æœ‰æ•ˆ

## 8.2 Storing UTF-8 Encoded Text with Strings


