---
completed: true
---
>  https://en.wikipedia.org/wiki/Common_subexpression_elimination

In [compiler theory](https://en.wikipedia.org/wiki/Compiler_theory "Compiler theory"), **common subexpression elimination** (**CSE**) is a [compiler optimization](https://en.wikipedia.org/wiki/Compiler_optimization "Compiler optimization") that searches for instances of identical [expressions](https://en.wikipedia.org/wiki/Expression_\(computer_science\) "Expression (computer science)") (i.e., they all evaluate to the same value), and analyzes whether it is worthwhile replacing them with a single variable holding the computed value. [1](https://en.wikipedia.org/wiki/Common_subexpression_elimination#cite_note-MuchnickAssociates1997-1)
>  公共子表达式消除是一种编译器优化技术，它寻找相同表达式的实例 (即它们都计算出相同的值)，然后分析是否值得用一个存储了计算值的变量替换这些表达式

## Example
In the following code:

```
a = b * c + g;
d = b * c * e;
```

it may be worth transforming the code to:

```
tmp = b * c;
a = tmp + g;
d = tmp * e;
```

if the cost of storing and retrieving `tmp` is less than the cost of calculating `b * c` an extra time.

>  例如，可以将上例中的 `b * c` 提前计算，存储为 `tmp` ，将表达式中的 `b * c` 都替换为 `tmp`
>  如果存储和查找 `tmp` 值的开销小于额外计算一次 `b * c` 的开销，CSE 就值得

## Principle
The possibility to perform CSE is based on [available expression](https://en.wikipedia.org/wiki/Available_expression "Available expression") analysis (a [data flow analysis](https://en.wikipedia.org/wiki/Data_flow_analysis "Data flow analysis")). An expression `b*c` is available at a point _p_ in a program if:

- every path from the initial node to p evaluates `b*c` before reaching _p_,
- and there are no assignments to `b` or `c` after the evaluation but before _p_.

>  可用表达式分析 (一种数据流分析技术) 用于检测执行 CSE 的可能性
>  对于程序中的一点 p，如果表达式 `b * c` 满足
>  - 从初始节点到 p 的每一条路径都会在到达 p 之前评估 `b * c`
>  - 在评估了 `b * c` 之后，到达点 p 之前，没有出现对 `b, c` 的赋值
>  则我们称表达式 `b * c` 在点 p 处是可用的

The cost/benefit analysis performed by an optimizer will calculate whether the cost of the store to `tmp` is less than the cost of the multiplication; in practice other factors such as which values are held in which registers are also significant.
>  优化器会执行成本/收益分析，计算将值存储在 `tmp` 的开销是否小于计算乘法的开销
>  在实践中，其他的因素例如存储在哪个寄存器也会带来影响

Compiler writers distinguish two kinds of CSE:

- **local common subexpression elimination** works within a single [basic block](https://en.wikipedia.org/wiki/Basic_block "Basic block")
- **global common subexpression elimination** works on an entire procedure,

Both kinds rely on [data flow analysis](https://en.wikipedia.org/wiki/Data_flow_analysis "Data flow analysis") of which expressions are available at which points in a program.

>  CSE 有两种类型
>  - 局部 CSE: 在单个基本块内工作
>  - 全局 CSE: 对整个过程进行操作
>  这两类 CSE 都依赖于数据流分析，以确定程序中的各个点上可用的表达式

## Benefits
The benefits of performing CSE are great enough that it is a commonly used optimization.
>  CSE 是常用的优化手段

In simple cases like in the example above, programmers may manually eliminate the [duplicate expressions](https://en.wikipedia.org/wiki/Duplicate_code "Duplicate code") while writing the code. The greatest source of CSEs are intermediate code sequences generated by the compiler, such as for [array](https://en.wikipedia.org/wiki/Array_data_structure "Array data structure") indexing calculations, where it is not possible for the developer to manually intervene. In some cases language features may create many duplicate expressions. For instance, [C](https://en.wikipedia.org/wiki/C_\(programming_language\) "C (programming language)") [macros](https://en.wikipedia.org/wiki/Macro_\(computer_science\) "Macro (computer science)"), where macro expansions may result in common subexpressions not apparent in the original source code.
>  在简单的示例中，例如上面的示例，程序员可以在编写代码时手动消除重复表达式 (手动执行 CSE)
>  然而最常见的 CSE 的来源是编译器生成的中间代码序列，例如用于数组索引计算的情况，这些情况下，开发者无法干预
>  另外，某些情况下，语言特性可能会产生许多重复表达式，例如 C 中的宏，宏展开后，可能会导致源码中不明显的公共子表达式出现

Compilers need to be judicious about the number of temporaries created to hold values. An excessive number of temporary values creates [register pressure](https://en.wikipedia.org/wiki/Register_pressure "Register pressure") possibly resulting in [spilling registers](https://en.wikipedia.org/wiki/Register_spilling "Register spilling") to memory, which may take longer than simply recomputing an arithmetic result when it is needed.
>  编译器在创建存储值的临时变量时，需要注意创建的临时变量的数量
>  过多的临时变量会带来寄存器压力，可能导致寄存器溢出到内存，进而拖累性能，导致比简单地重新执行计算还要慢

> This page was last edited on 17 November 2023, at 03:07 (UTC).