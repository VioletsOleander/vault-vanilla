This document describes a framework in MLIR in which to perform operation conversions between, and within dialects. This framework allows for transforming illegal operations to those supported by a provided conversion target, via a set of pattern-based operation rewriting patterns.
>  本文档描述一个用于在 MLIR 中不同方言之间以及方言内部执行转换的框架
>  该框架允许通过一组 pattern-based 的 operation 重写模式，将非法 operation 转化为由提供的转换目标支持的 operation

The dialect conversion framework consists of the following components:

- A [Conversion Target](https://mlir.llvm.org/docs/DialectConversion/#conversion-target)
- A set of [Rewrite Patterns](https://mlir.llvm.org/docs/DialectConversion/#rewrite-pattern-specification)
- A [Type Converter](https://mlir.llvm.org/docs/DialectConversion/#type-conversion) (Optional)

>  方言转换框架包括的成分有：
>  - 一个转换目标
>  - 一组重写模式
>  - 一个 type converter

## Modes of Conversion 
When applying a conversion to a set of operations, there are several different conversion modes that may be selected from:
>  对一组 operation 应用转换时，有以下三种转换模式供选择

- Partial Conversion
    - A partial conversion will legalize as many operations to the target as possible, but will allow pre-existing operations that were not explicitly marked as “illegal” to remain unconverted. This allows for partially lowering parts of the input in the presence of unknown operations.
    - A partial conversion can be applied via `applyPartialConversion`.

>  部分转换
>  部分转换为目标合法化尽可能多的 operation，但不会转换没有显式被标记为 “非法” 的 operation，部分转换允许在输入 operations 中存在 “未知”  operation 时仅 lowering 部分 operations
>  部分转换通过 `applyPartialConversion` 应用

- Full Conversion
    - A full conversion legalizes all input operations, and is only successful if all operations are properly legalized to the given conversion target. This ensures that only known operations will exist after the conversion process.
    - A full conversion can be applied via `applyFullConversion`.

>  完全转换
>  完全转换会合法化所有输入 operation，并且也仅在所有 operation 都被正确针对给定转换目标合法化后成功
>  完全转换通过 `appllyFullConversion` 应用

- Analysis Conversion
    - An analysis conversion will analyze which operations are legalizable to the given conversion target if a conversion were to be applied. This is done by performing a ‘partial’ conversion and recording which operations would have been successfully converted if successful. Note that no rewrites, or transformations, are actually applied to the input operations.
    - An analysis conversion can be applied via `applyAnalysisConversion`.

>  分析转换
>  分析转换会分析哪些 operation 针对给定转换是可以合法化的。这实际上是通过先执行一个部分转换，然后记录哪些 operation 会被成功转换来实现的，在这个过程中，输入 operation 不会被实际重写或转换。
>  分析转换通过 `applyAnalysisConversion` 应用

In all cases, the framework walks the operations in preorder, examining an op before the ops in any regions it has.
>  在所有情况下，框架都以前序遍历的顺序遍历 operations，即在检查任何包含该 operation 的区域中的其他 operations 时，先检查该 operation

## Conversion Target 
The conversion target is a formal definition of what is considered to be legal during the conversion process. The final operations generated by the conversion framework must be marked as legal on the `ConversionTarget` for the rewrite to be a success. Depending on the conversion mode, existing operations need not always be legal. 
>  转换目标正式定义了在转换过程中，什么是合法的
>  由转换框架生成的最终 operation 只有在 `ConverTarget` 中被标记是合法的，转换才会成功

Operations and dialects may be marked with any of the provided legality actions below:

- Legal
    - This action signals that every instance of a given operation is legal, i.e. any combination of attributes, operands, types, etc. are valid.
- Dynamic
    - This action signals that only some instances of a given operation are legal. This allows for defining fine-tune constraints, e.g. saying that `arith.addi` is only legal when operating on 32-bit integers.
- Illegal
    - This action signals that no instance of a given operation is legal. Operations marked as “illegal” must always be converted for the conversion to be successful. This action also allows for selectively marking specific operations as illegal in an otherwise legal dialect.

>  operation 和方言可以通过这些 legality actions 进行标记
>  - Legal: 该 action 表示给定 operation 的每个实例都是合法的，即任何属性、operation 数、类型等组合都是有效的
>  - Dynamic: 该 action 表示给定 operation 的某些实例是合法的。这允许定义精细的约束条件，例如 `arith.addi` 只有在对 32 bit 整数进行 operation 时才是合法的
>  - Illegal: 该 action 表示给定 operation 没有实例是合法的。被标记为 Illegal 的 operation 必须被转换，否则转换不会成功。该 action 还允许在其他合法的方言中选择性地将特定 operation 标记为非法

Operations and dialects that are neither explicitly marked legal nor illegal are separate from the above (“unknown” operations) and are treated differently, for example, for the purposes of partial conversion as mentioned above.
>  既未明确被标记为 legal 也未明确被标记为 illegal 的 operation 和方言属于上述分类之外的 “未知” operation，其处理方式有所不同

An example conversion target is shown below:

```c++
struct MyTarget : public ConversionTarget {
  MyTarget(MLIRContext &ctx) : ConversionTarget(ctx) {
    //--------------------------------------------------------------------------
    // Marking an operation as Legal:

    /// Mark all operations within the LLVM dialect are legal.
    addLegalDialect<LLVMDialect>();

    /// Mark `arith.constant` op is always legal on this target.
    addLegalOp<arith::ConstantOp>();

    //--------------------------------------------------------------------------
    // Marking an operation as dynamically legal.

    /// Mark all operations within Affine dialect have dynamic legality
    /// constraints.
    addDynamicallyLegalDialect<affine::AffineDialect>(
        [](Operation *op) { ... });

    /// Mark `func.return` as dynamically legal, but provide a specific legality
    /// callback.
    addDynamicallyLegalOp<func::ReturnOp>([](func::ReturnOp op) { ... });

    /// Treat unknown operations, i.e. those without a legalization action
    /// directly set, as dynamically legal.
    markUnknownOpDynamicallyLegal([](Operation *op) { ... });

    //--------------------------------------------------------------------------
    // Marking an operation as illegal.

    /// All operations within the GPU dialect are illegal.
    addIllegalDialect<GPUDialect>();

    /// Mark `cf.br` and `cf.cond_br` as illegal.
    addIllegalOp<cf::BranchOp, cf::CondBranchOp>();
  }

  /// Implement the default legalization handler to handle operations marked as
  /// dynamically legal that were not provided with an explicit handler.
  bool isDynamicallyLegal(Operation *op) override { ... }
};
```

>  在上述 `MyTarget` 的定义中
>  `addLegalDialect<LLVMDialect>` 标记了 `LLVM` dialect 中的所有 operation 都是 legal 的
>  `addLegalOp<arith::ConstantOp>` 标记了 `arich.ConstantOp` 为 legal
>  ...

### Recursive Legality 
In some cases, it may be desirable to mark entire regions as legal. This provides an additional granularity of context to the concept of “legal”. If an operation is marked recursively legal, either statically or dynamically, then all of the operations nested within are also considered legal even if they would otherwise be considered “illegal”. 
>  某些情况下，我们想把整个 Region 标记为合法，这为 “合法” 这一概念提供了额外的上下文粒度
>  如果一个 operation 被标记为 recursively legal ，则其中嵌套的所有 operation 被会被认为合法，即便它们原本可能会被认为是 illegal

An operation can be marked via `markOpRecursivelyLegal<>`:

```c++
ConversionTarget &target = ...;

/// The operation must first be marked as `Legal` or `Dynamic`.
target.addLegalOp<MyOp>(...);
target.addDynamicallyLegalOp<MySecondOp>(...);

/// Mark the operation as always recursively legal.
target.markOpRecursivelyLegal<MyOp>();
/// Mark optionally with a callback to allow selective marking.
target.markOpRecursivelyLegal<MyOp, MySecondOp>([](Operation *op) { ... });
/// Mark optionally with a callback to allow selective marking.
target.markOpRecursivelyLegal<MyOp>([](MyOp op) { ... });
```

>  上例代码中，在 `MyOp` 已经被标记为 Legal 或 Dynamic 的前提下，进一步将其标记为 Recursively Legal

## Rewrite Pattern Specification 
After the conversion target has been defined, a set of legalization patterns must be provided to transform illegal operations into legal ones. The patterns supplied here have the same structure and restrictions as those described in the main [Pattern](https://mlir.llvm.org/docs/PatternRewriter/) documentation. The patterns provided do not need to generate operations that are directly legal on the target. The framework will automatically build a graph of conversions to convert non-legal operations into a set of legal ones.
>  定义好转换目标后，需要提供一组合法化模式用于将非法 operation 转化为合法 operation
>  所提供的模式不需要生成直接对于目标合法的 operation，框架会自动构建一个转换图，将非法 operation 转换为一组合法 operation

As an example, say you define a target that supports one operation: `foo.add`. When providing the following patterns: [`bar.add` -> `baz.add`, `baz.add` -> `foo.add`], the framework will automatically detect that it can legalize `bar.add` -> `foo.add` even though a direct conversion does not exist. This means that you don’t have to define a direct legalization pattern for `bar.add` -> `foo.add`.
>  例如，我们定义了支持 operation `foo.add` 的目标，当我们提供了以下模式：\[ `bar.add` -> `barz.add`, `barz.add` -> `foo.add` \] 后，框架会自动检测到该模式可以用于合法化 `bar.add` -> `foo.add` ，即便不是直接的转换，因此我们不需要为 `bar.add` -> `foo.add` 定义直接的合法化模式

### Conversion Patterns 
Along with the general `RewritePattern` classes, the conversion framework provides a special type of rewrite pattern that can be used when a pattern relies on interacting with constructs specific to the conversion process, the `ConversionPattern`. 
>  转换框架提供了通用的 `RewritePattern` 类，此外还提供了一个特殊的重写 pattern，称为 `ConversionPattern` ，可以用于处理需要和转换过程中特定的构造进行交互的 pattern

For example, the conversion process does not necessarily update operations in-place and instead creates a mapping of events such as replacements and erasures, and only applies them when the entire conversion process is successful. 
>  例如，转换过程并不总是就地更新 operation，而是创建一个事件映射 (事件例如替代和删除)，并只在整个转换过程成功时才应用这些更改
>  (也就是先记住要执行什么，然后延迟到最后执行)

Certain classes of patterns rely on using the updated/remapped operands of an operation, such as when the types of results defined by an operation have changed. The general Rewrite Patterns can no longer be used in these situations, as the types of the operands of the operation being matched will not correspond with those expected by the user. 
>  某些 patterns 依赖于使用 operation 的更新/重新映射的 operands，例如当 operation 定义的结果类型发生更改时
>  此时，通用的 `RewritePattern` 将不适用，因为被匹配的 operation 的 operands 类型将和用户期望的类型不对应 (用户期望的类型即用户编写的 patterns 中所期望的 operations 的 operands 的类型，这些类型可能不是原来的类型，需要先进行一次转换)

This pattern provides, as an additional argument to the `matchAndRewrite` method, the list of operands that the operation should use after conversion. If an operand was the result of a non-converted operation, for example if it was already legal, the original operand is used. This means that the operands provided always have a 1-1 non-null correspondence with the operands on the operation. The original operands of the operation are still intact and may be inspected as normal.
>  `ConversionPattern` 向 `matchAndRewrite` 方法提供一个额外参数：operation 在转换之后应该使用的 operands 列表
>  如果某个 operand 是一个未转换 operation 的结果，例如它已经是 legal 的，则使用原始 operand，这意味着列表中提供的 operands 和 operation 上的 operands 需要有 1 对 1 的非空对应关系

These patterns also utilize a special `PatternRewriter`, `ConversionPatternRewriter`, that provides special hooks for use with the conversion infrastructure.
>  `ConversionPattern` 也会利用一个特殊的 `PatternRewriter` ，即 `ConversionPatternRewirter` 
>  `ConversionPatternRewriter` 为与转换 infrastructure 配合使用提供了特殊的 hooks

```c++
struct MyConversionPattern : public ConversionPattern {
  /// The `matchAndRewrite` hooks on ConversionPatterns take an additional
  /// `operands` parameter, containing the remapped operands of the original
  /// operation.
  virtual LogicalResult
  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
                  ConversionPatternRewriter &rewriter) const;
};
```

#### Type Safety 
The types of the remapped operands provided to a conversion pattern must be of a type expected by the pattern. The expected types of a pattern are determined by a provided [TypeConverter](https://mlir.llvm.org/docs/DialectConversion/#type-converter). If no type converter is provided, the types of the remapped operands are expected to match the types of the original operands. 
>  为 `ConvertionPattern` 提供的 remapped operands 的类型必须是该转换模式所期望的类型
>  一个 pattern 所期望的类型由提供的 TypeConverter 确定，如果没有提供，remapped operands 的类型则期望匹配原来 operands 的类型

If a type converter is provided, the types of the remapped operands are expected to be legal as determined by the converter. If the remapped operand types are not of an expected type, and a materialization to the expected type could not be performed, the pattern fails application before the `matchAndRewrite` hook is invoked. This ensures that patterns do not have to explicitly ensure type safety, or sanitize the types of the incoming remapped operands. More information on type conversion is detailed in the [dedicated section](https://mlir.llvm.org/docs/DialectConversion/#type-conversion) below.
>  如果提供了 type converter，则 remapped operands 的类型需要和 converter 定义的类型一致，才视作合法
>  如果 remapped operands 的类型不是 type converter 所期望的类型，并且无法执行到所期望类型的 materialization operation，则在调用 `mathAndRewirte` hook 之前，pattern 的应用将失败
>  这确保了 pattern 不需要显式地保证类型安全性，也不需要对输入的 remapped operands 进行验证和清理 (sanitize) (pattern 中不需要写类型验证的逻辑)

## Type Conversion 
It is sometimes necessary as part of a conversion to convert the set types of being operated on. In these cases, a `TypeConverter` object may be defined that details how types should be converted when interfacing with a pattern. A `TypeConverter` may be used to convert the signatures of block arguments and regions, to define the expected inputs types of the pattern, and to reconcile type differences in general.
>  有时，在转换的过程中，类型也有必要转换
>  此时，可以定义 `TypeConverter` 对象，该对象详细说明在与 pattern 交互时，类型应该如何被转换
>  `TypeConverter` 可以用于转换 block 参数和 region 参数的签名 (即参数声明类型)、用于定义 pattern 所期望的输入类型、用于解决一般的类型差异问题

### Type Converter 
The `TypeConverter` contains several hooks for detailing how to convert types, and how to materialize conversions between types in various situations. The two main aspects of the `TypeConverter` are conversion and materialization.
>  `TypeConverter` 包含了多个用于详细说明如何转化类型、如何在各种情况下 materialize (具体实现) 类型间的转换的 hooks
>  `TypeConverter` 的两个主要方面就是 `conversion` 和 `materialization`

A `conversion` describes how a given source `Type` should be converted to N target types. If the source type is converted to itself, we say it is a “legal” type. Type conversions are specified via the `addConversion` method described below.
>  `conversion` 描述了给定的源 `Type` 应该如何被转换到 N 个目标类型
>  如果在定义中，源类型应该被转换到它自己，则称该类型是合法类型 (不需要转换)
>  类型转换需要通过 `addConversion` 方法指定

A `materialization` describes how a list of values should be converted to a list of values with specific types. An important distinction from a `conversion` is that a `materialization` can produce IR, whereas a `conversion` cannot. These materializations are used by the conversion framework to ensure type safety during the conversion process. 
>  `materialization` 描述了一组 values 应该如何被转换到另一组具有特定类型的 values
>  和 `conversion` 的差异在于 `materialization` 可以生成 IR，`conversion` 不行 (`conversion` 抽象地指定要求，`materialization` 指定实现)
>  `materialization` 会被转换框架用于确保转换过程中的类型安全

There are several types of materializations depending on the situation.
>  materialization 分为两种类型

- Source Materialization
    - A source materialization is used when a value was replaced with a value of a different type, but there are still users that expects the original (“source”) type at the end of the conversion process. A source materialization converts the replacement value back to the source type.
    - This materialization is used in the following situations:
        - When a block argument has been converted to a different type, but the original argument still has users that will remain live after the conversion process has finished.
        - When a block argument has been dropped, but the argument still has users that will remain live after the conversion process has finished.
        - When the result type of an operation has been converted to a different type, but the original result still has users that will remain live after the conversion process is finished.

>  source materialization
>  当一个 value 被另一个 value 替换时，使用的就是 source materialization, source materialization 会将替换的 value 转换为源 value 的类型
>  在以下的情况中会使用 source materialization:
>  - 当一个 block 参数被转换为另一个类型时，原来的参数在转换过程完成后仍然具有使用者
>  - 当一个 block 参数被丢弃时，原来的参数在转换过程完成后仍然具有使用者
>  - 当一个 operation 的结果类型被转换到不同的类型后，原来的结果在转换过程完成后仍然具有使用者

- Target Materialization
    - A target materialization converts a value to the type that is expected by a conversion pattern according to its type converter.
    - A target materialization is used when a pattern expects the remapped operands to be of a certain set of types, but the original input operands have either not been replaced or been replaced with values of a different type.

>  target materialization
>  target materialization 会将一个 value 转换为 conversion pattern 根据其 type converter 所期待的类型
>  target materialization 会在一个 pattern 期待 remapped operands 属于特定的一组类型，但原来的输入 operands 即没有被替换为一个不同的 value，也没有被替换为一个不同的 type 时使用

If a converted value is used by an operation that isn’t converted, it needs a conversion back to the `source` type, hence source materialization; if an unconverted value is used by an operation that is being converted, it needs conversion to the `target` type, hence target materialization.
>  如果一个被转换后的 value 被一个不被转换的 operation 使用，它需要被转换为源类型，故需要使用 source materialization
>  如果一个不被转换的 value 被一个被转换的 operation 使用，它需要被转换为目标类型，故需要使用 target materialization

As noted above, the conversion process guarantees that the type contract of the IR is preserved during the conversion. This means that the types of value uses will not implicitly change during the conversion process. When the type of a value definition, either block argument or operation result, is being changed, the users of that definition must also be updated during the conversion process. If they aren’t, a type conversion must be materialized to ensure that a value of the expected type is still present within the IR. If a materialization is required, but cannot be performed, the entire conversion process fails.
>  转换过程确保了 IR 的类型 contract 在转换过程中保持，这意味着 value 的类型使用不会再转换过程中隐式改变
>  当一个 value 定义 (无论是块参数还是 operation 结果) 的类型正被改变时，该定义的使用者必须在转换过程中被更新
>  如果没有，则必须 materialize 一个类型转换，确保 IR 中仍然存在预期类型的 value，如果需要 materialize 一个类型转换但无法执行，则整个转换过程失败

Several of the available hooks are detailed below:

```c++
class TypeConverter {
 public:
  /// Register a conversion function. A conversion function defines how a given
  /// source type should be converted. A conversion function must be convertible
  /// to any of the following forms(where `T` is a class derived from `Type`:
  ///   * Optional<Type>(T)
  ///     - This form represents a 1-1 type conversion. It should return nullptr
  ///       or `std::nullopt` to signify failure. If `std::nullopt` is returned, the
  ///       converter is allowed to try another conversion function to perform
  ///       the conversion.
  ///   * Optional<LogicalResult>(T, SmallVectorImpl<Type> &)
  ///     - This form represents a 1-N type conversion. It should return
  ///       `failure` or `std::nullopt` to signify a failed conversion. If the new
  ///       set of types is empty, the type is removed and any usages of the
  ///       existing value are expected to be removed during conversion. If
  ///       `std::nullopt` is returned, the converter is allowed to try another
  ///       conversion function to perform the conversion.
  ///   * Optional<LogicalResult>(T, SmallVectorImpl<Type> &, ArrayRef<Type>)
  ///     - This form represents a 1-N type conversion supporting recursive
  ///       types. The first two arguments and the return value are the same as
  ///       for the regular 1-N form. The third argument is contains is the
  ///       "call stack" of the recursive conversion: it contains the list of
  ///       types currently being converted, with the current type being the
  ///       last one. If it is present more than once in the list, the
  ///       conversion concerns a recursive type.
  /// Note: When attempting to convert a type, e.g. via 'convertType', the
  ///       mostly recently added conversions will be invoked first.
  template <typename FnT,
            typename T = typename llvm::function_traits<FnT>::template arg_t<0>>
  void addConversion(FnT &&callback) {
    registerConversion(wrapCallback<T>(std::forward<FnT>(callback)));
  }

  /// All of the following materializations require function objects that are
  /// convertible to the following form:
  ///   `std::optional<Value>(OpBuilder &, T, ValueRange, Location)`,
  /// where `T` is any subclass of `Type`. This function is responsible for
  /// creating an operation, using the OpBuilder and Location provided, that
  /// "casts" a range of values into a single value of the given type `T`. It
  /// must return a Value of the converted type on success, an `std::nullopt` if
  /// it failed but other materialization can be attempted, and `nullptr` on
  /// unrecoverable failure. It will only be called for (sub)types of `T`.
  /// Materialization functions must be provided when a type conversion may
  /// persist after the conversion has finished.

  /// This method registers a materialization that will be called when
  /// converting a replacement value back to its original source type.
  /// This is used when some uses of the original value persist beyond the main
  /// conversion.
  template <typename FnT,
            typename T = typename llvm::function_traits<FnT>::template arg_t<1>>
  void addSourceMaterialization(FnT &&callback) {
    sourceMaterializations.emplace_back(
        wrapMaterialization<T>(std::forward<FnT>(callback)));
  }

  /// This method registers a materialization that will be called when
  /// converting a value to a target type according to a pattern's type
  /// converter.
  ///
  /// Note: Target materializations can optionally inspect the "original"
  /// type. This type may be different from the type of the input value.
  /// For example, let's assume that a conversion pattern "P1" replaced an SSA
  /// value "v1" (type "t1") with "v2" (type "t2"). Then a different conversion
  /// pattern "P2" matches an op that has "v1" as an operand. Let's furthermore
  /// assume that "P2" determines that the converted target type of "t1" is
  /// "t3", which may be different from "t2". In this example, the target
  /// materialization will be invoked with: outputType = "t3", inputs = "v2",
  /// originalType = "t1". Note that the original type "t1" cannot be recovered
  /// from just "t3" and "v2"; that's why the originalType parameter exists.
  ///
  /// Note: During a 1:N conversion, the result types can be a TypeRange. In
  /// that case the materialization produces a SmallVector<Value>.
  template <typename FnT,
            typename T = typename llvm::function_traits<FnT>::template arg_t<1>>
  void addTargetMaterialization(FnT &&callback) {
    targetMaterializations.emplace_back(
        wrapMaterialization<T>(std::forward<FnT>(callback)));
  }
};
```

Materializations through the type converter are optional. If the `ConversionConfig::buildMaterializations` flag is set to “false”, the dialect conversion driver builds an `unrealized_conversion_cast` op instead of calling the respective type converter callback whenever a materialization is required.
>  通过 type converter 的 materialization 是可选的，如果 `ConversionConfig::buildMaterializations` flag 被设置为 false, dialect conversion driver 会在需要 materialization 时构建一个 `unrealized_conversion_case` 算子，而不是调用对应的 type converter 的 callback

### Region Signature Conversion 
From the perspective of type conversion, the types of block arguments are a bit special. Throughout the conversion process, blocks may move between regions of different operations. Given this, the conversion of the types for blocks must be done explicitly via a conversion pattern.
>  在转换过程中，blocks 可能会在不同 operations 的 regions 中移动，因此 blocks 参数的类型转换必须通过 conversion pattern 显式进行

To convert the types of block arguments within a Region, a custom hook on the `ConversionPatternRewriter` must be invoked; `convertRegionTypes`. This hook uses a provided type converter to apply type conversions to all blocks of a given region. 
>  要转换一个 region 内 block arguments 的类型，需要调用 `ConversionPatternRewriter` 的一个自定义 hook `convertRegionTypes` ，该 hook 使用提供的 type converter 将类型转换应用到给定 region 的所有 blocks

This hook also takes an optional `TypeConverter::SignatureConversion` parameter that applies a custom conversion to the entry block of the region. The types of the entry block arguments are often tied semantically to the operation, e.g., `func::FuncOp`, `AffineForOp`, etc.
>  该 hook 还接受一个可选 `TypeConverter::SignatureConversion` 参数，以对 region 的 entry block 应用自定义转换

To convert the signature of just one given block, the `applySignatureConversion` hook can be used.

A signature conversion, `TypeConverter::SignatureConversion`, can be built programmatically:

```c++
class SignatureConversion {
public:
    /// Remap an input of the original signature with a new set of types. The
    /// new types are appended to the new signature conversion.
    void addInputs(unsigned origInputNo, ArrayRef<Type> types);

    /// Append new input types to the signature conversion, this should only be
    /// used if the new types are not intended to remap an existing input.
    void addInputs(ArrayRef<Type> types);

    /// Remap an input of the original signature with a range of types in the
    /// new signature.
    void remapInput(unsigned origInputNo, unsigned newInputNo,
                    unsigned newInputCount = 1);

    /// Remap an input of the original signature to another `replacement`
    /// value. This drops the original argument.
    void remapInput(unsigned origInputNo, Value replacement);
};
```

The `TypeConverter` provides several default utilities for signature conversion and legality checking: `convertSignatureArgs`/`convertBlockSignature`/`isLegal(Region *|Type)`.

## Debugging 
To debug the execution of the dialect conversion framework, `-debug-only=dialect-conversion` may be used. 

This command line flag activates LLVM’s debug logging infrastructure solely for the conversion framework. The output is formatted as a tree structure, mirroring the structure of the conversion process. This output contains all of the actions performed by the rewriter, how generated operations get legalized, and why they fail.

Example output is shown below:

```
//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x608000002e20) {
  "func.return"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
    ** Insert  : 'spirv.Return'(0x6070000453e0)
    ** Replace : 'func.return'(0x608000002e20)

    //===-------------------------------------------===//
    Legalizing operation : 'spirv.Return'(0x6070000453e0) {
      "spirv.Return"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
} -> SUCCESS
//===-------------------------------------------===//
```

This output is describing the legalization of an `func.return` operation. We first try to legalize by folding the operation, but that is unsuccessful for `func.return`. From there, a pattern is applied that replaces the `func.return` with a `spirv.Return`. The newly generated `spirv.Return` is then processed for legalization, but is found to already legal as per the target.