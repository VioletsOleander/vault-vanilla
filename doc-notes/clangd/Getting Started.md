To use clangd, you need:

- clangd installed
- a plugin for your editor
- to tell clangd how your project is built

>  要使用 clangd，我们需要
>  - 安装 clangd
>  - 安装编辑器拓展
>  - 告诉 clangd 我们的项目应该如何构建

## Installing clangd
For best results, use the [most recent version](https://github.com/clangd/clangd/releases/latest) of clangd.

You can check the version currently installed with `clangd --version`.

(Version numbers are based on LLVM. clangd 7 was the first usable release).

### Installing with a package manager
Most distributions include clangd in a `clangd` package, in a `clang-tools` package, or in the full `llvm` distribution.

For some platforms, binaries are also available at [releases.llvm.org](http://releases.llvm.org/download.html).

### Standalone .zip releases
You can also download binaries directly for macOS, windows, and Linux (x86-64): [latest stable release](https://github.com/clangd/clangd/releases/latest).

If you live on the bleeding edge, snapshot pre-releases are built weekly and available on the [github releases page](https://github.com/clangd/clangd/releases).

### Compiling from sources
You can find instructions in [llvm-project](https://github.com/llvm/llvm-project/tree/main/clang-tools-extra/clangd#building-and-testing-clangd).

## Editor plugins
clangd runs through [Language Server Protocol](https://microsoft.github.io/language-server-protocol/), editors that support LSP can communicate with clangd to provide features like code completion, diagnostics, go-to-definition, etc. In principle clangd should work with any of them, though feature set and interface may vary.

Here are some plugins we know work well with clangd:

**Visual Studio Code**
The official extension is [vscode-clangd](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd) and can be installed from within VSCode.

Choose **View** –> **Extensions**, then search for “clangd”. (Make sure the Microsoft C/C++ extension is **not** installed).

After restarting, you should see red underlines underneath errors, and you should get rich code completions including e.g. function parameters.

![Code completion in VSCode](https://clangd.llvm.org/screenshots/basic_completion.png)

vscode-clangd has excellent support for all clangd features, including:

- code completion
- diagnostics and fixes
- find declarations, references, and definitions
- find symbol in file (`Ctrl-P @foo`) or workspace (`Ctrl-P #foo`)
- hover and highlights
- code actions

Under the hood
- **Debug logs**: when clangd is running, you should see “Clang Language Server” in the dropdown of the Output panel (**View** -> **Output**).
- **Command-line flags**: these can be passed in the `clangd.arguments` array in your `settings.json`. (**File** -> **Preferences** -> **Settings**).
- **Alternate clangd binary**: set the `clangd.path` string in `settings.json`.

If you don’t have strong feelings about an editor, we suggest you try out [VSCode](https://code.visualstudio.com/), it has excellent language server support and most faithfully demonstrates what clangd can do.

## Project setup
To understand your source code, clangd needs to know your build flags. (This is just a fact of life in C++, source files are not self-contained).
>  要理解源码，clangd 需要知道我们的构建标志 (因为 C++ 的源文件不是 self-contained 的)

By default, clangd will assume your code is built as `clang some_file.cc`, and you’ll probably get spurious errors about missing `#include` d files, etc. There are a couple of ways to fix this.
>  clangd 默认假设我们的代码通过 `clang some_file.cc` 构建
>  通常遇到的缺少 `#include` 的文件的错误可以通过以下介绍的方式解决

### `compile_commands.json`
This file provides compile commands for every source file in a project. It is usually generated by tools.
>  `compile_commands.json` 为项目中的每个源文件都提供了编译命令，它通常由工具生成

clangd will look in the parent directories of the files you edit looking for it, and also in subdirectories named `build/`. For example, if editing `$SRC/gui/window.cpp`, we search in `$SRC/gui/`, `$SRC/gui/build/`, `$SRC/`, `$SRC/build/`, …
>  clangd 会在我们编辑的文件的父目录中寻找该文件，也会在 `build/` 目录中查找
>  例如，如果正在编辑 `$SRC/gui/window.cpp`，clangd 会搜索 `$SRC/gui/`、`$SRC/gui/build/`、`$SRC/`、`$SRC/build/` 等等

**Other build systems, using Bear**
[Bear](https://github.com/rizsotto/Bear) is a tool to generate a `compile_commands.json` file by recording a complete build.

For a `make`-based build, you can run `make clean; bear -- make` to generate the file (and run a clean build!).

On Windows, a tool similar to Bear called [compiledb](https://github.com/nickdiego/compiledb) can be used.

Other tools can also generate this file. See [the compile_commands.json specification](https://clang.llvm.org/docs/JSONCompilationDatabase.html).

### `compile_flags.txt`
If all files in a project use the same build flags, you can put those flags one-per-line in `compile_flags.txt` in your source root.
>  如果项目中的所有文件都使用相同的 build flags，我们可以将这些 flags 以每行一个的形式放在源代码根目录下的 `compile_flags.txt` 中

Clangd will assume the compile command is `clang $FLAGS some_file.cc`.
>  clangd 将假设编译命令为 `clang $FLAGS some_files.cc`

Creating this file by hand is a reasonable place to start if your project is quite simple. However background-indexing will not work, as clangd can’t be sure which of the files are project sources.
>  如果项目较简单，可以手动创建该文件，但后台索引将无法工作，因为 clangd 无法确定哪些文件是项目的源代码

This file will be ignored if `compile_commands.json` is present.
>  如果存在 `compile_commands.json` ，该文件将会被忽略


