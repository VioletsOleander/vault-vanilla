## 1.1 Introduction
The purpose of TableGen is to generate complex output files based on information from source files that are significantly easier to code than the output files would be, and also easier to maintain and modify over time. The information is coded in a declarative style involving classes and records, which are then processed by TableGen. 
>  TableGen 的目的是基于容易编码、容易维护的源文件的信息生成复杂的输出文件
>  源文件中，信息通过关于 classes 和 records 的声明式风格编码

The internalized records are passed on to various _backends_, which extract information from a subset of the records and generate one or more output files. These output files are typically `.inc` files for C++, but may be any type of file that the backend developer needs.
>  internalized records 会被传递给各种后端
>  后端从 records 的子集中提取信息，生成输出文件，通常是 C++ 文件，后缀为 `.inc` (意为 `include`，一般会被其他源文件和头文件 `#include` )

This document describes the LLVM TableGen facility in detail. It is intended for the programmer who is using TableGen to produce code for a project. If you are looking for a simple overview, check out the [TableGen Overview](https://llvm.org/docs/TableGen/index.html). The various `*-tblgen` commands used to invoke TableGen are described in [tblgen Family - Description to C++ Code](https://llvm.org/docs/CommandGuide/tblgen.html).

An example of a backend is `RegisterInfo`, which generates the register file information for a particular target machine, for use by the LLVM target-independent code generator. See [TableGen Backends](https://llvm.org/docs/TableGen/BackEnds.html) for a description of the LLVM TableGen backends, and [TableGen Backend Developer’s Guide](https://llvm.org/docs/TableGen/BackGuide.html) for a guide to writing a new backend.
>  一个示例后端是 `RegisterInfo` ，它为特定的目标机器生成注册文件信息，供 LLVM target-independent code generator 使用

Here are a few of the things backends can do.

- Generate the register file information for a particular target machine.
- Generate the instruction definitions for a target.
- Generate the patterns that the code generator uses to match instructions to intermediate representation (IR) nodes.
- Generate semantic attribute identifiers for Clang.
- Generate abstract syntax tree (AST) declaration node definitions for Clang.
- Generate AST statement node definitions for Clang.

>  后端可以执行的一些任务包括:
>  - 为特定目标机器生成注册文件信息
>  - 为目标生成指令定义
>  - 为代码生成器生成用于将指令和 IR nodes 匹配的模式
>  - 为 Clang 生成语义属性标识符
>  - 为 Clang 生成抽象语法树声明节点定义
>  - 为 Clang 生成抽象语法树声明节点定义

### 1.1.1 Concepts
TableGen source files contain two primary items: _abstract records_ and _concrete records_. In this and other TableGen documents, abstract records are called _classes._ (These classes are different from C++ classes and do not map onto them.) In addition, concrete records are usually just called records, although sometimes the term _record_ refers to both classes and concrete records. The distinction should be clear in context.
>  TableGen 源文件包含两个主要元素: abstract records, concrete records
>  abstract records 也称为 classes (并不等同于 C++ 中的类，且也不会映射到 C++ 中的类), concrete records 也称为 records

Classes and concrete records have a unique _name_, either chosen by the programmer or generated by TableGen. Associated with that name is a list of _fields_ with values and an optional list of _parent classes_ (sometimes called base or super classes). The fields are the primary data that backends will process. 
>  classes 和 concrete records 都具有唯一的名字，名字可以由程序员选择，也可以由 TableGen 生成
>  名字会关联一组带有值的 fields 和一个可选的 parent class 列表，fields 是后端将处理的主要数据

Note that TableGen assigns no meanings to fields; the meanings are entirely up to the backends and the programs that incorporate the output of those backends.
>  TableGen 不会为 fields 赋予任何特定含义，fields 的含义完全取决于后端以及接收后端输出的程序

Note
The term “parent class” can refer to a class that is a parent of another class, and also to a class from which a concrete record inherits. This nonstandard use of the term arises because TableGen treats classes and concrete records similarly.
>  Note: parent class 可以指 concrete record 的 parent class，也可以指 class 的 parent class

A backend processes some subset of the concrete records built by the TableGen parser and emits the output files. These files are usually C++ `.inc` files that are included by the programs that require the data in those records. 
>  后端负责处理由 TableGen parser 生成的 concrete records 的某个子集，并生成输出文件
>  输出文件通常是 C++ `.inc` 文件，`.inc` 文件会被需要这些 records 的 C++ 程序 `#include`

However, a backend can produce any type of output files. For example, it could produce a data file containing messages tagged with identifiers and substitution parameters. In a complex use case such as the LLVM code generator, there can be many concrete records and some of them can have an unexpectedly large number of fields, resulting in large output files.
>  后端实际上可以生成任何类型的输出文件
>  例如，它可以生成一个包含带标识符和替换参数的消息的数据文件，在复杂的用例，例如 LLVM code generator 中，可能会有许多 concrete records，且其中一些 records 可能具有非常多的 fields，故输出文件会非常大

In order to reduce the complexity of TableGen files, classes are used to abstract out groups of record fields. For example, a few classes may abstract the concept of a machine register file, while other classes may abstract the instruction formats, and still others may abstract the individual instructions. TableGen allows an arbitrary hierarchy of classes, so that the abstract classes for two concepts can share a third superclass that abstracts common “sub-concepts” from the two original concepts.
>  为了减少 TableGen 文件的复杂性，可以将一组 record fields 抽象为 class
>  例如，一些 classes 抽象出机器缓存文件的概念，一些 classes 抽象出指令格式，其他 classes 抽象出单独的指令
>  TableGen 允许任意的 classes 层次，故抽象出两个概念的 classes 可以共享另一个抽象出两个概念的公共子概念的 superclass

>  class 是对一组 record fields 的抽象，表征了一个概念

In order to make classes more useful, a concrete record (or another class) can request a class as a parent class and pass _template arguments_ to it. These template arguments can be used in the fields of the parent class to initialize them in a custom manner. 
>  concrete record 或 class 可以将一个 class 作为 parent class，并为其传递 template argument
>  这些 template arguments 可以在 parent class 的 fields 中使用，以自定义的方式对其初始化

That is, record or class `A` can request parent class `S` with one set of template arguments, while record or class `B` can request `S` with a different set of arguments. Without template arguments, many more classes would be required, one for each combination of the template arguments.
>  也就是说，假设 class `S` 同时是 `A, B` 的 parent class
>  则 record 或 class ` A ` 可以向 ` S ` 传递一组 template arguments，而 record 或 class `B` 可以向 `S` 传递另一组 template arguments
>  如果没有 template arguments，则我们需要为每种类型的的 template argument 组合分别定义 parent class

Both classes and concrete records can include fields that are uninitialized. The uninitialized “value” is represented by a question mark (`?`). Classes often have uninitialized fields that are expected to be filled in when those classes are inherited by concrete records. Even so, some fields of concrete records may remain uninitialized.
>  classes 和 concrete records 可以包含未初始化的 fields
>  未初始化的值用 `?` 表示
>  通常，class 都会包含未初始化的 fields，这些 fields 一般在 class 被 concrete record 继承之后被初始化
>  不过有时 concrete records 也会包含未初始化的 fields

TableGen provides _multiclasses_ to collect a group of record definitions in one place. A multiclass is a sort of macro that can be “invoked” to define multiple concrete records all at once. A multiclass can inherit from other multiclasses, which means that the multiclass inherits all the definitions from its parent multiclasses.
>  multiclass 用于将一组 record 定义放在同一个地方
>  multiclass 是一类类似于宏的结构，可以通过 “调用” 它来一次性定义多个 concrete record
>  一个 multiclass 可以继承自其他 multiclass，它将继承它的 parent multiclasses 的所有定义

[Appendix C: Sample Record](https://llvm.org/docs/TableGen/ProgRef.html#appendix-c-sample-record) illustrates a complex record in the Intel X86 target and the simple way in which it is defined.

## 1.2 Source Files
TableGen source files are plain ASCII text files. The files can contain statements, comments, and blank lines (see [Lexical Analysis](https://llvm.org/docs/TableGen/ProgRef.html#lexical-analysis)). The standard file extension for TableGen files is `.td`.
>  TableGen 源文件是纯 ASCII 文本文件，源文件可以包含 statements, comments, blank lines
>  TableGen 源文件的拓展名是 `.td`

TableGen files can grow quite large, so there is an include mechanism that allows one file to include the content of another file (see [Include Files](https://llvm.org/docs/TableGen/ProgRef.html#include-files)). This allows large files to be broken up into smaller ones, and also provides a simple library mechanism where multiple source files can include the same library file.
>  TableGen 提供了 include 机制

TableGen supports a simple preprocessor that can be used to conditionalize portions of `.td` files. See [Preprocessing Facilities](https://llvm.org/docs/TableGen/ProgRef.html#preprocessing-facilities) for more information.
>  TableGen 提供了简单的预处理器，用于条件化 `.td` 文件的部分内容

## 1.3 Lexical Analysis
The lexical and syntax notation used here is intended to imitate [Python’s](http://docs.python.org/py3k/reference/introduction.html#notation) notation. 
>  TableGen 的词法和语法符号模仿了 Python

In particular, for lexical definitions, the productions operate at the character level and there is no implied whitespace between elements. The syntax definitions operate at the token level, so there is implied whitespace between tokens.
>  词法定义的产生式在字符级别执行，即规则会检查单个字符，并根据模式将它们组合起来
>  语法定义的产生式在 token 级别执行
>  空白字符都会视作分离字符，会被丢弃

TableGen supports BCPL-style comments (`// ...`) and nestable C-style comments (`/* ... */`). TableGen also provides simple [Preprocessing Facilities](https://llvm.org/docs/TableGen/ProgRef.html#preprocessing-facilities).

Formfeed characters may be used freely in files to produce page breaks when the file is printed for review.
>  Formfeed 字符 (`/f`，一般用于告诉打印机换页) 可以在 TableGen 中使用

The following are the basic punctuation tokens:

```
- + [ ] { } ( ) < > : ; . ... = ? #
```

## 1.4 Types
The TableGen language is statically typed, using a simple but complete type system. Types are used to check for errors, to perform implicit conversions, and to help interface designers constrain the allowed input. Every value is required to have an associated type.
>  TableGen 语言为静态类型，所有值都要求有类型

TableGen supports a mixture of low-level types (e.g., `bit`) and high-level types (e.g., `dag`). This flexibility allows you to describe a wide range of records conveniently and compactly.

```
Type    ::=  "bit" | "int" | "string" | "dag" | "code"
            | "bits" "<" TokInteger ">"
            | "list" "<" Type ">"
            | ClassID
ClassID ::=  TokIdentifier
```

`bit`
A `bit` is a boolean value that can be 0 or 1.

`int`
The `int` type represents a simple 64-bit integer value, such as 5 or -42.

`string`
The `string` type represents an ordered sequence of characters of arbitrary length.

`code`
The keyword `code` is an alias for `string` which may be used to indicate string values that are code.

`bits<`_n_`>`
The `bits` type is a fixed-sized integer of arbitrary length _n_ that is treated as separate bits. These bits can be accessed individually. A field of this type is useful for representing an instruction operation code, register number, or address mode/register/displacement. The bits of the field can be set individually or as subfields. For example, in an instruction address, the addressing mode, base register number, and displacement can be set separately.

`list<`_type_`>`
This type represents a list whose elements are of the _type_ specified in angle brackets. The element type is arbitrary; it can even be another list type. List elements are indexed from 0.

`dag`
This type represents a nestable directed acyclic graph (DAG) of nodes. Each node has an _operator_ and zero or more _arguments_ (or _operands_). An argument can be another `dag` object, allowing an arbitrary tree of nodes and edges. As an example, DAGs are used to represent code patterns for use by the code generator instruction selection algorithms. See [Directed acyclic graphs (DAGs)](https://llvm.org/docs/TableGen/ProgRef.html#directed-acyclic-graphs-dags) for more details;

[`ClassID`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-ClassID)
Specifying a class name in a type context indicates that the type of the defined value must be a subclass of the specified class. This is useful in conjunction with the `list` type; for example, to constrain the elements of the list to a common base class (e.g., a `list<Register>` can only contain definitions derived from the `Register` class). The [`ClassID`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-ClassID) must name a class that has been previously declared or defined.

## 1.6 Statements
The following statements may appear at the top level of TableGen source files.

```
TableGenFile ::=  (Statement | IncludeDirective
                 | PreprocessorDirective)*
Statement    ::=  Assert | Class | Def | Defm | Defset | Deftype
                 | Defvar | Dump  | Foreach | If | Let | MultiClass
```

The following sections describe each of these top-level statements.

### 1.6.1 `class` — define an abstract record class
A `class` statement defines an abstract record class from which other classes and records can inherit.
>  `class` 定义 abstract record class，其目的是被继承

```
Class           ::=  "class" ClassID [TemplateArgList] RecordBody
TemplateArgList ::=  "<" TemplateArgDecl ("," TemplateArgDecl)* ">"
TemplateArgDecl ::=  Type TokIdentifier ["=" Value]
```

A class can be parameterized by a list of “template arguments,” whose values can be used in the class’s record body. These template arguments are specified each time the class is inherited by another class or record.
>  class 可以使用模板参数，模板参数的实际值在 class 被继承时被传递进来

If a template argument is not assigned a default value with `=`, it is uninitialized (has the “value” `?`) and must be specified in the template argument list when the class is inherited (required argument). If an argument is assigned a default value, then it need not be specified in the argument list (optional argument). In the declaration, all required template arguments must precede any optional arguments. The template argument default values are evaluated from left to right.
>  没有默认值的模板参数必须在被继承时指定

The [`RecordBody`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-RecordBody) is defined below. It can include a list of parent classes from which the current class inherits, along with field definitions and other statements. When a class `C` inherits from another class `D`, the fields of `D` are effectively merged into the fields of `C`.

A given class can only be defined once. A `class` statement is considered to define the class if _any_ of the following are true (the [`RecordBody`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-RecordBody) elements are described below).

- The [`TemplateArgList`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-TemplateArgList) is present, or
- The [`ParentClassList`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-ParentClassList) in the [`RecordBody`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-RecordBody) is present, or
- The [`Body`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-Body) in the [`RecordBody`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-RecordBody) is present and not empty.

You can declare an empty class by specifying an empty [`TemplateArgList`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-TemplateArgList) and an empty [`RecordBody`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-RecordBody). This can serve as a restricted form of forward declaration. Note that records derived from a forward-declared class will inherit no fields from it, because those records are built when their declarations are parsed, and thus before the class is finally defined.

Every class has an implicit template argument named `NAME` (uppercase), which is bound to the name of the [`Def`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-Def) or [`Defm`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-Defm) inheriting from the class. If the class is inherited by an anonymous record, the name is unspecified but globally unique.
>  所有的 class 都有一个隐式的模板参数 `NAME`，它绑定到继承了该 class 的 record 的名字

See [Examples: classes and records](https://llvm.org/docs/TableGen/ProgRef.html#examples-classes-and-records) for examples.

### 1.6.2 `def` — define a concrete record
A `def` statement defines a new concrete record.
>  `def` 语句定义 concrete record

```
Def       ::=  "def" [NameValue] RecordBody
NameValue ::=  Value (parsed in a special mode)
```

The name value is optional. If specified, it is parsed in a special mode where undefined (unrecognized) identifiers are interpreted as literal strings. In particular, global identifiers are considered unrecognized. These include global variables defined by `defvar` and `defset`. A record name can be the null string.

If no name value is given, the record is _anonymous_. The final name of an anonymous record is unspecified but globally unique.

Special handling occurs if a `def` appears inside a `multiclass` statement. See the `multiclass` section below for details.

A record can inherit from one or more classes by specifying the [`ParentClassList`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-ParentClassList) clause at the beginning of its record body. All of the fields in the parent classes are added to the record. If two or more parent classes provide the same field, the record ends up with the field value of the last parent class.
>  concrete record 可以继承 classes
>  parent classes 的所有 fields 都会被加入到 record 中，如果多个 parent classes 提供了相同的 field，则选择最后的 parent classes 的 field

As a special case, the name of a record can be passed as a template argument to that record’s parent classes. For example:

```
class A <dag d> {
  dag the_dag = d;
}

def rec1 : A<(ops rec1)>;
```

The DAG `(ops rec1)` is passed as a template argument to class `A`. Notice that the DAG includes `rec1`, the record being defined.

The steps taken to create a new record are somewhat complex. See [How records are built](https://llvm.org/docs/TableGen/ProgRef.html#how-records-are-built).

See [Examples: classes and records](https://llvm.org/docs/TableGen/ProgRef.html#examples-classes-and-records) for examples.

### 1.6.4 `let` — override fields in classes or records
A `let` statement collects a set of field values (sometimes called _bindings_) and applies them to all the classes and records defined by statements within the scope of the `let`.
>  `let` 将一组 field values (bindings) 应用到其作用域内所有的语句定义的 classes, records

```
Let     ::=   "let" LetList "in" "{" Statement* "}"
            | "let" LetList "in" Statement
LetList ::=  LetItem ("," LetItem)*
LetItem ::=  TokIdentifier ["<" RangeList ">"] "=" Value
```

The `let` statement establishes a scope, which is a sequence of statements in braces or a single statement with no braces. The bindings in the [`LetList`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-LetList) apply to the statements in that scope.
>  `let` 会构建一个作用域
>  作用域可以是 `{}` 中的一系列语句，也可以仅是一条语句
>  `let` 的所有 field values (bindings) 将适用于这一作用域中的所有语句

The field names in the [`LetList`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-LetList) must name fields in classes inherited by the classes and records defined in the statements. The field values are applied to the classes and records _after_ the records inherit all the fields from their parent classes. So the `let` acts to override inherited field values. A `let` cannot override the value of a template argument.
>  `let` 会覆盖继承的 field values，但不会覆盖 template argument 的 value

Top-level `let` statements are often useful when a few fields need to be overridden in several records. Here are two examples. Note that `let` statements can be nested.

```
let isTerminator = true, isReturn = true, isBarrier = true, hasCtrlDep = true in
  def RET : I<0xC3, RawFrm, (outs), (ins), "ret", [(X86retflag 0)]>;

let isCall = true in
  // All calls clobber the non-callee saved registers...
  let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,
              MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,
              XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {
    def CALLpcrel32 : Ii32<0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),
                           "call\t${dst:call}", []>;
    def CALL32r     : I<0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),
                        "call\t{*}$dst", [(X86call GR32:$dst)]>;
    def CALL32m     : I<0xFF, MRM2m, (outs), (ins i32mem:$dst, variable_ops),
                        "call\t{*}$dst", []>;
  }
```

Note that a top-level `let` will not override fields defined in the classes or records themselves.

## 1.7 Additional Details
### 1.7.1 Directed acyclic graphs (DAGs)
A directed acyclic graph can be represented directly in TableGen using the `dag` datatype. A DAG node consists of an operator and zero or more arguments (or operands). Each argument can be of any desired type. By using another DAG node as an argument, an arbitrary graph of DAG nodes can be built.
>  TableGen 中使用 `dag` 数据类型表示有向无环图
>  一个 DAG 节点由一个 operator 以及零个或多个 arguments 组成，arguements 可以是任意类型，包括 `dag`

The syntax of a `dag` instance is:

> `(` _operator_ _argument1_`,` _argument2_`,` … `)`

The operator must be present and must be a record. There can be zero or more arguments, separated by commas. The operator and arguments can have three formats.

>  `dag` 实例通过上述语法定义
>  operator 必须是已经定义的 record
>  operator, arguments 可以以以下三种语法定义

| Format           | Meaning                                        |
| :--------------- | :--------------------------------------------- |
| _value_          | argument value                                 |
| _value_`:`_name_ | argument value and associated name             |
| _name_           | argument name with unset (uninitialized) value |

The _value_ can be any TableGen value. The _name_, if present, must be a [`TokVarName`](https://llvm.org/docs/TableGen/ProgRef.html#grammar-token-TokVarName), which starts with a dollar sign (`$`). The purpose of a name is to tag an operator or argument in a DAG with a particular meaning, or to associate an argument in one DAG with a like-named argument in another DAG.

The following bang operators are useful for working with DAGs: `!con`, `!dag`, `!empty`, `!foreach`, `!getdagarg`, `!getdagname`, `!getdagop`, `!setdagarg`, `!setdagname`, `!setdagop`, `!size`.