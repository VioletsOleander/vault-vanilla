## 1.1 Introduction
The purpose of TableGen is to generate complex output files based on information from source files that are significantly easier to code than the output files would be, and also easier to maintain and modify over time. The information is coded in a declarative style involving classes and records, which are then processed by TableGen. 
>  TableGen 的目的是基于容易编码、容易维护的源文件的信息生成复杂的输出文件
>  源文件中，信息通过关于 classes 和 records 的声明式风格编码

The internalized records are passed on to various _backends_, which extract information from a subset of the records and generate one or more output files. These output files are typically `.inc` files for C++, but may be any type of file that the backend developer needs.
>  internalized records 会被传递给各种后端
>  后端从 records 的子集中提取信息，生成输出文件，通常是 C++ 文件，后缀为 `.inc` (意为 `include`，一般会被其他源文件和头文件 `#include` )

This document describes the LLVM TableGen facility in detail. It is intended for the programmer who is using TableGen to produce code for a project. If you are looking for a simple overview, check out the [TableGen Overview](https://llvm.org/docs/TableGen/index.html). The various `*-tblgen` commands used to invoke TableGen are described in [tblgen Family - Description to C++ Code](https://llvm.org/docs/CommandGuide/tblgen.html).

An example of a backend is `RegisterInfo`, which generates the register file information for a particular target machine, for use by the LLVM target-independent code generator. See [TableGen Backends](https://llvm.org/docs/TableGen/BackEnds.html) for a description of the LLVM TableGen backends, and [TableGen Backend Developer’s Guide](https://llvm.org/docs/TableGen/BackGuide.html) for a guide to writing a new backend.
>  一个示例后端是 `RegisterInfo` ，它为特定的目标机器生成注册文件信息，供 LLVM target-independent code generator 使用

Here are a few of the things backends can do.

- Generate the register file information for a particular target machine.
- Generate the instruction definitions for a target.
- Generate the patterns that the code generator uses to match instructions to intermediate representation (IR) nodes.
- Generate semantic attribute identifiers for Clang.
- Generate abstract syntax tree (AST) declaration node definitions for Clang.
- Generate AST statement node definitions for Clang.

>  后端可以执行的一些任务包括:
>  - 为特定目标机器生成注册文件信息
>  - 为目标生成指令定义
>  - 为代码生成器生成用于将指令和 IR nodes 匹配的模式
>  - 为 Clang 生成语义属性标识符
>  - 为 Clang 生成抽象语法树声明节点定义
>  - 为 Clang 生成抽象语法树声明节点定义

### 1.1.1 Concepts
TableGen source files contain two primary items: _abstract records_ and _concrete records_. In this and other TableGen documents, abstract records are called _classes._ (These classes are different from C++ classes and do not map onto them.) In addition, concrete records are usually just called records, although sometimes the term _record_ refers to both classes and concrete records. The distinction should be clear in context.
>  TableGen 源文件包含两个主要元素: abstract records, concrete records
>  abstract records 也称为 classes (并不等同于 C++ 中的类，且也不会映射到 C++ 中的类), concrete records 也称为 records

Classes and concrete records have a unique _name_, either chosen by the programmer or generated by TableGen. Associated with that name is a list of _fields_ with values and an optional list of _parent classes_ (sometimes called base or super classes). The fields are the primary data that backends will process. 
>  classes 和 concrete records 都具有唯一的名字，名字可以有程序员选择，也可以由 TableGen 生成
>  名字会关联一组带有值的 fields 和一个可选的 parent class 列表，fields 是后端将处理的主要数据

Note that TableGen assigns no meanings to fields; the meanings are entirely up to the backends and the programs that incorporate the output of those backends.
>  TableGen 不会为 fields 赋予任何特定含义，fields 的含义完全取决于后端以及接收后端输出的程序

Note
The term “parent class” can refer to a class that is a parent of another class, and also to a class from which a concrete record inherits. This nonstandard use of the term arises because TableGen treats classes and concrete records similarly.
>  Note: parent class 可以指 concrete record 的 parent class，也可以指 class 的 parent class

A backend processes some subset of the concrete records built by the TableGen parser and emits the output files. These files are usually C++ `.inc` files that are included by the programs that require the data in those records. 
>  后端负责处理由 TableGen parser 生成的 concrete records 的某个子集，并生成输出文件
>  输出文件通常是 C++ `.inc` 文件，`.inc` 文件会被需要这些 records 的 C++ 程序 `#include`

However, a backend can produce any type of output files. For example, it could produce a data file containing messages tagged with identifiers and substitution parameters. In a complex use case such as the LLVM code generator, there can be many concrete records and some of them can have an unexpectedly large number of fields, resulting in large output files.
>  后端实际上可以生成任何类型的输出文件
>  例如，它可以生成一个包含带标识符和替换参数的消息的数据文件，在复杂的用例，例如 LLVM code generator 中，可能会有许多 concrete records，且其中一些 records 可能具有非常多的 fields，故输出文件会非常大

In order to reduce the complexity of TableGen files, classes are used to abstract out groups of record fields. For example, a few classes may abstract the concept of a machine register file, while other classes may abstract the instruction formats, and still others may abstract the individual instructions. TableGen allows an arbitrary hierarchy of classes, so that the abstract classes for two concepts can share a third superclass that abstracts common “sub-concepts” from the two original concepts.
>  为了减少 TableGen 文件的复杂性，可以将一组 record fields 抽象为 class
>  例如，一些 classes 抽象出机器缓存文件的概念，一些 classes 抽象出指令格式，其他 classes 抽象出单独的指令
>  TableGen 允许任意的 classes 层次，故抽象出两个概念的 classes 可以共享另一个抽象出两个概念的公共子概念的 superclass

>  class 是对一组 record fields 的抽象，表征了一个概念

In order to make classes more useful, a concrete record (or another class) can request a class as a parent class and pass _template arguments_ to it. These template arguments can be used in the fields of the parent class to initialize them in a custom manner. 
>  concrete record 或 class 可以将一个 class 作为 parent class，并为其传递 template argument
>  这些 template arguments 可以在 parent class 的 fields 中使用，以自定义的方式对其初始化

That is, record or class `A` can request parent class `S` with one set of template arguments, while record or class `B` can request `S` with a different set of arguments. Without template arguments, many more classes would be required, one for each combination of the template arguments.
>  也就是说，假设 class `S` 同时是 `A, B` 的 parent class
>  则 record 或 class ` A ` 可以 ` S ` 传递一组 template arguments，而 record 或 class `B` 可以向 `S` 传递另一组 template arguments
>  如果没有 template arguments，则我们需要为每种类型的的 template argument 组合分别定义 parent class

Both classes and concrete records can include fields that are uninitialized. The uninitialized “value” is represented by a question mark (`?`). Classes often have uninitialized fields that are expected to be filled in when those classes are inherited by concrete records. Even so, some fields of concrete records may remain uninitialized.
>  classes 和 concrete records 可以包含未初始化的 fields
>  未初始化的值用 `?` 表示
>  通常，class 都会包含未初始化的 fields，这些 fields 一般在 class 被 concrete record 继承之后被初始化
>  不过有时 concrete records 也会包含未初始化的 fields

TableGen provides _multiclasses_ to collect a group of record definitions in one place. A multiclass is a sort of macro that can be “invoked” to define multiple concrete records all at once. A multiclass can inherit from other multiclasses, which means that the multiclass inherits all the definitions from its parent multiclasses.
>  multiclass 用于将一组 record 定义放在同一个地方
>  multiclass 是一类类似于宏的结构，可以通过 “调用” 它来一次性定义多个 concrete record
>  一个 multiclass 可以继承自其他 multiclass，它将继承它的 parent multiclasses 的所有定义

[Appendix C: Sample Record](https://llvm.org/docs/TableGen/ProgRef.html#appendix-c-sample-record) illustrates a complex record in the Intel X86 target and the simple way in which it is defined.

## 1.2 Source Files
TableGen source files are plain ASCII text files. The files can contain statements, comments, and blank lines (see [Lexical Analysis](https://llvm.org/docs/TableGen/ProgRef.html#lexical-analysis)). The standard file extension for TableGen files is `.td`.
>  TableGen 源文件是纯 ASCII 文本文件，源文件可以包含 statements, comments, blank lines
>  TableGen 源文件的拓展名是 `.td`

TableGen files can grow quite large, so there is an include mechanism that allows one file to include the content of another file (see [Include Files](https://llvm.org/docs/TableGen/ProgRef.html#include-files)). This allows large files to be broken up into smaller ones, and also provides a simple library mechanism where multiple source files can include the same library file.
>  TableGen 提供了 include 机制

TableGen supports a simple preprocessor that can be used to conditionalize portions of `.td` files. See [Preprocessing Facilities](https://llvm.org/docs/TableGen/ProgRef.html#preprocessing-facilities) for more information.
>  TableGen 提供了简单的预处理器，用于条件化 `.td` 文件的部分内容